/* automatically generated by rust-bindgen 0.55.1 */

pub const NM_DBUS_SERVICE: &'static [u8; 31usize] = b"org.freedesktop.NetworkManager\0";
pub const NM_DBUS_INTERFACE: &'static [u8; 31usize] = b"org.freedesktop.NetworkManager\0";
pub const NM_DBUS_INTERFACE_ACCESS_POINT: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.AccessPoint\0";
pub const NM_DBUS_INTERFACE_ACTIVE_CONNECTION: &'static [u8; 49usize] =
    b"org.freedesktop.NetworkManager.Connection.Active\0";
pub const NM_DBUS_INTERFACE_CHECKPOINT: &'static [u8; 42usize] =
    b"org.freedesktop.NetworkManager.Checkpoint\0";
pub const NM_DBUS_INTERFACE_DEVICE: &'static [u8; 38usize] =
    b"org.freedesktop.NetworkManager.Device\0";
pub const NM_DBUS_INTERFACE_DEVICE_6LOWPAN: &'static [u8; 45usize] =
    b"org.freedesktop.NetworkManager.Device.Lowpan\0";
pub const NM_DBUS_INTERFACE_DEVICE_ADSL: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.Device.Adsl\0";
pub const NM_DBUS_INTERFACE_DEVICE_BLUETOOTH: &'static [u8; 48usize] =
    b"org.freedesktop.NetworkManager.Device.Bluetooth\0";
pub const NM_DBUS_INTERFACE_DEVICE_BOND: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.Device.Bond\0";
pub const NM_DBUS_INTERFACE_DEVICE_BRIDGE: &'static [u8; 45usize] =
    b"org.freedesktop.NetworkManager.Device.Bridge\0";
pub const NM_DBUS_INTERFACE_DEVICE_DUMMY: &'static [u8; 44usize] =
    b"org.freedesktop.NetworkManager.Device.Dummy\0";
pub const NM_DBUS_INTERFACE_DEVICE_GENERIC: &'static [u8; 46usize] =
    b"org.freedesktop.NetworkManager.Device.Generic\0";
pub const NM_DBUS_INTERFACE_DEVICE_GRE: &'static [u8; 42usize] =
    b"org.freedesktop.NetworkManager.Device.Gre\0";
pub const NM_DBUS_INTERFACE_DEVICE_INFINIBAND: &'static [u8; 49usize] =
    b"org.freedesktop.NetworkManager.Device.Infiniband\0";
pub const NM_DBUS_INTERFACE_DEVICE_IP_TUNNEL: &'static [u8; 47usize] =
    b"org.freedesktop.NetworkManager.Device.IPTunnel\0";
pub const NM_DBUS_INTERFACE_DEVICE_MACSEC: &'static [u8; 45usize] =
    b"org.freedesktop.NetworkManager.Device.Macsec\0";
pub const NM_DBUS_INTERFACE_DEVICE_MACVLAN: &'static [u8; 46usize] =
    b"org.freedesktop.NetworkManager.Device.Macvlan\0";
pub const NM_DBUS_INTERFACE_DEVICE_MODEM: &'static [u8; 44usize] =
    b"org.freedesktop.NetworkManager.Device.Modem\0";
pub const NM_DBUS_INTERFACE_DEVICE_OLPC_MESH: &'static [u8; 47usize] =
    b"org.freedesktop.NetworkManager.Device.OlpcMesh\0";
pub const NM_DBUS_INTERFACE_DEVICE_OVS_BRIDGE: &'static [u8; 48usize] =
    b"org.freedesktop.NetworkManager.Device.OvsBridge\0";
pub const NM_DBUS_INTERFACE_DEVICE_OVS_INTERFACE: &'static [u8; 51usize] =
    b"org.freedesktop.NetworkManager.Device.OvsInterface\0";
pub const NM_DBUS_INTERFACE_DEVICE_OVS_PORT: &'static [u8; 46usize] =
    b"org.freedesktop.NetworkManager.Device.OvsPort\0";
pub const NM_DBUS_INTERFACE_DEVICE_PPP: &'static [u8; 42usize] =
    b"org.freedesktop.NetworkManager.Device.Ppp\0";
pub const NM_DBUS_INTERFACE_DEVICE_STATISTICS: &'static [u8; 49usize] =
    b"org.freedesktop.NetworkManager.Device.Statistics\0";
pub const NM_DBUS_INTERFACE_DEVICE_TEAM: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.Device.Team\0";
pub const NM_DBUS_INTERFACE_DEVICE_TUN: &'static [u8; 42usize] =
    b"org.freedesktop.NetworkManager.Device.Tun\0";
pub const NM_DBUS_INTERFACE_DEVICE_VETH: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.Device.Veth\0";
pub const NM_DBUS_INTERFACE_DEVICE_VLAN: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.Device.Vlan\0";
pub const NM_DBUS_INTERFACE_DEVICE_VRF: &'static [u8; 42usize] =
    b"org.freedesktop.NetworkManager.Device.Vrf\0";
pub const NM_DBUS_INTERFACE_DEVICE_VXLAN: &'static [u8; 44usize] =
    b"org.freedesktop.NetworkManager.Device.Vxlan\0";
pub const NM_DBUS_INTERFACE_DEVICE_WIFI_P2P: &'static [u8; 46usize] =
    b"org.freedesktop.NetworkManager.Device.WifiP2P\0";
pub const NM_DBUS_INTERFACE_DEVICE_WIMAX: &'static [u8; 44usize] =
    b"org.freedesktop.NetworkManager.Device.WiMax\0";
pub const NM_DBUS_INTERFACE_DEVICE_WIRED: &'static [u8; 44usize] =
    b"org.freedesktop.NetworkManager.Device.Wired\0";
pub const NM_DBUS_INTERFACE_DEVICE_WIREGUARD: &'static [u8; 48usize] =
    b"org.freedesktop.NetworkManager.Device.WireGuard\0";
pub const NM_DBUS_INTERFACE_DEVICE_WIRELESS: &'static [u8; 47usize] =
    b"org.freedesktop.NetworkManager.Device.Wireless\0";
pub const NM_DBUS_INTERFACE_DEVICE_WPAN: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.Device.Wpan\0";
pub const NM_DBUS_INTERFACE_DHCP4_CONFIG: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.DHCP4Config\0";
pub const NM_DBUS_INTERFACE_DHCP6_CONFIG: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.DHCP6Config\0";
pub const NM_DBUS_INTERFACE_IP4_CONFIG: &'static [u8; 41usize] =
    b"org.freedesktop.NetworkManager.IP4Config\0";
pub const NM_DBUS_INTERFACE_IP6_CONFIG: &'static [u8; 41usize] =
    b"org.freedesktop.NetworkManager.IP6Config\0";
pub const NM_DBUS_INTERFACE_WIFI_P2P_PEER: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.WifiP2PPeer\0";
pub const NM_DBUS_INTERFACE_WIMAX_NSP: &'static [u8; 41usize] =
    b"org.freedesktop.NetworkManager.WiMax.Nsp\0";
pub const NM_DBUS_PATH: &'static [u8; 32usize] = b"/org/freedesktop/NetworkManager\0";
pub const NM_DBUS_PATH_ACCESS_POINT: &'static [u8; 44usize] =
    b"/org/freedesktop/NetworkManager/AccessPoint\0";
pub const NM_DBUS_PATH_WIFI_P2P_PEER: &'static [u8; 44usize] =
    b"/org/freedesktop/NetworkManager/WifiP2PPeer\0";
pub const NM_DBUS_PATH_WIMAX_NSP: &'static [u8; 36usize] = b"/org/freedesktop/NetworkManager/Nsp\0";
pub const NM_DBUS_INTERFACE_SETTINGS: &'static [u8; 40usize] =
    b"org.freedesktop.NetworkManager.Settings\0";
pub const NM_DBUS_PATH_SETTINGS: &'static [u8; 41usize] =
    b"/org/freedesktop/NetworkManager/Settings\0";
pub const NM_DBUS_INTERFACE_SETTINGS_CONNECTION: &'static [u8; 51usize] =
    b"org.freedesktop.NetworkManager.Settings.Connection\0";
pub const NM_DBUS_PATH_SETTINGS_CONNECTION: &'static [u8; 52usize] =
    b"/org/freedesktop/NetworkManager/Settings/Connection\0";
pub const NM_DBUS_INTERFACE_SETTINGS_CONNECTION_SECRETS: &'static [u8; 59usize] =
    b"org.freedesktop.NetworkManager.Settings.Connection.Secrets\0";
pub const NM_DBUS_INTERFACE_AGENT_MANAGER: &'static [u8; 44usize] =
    b"org.freedesktop.NetworkManager.AgentManager\0";
pub const NM_DBUS_PATH_AGENT_MANAGER: &'static [u8; 45usize] =
    b"/org/freedesktop/NetworkManager/AgentManager\0";
pub const NM_DBUS_INTERFACE_SECRET_AGENT: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.SecretAgent\0";
pub const NM_DBUS_PATH_SECRET_AGENT: &'static [u8; 44usize] =
    b"/org/freedesktop/NetworkManager/SecretAgent\0";
pub const NM_DBUS_INTERFACE_DNS_MANAGER: &'static [u8; 42usize] =
    b"org.freedesktop.NetworkManager.DnsManager\0";
pub const NM_DBUS_PATH_DNS_MANAGER: &'static [u8; 43usize] =
    b"/org/freedesktop/NetworkManager/DnsManager\0";
pub const NM_LLDP_ATTR_RAW: &'static [u8; 4usize] = b"raw\0";
pub const NM_LLDP_ATTR_DESTINATION: &'static [u8; 12usize] = b"destination\0";
pub const NM_LLDP_ATTR_CHASSIS_ID_TYPE: &'static [u8; 16usize] = b"chassis-id-type\0";
pub const NM_LLDP_ATTR_CHASSIS_ID: &'static [u8; 11usize] = b"chassis-id\0";
pub const NM_LLDP_ATTR_PORT_ID_TYPE: &'static [u8; 13usize] = b"port-id-type\0";
pub const NM_LLDP_ATTR_PORT_ID: &'static [u8; 8usize] = b"port-id\0";
pub const NM_LLDP_ATTR_PORT_DESCRIPTION: &'static [u8; 17usize] = b"port-description\0";
pub const NM_LLDP_ATTR_SYSTEM_NAME: &'static [u8; 12usize] = b"system-name\0";
pub const NM_LLDP_ATTR_SYSTEM_DESCRIPTION: &'static [u8; 19usize] = b"system-description\0";
pub const NM_LLDP_ATTR_SYSTEM_CAPABILITIES: &'static [u8; 20usize] = b"system-capabilities\0";
pub const NM_LLDP_ATTR_MANAGEMENT_ADDRESSES: &'static [u8; 21usize] = b"management-addresses\0";
pub const NM_LLDP_ATTR_IEEE_802_1_PVID: &'static [u8; 16usize] = b"ieee-802-1-pvid\0";
pub const NM_LLDP_ATTR_IEEE_802_1_VLANS: &'static [u8; 17usize] = b"ieee-802-1-vlans\0";
pub const NM_LLDP_ATTR_IEEE_802_1_PPVIDS: &'static [u8; 18usize] = b"ieee-802-1-ppvids\0";
pub const NM_LLDP_ATTR_IEEE_802_3_MAC_PHY_CONF: &'static [u8; 24usize] =
    b"ieee-802-3-mac-phy-conf\0";
pub const NM_LLDP_ATTR_IEEE_802_3_POWER_VIA_MDI: &'static [u8; 25usize] =
    b"ieee-802-3-power-via-mdi\0";
pub const NM_LLDP_ATTR_IEEE_802_3_MAX_FRAME_SIZE: &'static [u8; 26usize] =
    b"ieee-802-3-max-frame-size\0";
pub const NM_LLDP_ATTR_MUD_URL: &'static [u8; 8usize] = b"mud-url\0";
pub const NM_LLDP_ATTR_IEEE_802_1_VID: &'static [u8; 15usize] = b"ieee-802-1-vid\0";
pub const NM_LLDP_ATTR_IEEE_802_1_VLAN_NAME: &'static [u8; 21usize] = b"ieee-802-1-vlan-name\0";
pub const NM_LLDP_ATTR_IEEE_802_1_PPVID: &'static [u8; 17usize] = b"ieee-802-1-ppvid\0";
pub const NM_LLDP_ATTR_IEEE_802_1_PPVID_FLAGS: &'static [u8; 23usize] = b"ieee-802-1-ppvid-flags\0";
pub const NM_LLDP_DEST_NEAREST_BRIDGE: &'static [u8; 15usize] = b"nearest-bridge\0";
pub const NM_LLDP_DEST_NEAREST_NON_TPMR_BRIDGE: &'static [u8; 24usize] =
    b"nearest-non-tpmr-bridge\0";
pub const NM_LLDP_DEST_NEAREST_CUSTOMER_BRIDGE: &'static [u8; 24usize] =
    b"nearest-customer-bridge\0";
pub const NM_MAJOR_VERSION: u32 = 1;
pub const NM_MINOR_VERSION: u32 = 26;
pub const NM_MICRO_VERSION: u32 = 2;
pub const NM_SETTING_PARAM_REQUIRED: u32 = 512;
pub const NM_SETTING_PARAM_SECRET: u32 = 1024;
pub const NM_SETTING_PARAM_FUZZY_IGNORE: u32 = 2048;
pub const NM_SETTING_NAME: &'static [u8; 5usize] = b"name\0";
pub const NM_CONNECTION_SECRETS_UPDATED: &'static [u8; 16usize] = b"secrets-updated\0";
pub const NM_CONNECTION_SECRETS_CLEARED: &'static [u8; 16usize] = b"secrets-cleared\0";
pub const NM_CONNECTION_CHANGED: &'static [u8; 8usize] = b"changed\0";
pub const NM_CONNECTION_NORMALIZE_PARAM_IP6_CONFIG_METHOD: &'static [u8; 18usize] =
    b"ip6-config-method\0";
pub const NM_OBJECT_PATH: &'static [u8; 5usize] = b"path\0";
pub const NM_ACCESS_POINT_FLAGS: &'static [u8; 6usize] = b"flags\0";
pub const NM_ACCESS_POINT_WPA_FLAGS: &'static [u8; 10usize] = b"wpa-flags\0";
pub const NM_ACCESS_POINT_RSN_FLAGS: &'static [u8; 10usize] = b"rsn-flags\0";
pub const NM_ACCESS_POINT_SSID: &'static [u8; 5usize] = b"ssid\0";
pub const NM_ACCESS_POINT_BSSID: &'static [u8; 6usize] = b"bssid\0";
pub const NM_ACCESS_POINT_FREQUENCY: &'static [u8; 10usize] = b"frequency\0";
pub const NM_ACCESS_POINT_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_ACCESS_POINT_MAX_BITRATE: &'static [u8; 12usize] = b"max-bitrate\0";
pub const NM_ACCESS_POINT_STRENGTH: &'static [u8; 9usize] = b"strength\0";
pub const NM_ACCESS_POINT_LAST_SEEN: &'static [u8; 10usize] = b"last-seen\0";
pub const NM_ACCESS_POINT_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_ACTIVE_CONNECTION_CONNECTION: &'static [u8; 11usize] = b"connection\0";
pub const NM_ACTIVE_CONNECTION_ID: &'static [u8; 3usize] = b"id\0";
pub const NM_ACTIVE_CONNECTION_UUID: &'static [u8; 5usize] = b"uuid\0";
pub const NM_ACTIVE_CONNECTION_TYPE: &'static [u8; 5usize] = b"type\0";
pub const NM_ACTIVE_CONNECTION_SPECIFIC_OBJECT_PATH: &'static [u8; 21usize] =
    b"specific-object-path\0";
pub const NM_ACTIVE_CONNECTION_DEVICES: &'static [u8; 8usize] = b"devices\0";
pub const NM_ACTIVE_CONNECTION_STATE: &'static [u8; 6usize] = b"state\0";
pub const NM_ACTIVE_CONNECTION_STATE_FLAGS: &'static [u8; 12usize] = b"state-flags\0";
pub const NM_ACTIVE_CONNECTION_DEFAULT: &'static [u8; 8usize] = b"default\0";
pub const NM_ACTIVE_CONNECTION_IP4_CONFIG: &'static [u8; 11usize] = b"ip4-config\0";
pub const NM_ACTIVE_CONNECTION_DHCP4_CONFIG: &'static [u8; 13usize] = b"dhcp4-config\0";
pub const NM_ACTIVE_CONNECTION_DEFAULT6: &'static [u8; 9usize] = b"default6\0";
pub const NM_ACTIVE_CONNECTION_IP6_CONFIG: &'static [u8; 11usize] = b"ip6-config\0";
pub const NM_ACTIVE_CONNECTION_DHCP6_CONFIG: &'static [u8; 13usize] = b"dhcp6-config\0";
pub const NM_ACTIVE_CONNECTION_VPN: &'static [u8; 4usize] = b"vpn\0";
pub const NM_ACTIVE_CONNECTION_MASTER: &'static [u8; 7usize] = b"master\0";
pub const NM_CLIENT_VERSION: &'static [u8; 8usize] = b"version\0";
pub const NM_CLIENT_STATE: &'static [u8; 6usize] = b"state\0";
pub const NM_CLIENT_STARTUP: &'static [u8; 8usize] = b"startup\0";
pub const NM_CLIENT_NM_RUNNING: &'static [u8; 11usize] = b"nm-running\0";
pub const NM_CLIENT_DBUS_CONNECTION: &'static [u8; 16usize] = b"dbus-connection\0";
pub const NM_CLIENT_DBUS_NAME_OWNER: &'static [u8; 16usize] = b"dbus-name-owner\0";
pub const NM_CLIENT_INSTANCE_FLAGS: &'static [u8; 15usize] = b"instance-flags\0";
pub const NM_CLIENT_NETWORKING_ENABLED: &'static [u8; 19usize] = b"networking-enabled\0";
pub const NM_CLIENT_WIRELESS_ENABLED: &'static [u8; 17usize] = b"wireless-enabled\0";
pub const NM_CLIENT_WWAN_ENABLED: &'static [u8; 13usize] = b"wwan-enabled\0";
pub const NM_CLIENT_WIMAX_ENABLED: &'static [u8; 14usize] = b"wimax-enabled\0";
pub const NM_CLIENT_WIRELESS_HARDWARE_ENABLED: &'static [u8; 26usize] =
    b"wireless-hardware-enabled\0";
pub const NM_CLIENT_WWAN_HARDWARE_ENABLED: &'static [u8; 22usize] = b"wwan-hardware-enabled\0";
pub const NM_CLIENT_WIMAX_HARDWARE_ENABLED: &'static [u8; 23usize] = b"wimax-hardware-enabled\0";
pub const NM_CLIENT_ACTIVE_CONNECTIONS: &'static [u8; 19usize] = b"active-connections\0";
pub const NM_CLIENT_CONNECTIVITY: &'static [u8; 13usize] = b"connectivity\0";
pub const NM_CLIENT_CONNECTIVITY_CHECK_URI: &'static [u8; 23usize] = b"connectivity-check-uri\0";
pub const NM_CLIENT_CONNECTIVITY_CHECK_AVAILABLE: &'static [u8; 29usize] =
    b"connectivity-check-available\0";
pub const NM_CLIENT_CONNECTIVITY_CHECK_ENABLED: &'static [u8; 27usize] =
    b"connectivity-check-enabled\0";
pub const NM_CLIENT_PRIMARY_CONNECTION: &'static [u8; 19usize] = b"primary-connection\0";
pub const NM_CLIENT_ACTIVATING_CONNECTION: &'static [u8; 22usize] = b"activating-connection\0";
pub const NM_CLIENT_DEVICES: &'static [u8; 8usize] = b"devices\0";
pub const NM_CLIENT_ALL_DEVICES: &'static [u8; 12usize] = b"all-devices\0";
pub const NM_CLIENT_CONNECTIONS: &'static [u8; 12usize] = b"connections\0";
pub const NM_CLIENT_HOSTNAME: &'static [u8; 9usize] = b"hostname\0";
pub const NM_CLIENT_CAN_MODIFY: &'static [u8; 11usize] = b"can-modify\0";
pub const NM_CLIENT_METERED: &'static [u8; 8usize] = b"metered\0";
pub const NM_CLIENT_DNS_MODE: &'static [u8; 9usize] = b"dns-mode\0";
pub const NM_CLIENT_DNS_RC_MANAGER: &'static [u8; 15usize] = b"dns-rc-manager\0";
pub const NM_CLIENT_DNS_CONFIGURATION: &'static [u8; 18usize] = b"dns-configuration\0";
pub const NM_CLIENT_CHECKPOINTS: &'static [u8; 12usize] = b"checkpoints\0";
pub const NM_CLIENT_CAPABILITIES: &'static [u8; 13usize] = b"capabilities\0";
pub const NM_CLIENT_PERMISSIONS_STATE: &'static [u8; 18usize] = b"permissions-state\0";
pub const NM_CLIENT_DEVICE_ADDED: &'static [u8; 13usize] = b"device-added\0";
pub const NM_CLIENT_DEVICE_REMOVED: &'static [u8; 15usize] = b"device-removed\0";
pub const NM_CLIENT_ANY_DEVICE_ADDED: &'static [u8; 17usize] = b"any-device-added\0";
pub const NM_CLIENT_ANY_DEVICE_REMOVED: &'static [u8; 19usize] = b"any-device-removed\0";
pub const NM_CLIENT_PERMISSION_CHANGED: &'static [u8; 19usize] = b"permission-changed\0";
pub const NM_CLIENT_CONNECTION_ADDED: &'static [u8; 17usize] = b"connection-added\0";
pub const NM_CLIENT_CONNECTION_REMOVED: &'static [u8; 19usize] = b"connection-removed\0";
pub const NM_CLIENT_ACTIVE_CONNECTION_ADDED: &'static [u8; 24usize] = b"active-connection-added\0";
pub const NM_CLIENT_ACTIVE_CONNECTION_REMOVED: &'static [u8; 26usize] =
    b"active-connection-removed\0";
pub const NM_DEVICE_DEVICE_TYPE: &'static [u8; 12usize] = b"device-type\0";
pub const NM_DEVICE_UDI: &'static [u8; 4usize] = b"udi\0";
pub const NM_DEVICE_PATH: &'static [u8; 5usize] = b"path\0";
pub const NM_DEVICE_INTERFACE: &'static [u8; 10usize] = b"interface\0";
pub const NM_DEVICE_IP_INTERFACE: &'static [u8; 13usize] = b"ip-interface\0";
pub const NM_DEVICE_DRIVER: &'static [u8; 7usize] = b"driver\0";
pub const NM_DEVICE_DRIVER_VERSION: &'static [u8; 15usize] = b"driver-version\0";
pub const NM_DEVICE_FIRMWARE_VERSION: &'static [u8; 17usize] = b"firmware-version\0";
pub const NM_DEVICE_CAPABILITIES: &'static [u8; 13usize] = b"capabilities\0";
pub const NM_DEVICE_REAL: &'static [u8; 5usize] = b"real\0";
pub const NM_DEVICE_MANAGED: &'static [u8; 8usize] = b"managed\0";
pub const NM_DEVICE_AUTOCONNECT: &'static [u8; 12usize] = b"autoconnect\0";
pub const NM_DEVICE_FIRMWARE_MISSING: &'static [u8; 17usize] = b"firmware-missing\0";
pub const NM_DEVICE_NM_PLUGIN_MISSING: &'static [u8; 18usize] = b"nm-plugin-missing\0";
pub const NM_DEVICE_IP4_CONFIG: &'static [u8; 11usize] = b"ip4-config\0";
pub const NM_DEVICE_DHCP4_CONFIG: &'static [u8; 13usize] = b"dhcp4-config\0";
pub const NM_DEVICE_IP6_CONFIG: &'static [u8; 11usize] = b"ip6-config\0";
pub const NM_DEVICE_DHCP6_CONFIG: &'static [u8; 13usize] = b"dhcp6-config\0";
pub const NM_DEVICE_STATE: &'static [u8; 6usize] = b"state\0";
pub const NM_DEVICE_STATE_REASON: &'static [u8; 13usize] = b"state-reason\0";
pub const NM_DEVICE_ACTIVE_CONNECTION: &'static [u8; 18usize] = b"active-connection\0";
pub const NM_DEVICE_AVAILABLE_CONNECTIONS: &'static [u8; 22usize] = b"available-connections\0";
pub const NM_DEVICE_VENDOR: &'static [u8; 7usize] = b"vendor\0";
pub const NM_DEVICE_PRODUCT: &'static [u8; 8usize] = b"product\0";
pub const NM_DEVICE_PHYSICAL_PORT_ID: &'static [u8; 17usize] = b"physical-port-id\0";
pub const NM_DEVICE_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_DEVICE_METERED: &'static [u8; 8usize] = b"metered\0";
pub const NM_DEVICE_LLDP_NEIGHBORS: &'static [u8; 15usize] = b"lldp-neighbors\0";
pub const NM_DEVICE_IP4_CONNECTIVITY: &'static [u8; 17usize] = b"ip4-connectivity\0";
pub const NM_DEVICE_IP6_CONNECTIVITY: &'static [u8; 17usize] = b"ip6-connectivity\0";
pub const NM_DEVICE_INTERFACE_FLAGS: &'static [u8; 16usize] = b"interface-flags\0";
pub const NM_DEVICE_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_6LOWPAN_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_DEVICE_6LOWPAN_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_ADSL_CARRIER: &'static [u8; 8usize] = b"carrier\0";
pub const NM_DEVICE_BOND_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_BOND_CARRIER: &'static [u8; 8usize] = b"carrier\0";
pub const NM_DEVICE_BOND_SLAVES: &'static [u8; 7usize] = b"slaves\0";
pub const NM_DEVICE_BRIDGE_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_BRIDGE_CARRIER: &'static [u8; 8usize] = b"carrier\0";
pub const NM_DEVICE_BRIDGE_SLAVES: &'static [u8; 7usize] = b"slaves\0";
pub const NM_DEVICE_BT_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_BT_NAME: &'static [u8; 5usize] = b"name\0";
pub const NM_DEVICE_BT_CAPABILITIES: &'static [u8; 16usize] = b"bt-capabilities\0";
pub const NM_DEVICE_DUMMY_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_ETHERNET_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_ETHERNET_PERMANENT_HW_ADDRESS: &'static [u8; 16usize] = b"perm-hw-address\0";
pub const NM_DEVICE_ETHERNET_SPEED: &'static [u8; 6usize] = b"speed\0";
pub const NM_DEVICE_ETHERNET_CARRIER: &'static [u8; 8usize] = b"carrier\0";
pub const NM_DEVICE_ETHERNET_S390_SUBCHANNELS: &'static [u8; 17usize] = b"s390-subchannels\0";
pub const NM_DEVICE_GENERIC_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_GENERIC_TYPE_DESCRIPTION: &'static [u8; 17usize] = b"type-description\0";
pub const NM_DEVICE_INFINIBAND_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_INFINIBAND_CARRIER: &'static [u8; 8usize] = b"carrier\0";
pub const NM_SETTING_IP_TUNNEL_SETTING_NAME: &'static [u8; 10usize] = b"ip-tunnel\0";
pub const NM_SETTING_IP_TUNNEL_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_SETTING_IP_TUNNEL_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_SETTING_IP_TUNNEL_LOCAL: &'static [u8; 6usize] = b"local\0";
pub const NM_SETTING_IP_TUNNEL_REMOTE: &'static [u8; 7usize] = b"remote\0";
pub const NM_SETTING_IP_TUNNEL_TTL: &'static [u8; 4usize] = b"ttl\0";
pub const NM_SETTING_IP_TUNNEL_TOS: &'static [u8; 4usize] = b"tos\0";
pub const NM_SETTING_IP_TUNNEL_PATH_MTU_DISCOVERY: &'static [u8; 19usize] = b"path-mtu-discovery\0";
pub const NM_SETTING_IP_TUNNEL_INPUT_KEY: &'static [u8; 10usize] = b"input-key\0";
pub const NM_SETTING_IP_TUNNEL_OUTPUT_KEY: &'static [u8; 11usize] = b"output-key\0";
pub const NM_SETTING_IP_TUNNEL_ENCAPSULATION_LIMIT: &'static [u8; 20usize] =
    b"encapsulation-limit\0";
pub const NM_SETTING_IP_TUNNEL_FLOW_LABEL: &'static [u8; 11usize] = b"flow-label\0";
pub const NM_SETTING_IP_TUNNEL_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_SETTING_IP_TUNNEL_FLAGS: &'static [u8; 6usize] = b"flags\0";
pub const NM_DEVICE_IP_TUNNEL_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_DEVICE_IP_TUNNEL_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_DEVICE_IP_TUNNEL_LOCAL: &'static [u8; 6usize] = b"local\0";
pub const NM_DEVICE_IP_TUNNEL_REMOTE: &'static [u8; 7usize] = b"remote\0";
pub const NM_DEVICE_IP_TUNNEL_TTL: &'static [u8; 4usize] = b"ttl\0";
pub const NM_DEVICE_IP_TUNNEL_TOS: &'static [u8; 4usize] = b"tos\0";
pub const NM_DEVICE_IP_TUNNEL_PATH_MTU_DISCOVERY: &'static [u8; 19usize] = b"path-mtu-discovery\0";
pub const NM_DEVICE_IP_TUNNEL_INPUT_KEY: &'static [u8; 10usize] = b"input-key\0";
pub const NM_DEVICE_IP_TUNNEL_OUTPUT_KEY: &'static [u8; 11usize] = b"output-key\0";
pub const NM_DEVICE_IP_TUNNEL_ENCAPSULATION_LIMIT: &'static [u8; 20usize] =
    b"encapsulation-limit\0";
pub const NM_DEVICE_IP_TUNNEL_FLOW_LABEL: &'static [u8; 11usize] = b"flow-label\0";
pub const NM_DEVICE_IP_TUNNEL_FLAGS: &'static [u8; 6usize] = b"flags\0";
pub const NM_DEVICE_MACSEC_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_DEVICE_MACSEC_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_MACSEC_SCI: &'static [u8; 4usize] = b"sci\0";
pub const NM_DEVICE_MACSEC_ICV_LENGTH: &'static [u8; 11usize] = b"icv-length\0";
pub const NM_DEVICE_MACSEC_CIPHER_SUITE: &'static [u8; 13usize] = b"cipher-suite\0";
pub const NM_DEVICE_MACSEC_WINDOW: &'static [u8; 7usize] = b"window\0";
pub const NM_DEVICE_MACSEC_ENCODING_SA: &'static [u8; 12usize] = b"encoding-sa\0";
pub const NM_DEVICE_MACSEC_VALIDATION: &'static [u8; 11usize] = b"validation\0";
pub const NM_DEVICE_MACSEC_ENCRYPT: &'static [u8; 8usize] = b"encrypt\0";
pub const NM_DEVICE_MACSEC_PROTECT: &'static [u8; 8usize] = b"protect\0";
pub const NM_DEVICE_MACSEC_INCLUDE_SCI: &'static [u8; 12usize] = b"include-sci\0";
pub const NM_DEVICE_MACSEC_ES: &'static [u8; 3usize] = b"es\0";
pub const NM_DEVICE_MACSEC_SCB: &'static [u8; 4usize] = b"scb\0";
pub const NM_DEVICE_MACSEC_REPLAY_PROTECT: &'static [u8; 15usize] = b"replay-protect\0";
pub const NM_DEVICE_MACVLAN_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_DEVICE_MACVLAN_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_DEVICE_MACVLAN_NO_PROMISC: &'static [u8; 11usize] = b"no-promisc\0";
pub const NM_DEVICE_MACVLAN_TAP: &'static [u8; 4usize] = b"tap\0";
pub const NM_DEVICE_MACVLAN_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_MODEM_MODEM_CAPABILITIES: &'static [u8; 19usize] = b"modem-capabilities\0";
pub const NM_DEVICE_MODEM_CURRENT_CAPABILITIES: &'static [u8; 21usize] = b"current-capabilities\0";
pub const NM_DEVICE_MODEM_DEVICE_ID: &'static [u8; 10usize] = b"device-id\0";
pub const NM_DEVICE_MODEM_OPERATOR_CODE: &'static [u8; 14usize] = b"operator-code\0";
pub const NM_DEVICE_MODEM_APN: &'static [u8; 4usize] = b"apn\0";
pub const NM_DEVICE_OLPC_MESH_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_OLPC_MESH_COMPANION: &'static [u8; 10usize] = b"companion\0";
pub const NM_DEVICE_OLPC_MESH_ACTIVE_CHANNEL: &'static [u8; 15usize] = b"active-channel\0";
pub const NM_DEVICE_OVS_BRIDGE_SLAVES: &'static [u8; 7usize] = b"slaves\0";
pub const NM_DEVICE_OVS_PORT_SLAVES: &'static [u8; 7usize] = b"slaves\0";
pub const NM_DEVICE_TEAM_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_TEAM_CARRIER: &'static [u8; 8usize] = b"carrier\0";
pub const NM_DEVICE_TEAM_SLAVES: &'static [u8; 7usize] = b"slaves\0";
pub const NM_DEVICE_TEAM_CONFIG: &'static [u8; 7usize] = b"config\0";
pub const NM_DEVICE_TUN_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_TUN_OWNER: &'static [u8; 6usize] = b"owner\0";
pub const NM_DEVICE_TUN_GROUP: &'static [u8; 6usize] = b"group\0";
pub const NM_DEVICE_TUN_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_DEVICE_TUN_NO_PI: &'static [u8; 6usize] = b"no-pi\0";
pub const NM_DEVICE_TUN_VNET_HDR: &'static [u8; 9usize] = b"vnet-hdr\0";
pub const NM_DEVICE_TUN_MULTI_QUEUE: &'static [u8; 12usize] = b"multi-queue\0";
pub const NM_DEVICE_VLAN_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_VLAN_CARRIER: &'static [u8; 8usize] = b"carrier\0";
pub const NM_DEVICE_VLAN_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_DEVICE_VLAN_VLAN_ID: &'static [u8; 8usize] = b"vlan-id\0";
pub const NM_DEVICE_VXLAN_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_VXLAN_CARRIER: &'static [u8; 8usize] = b"carrier\0";
pub const NM_DEVICE_VXLAN_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_DEVICE_VXLAN_ID: &'static [u8; 3usize] = b"id\0";
pub const NM_DEVICE_VXLAN_GROUP: &'static [u8; 6usize] = b"group\0";
pub const NM_DEVICE_VXLAN_LOCAL: &'static [u8; 6usize] = b"local\0";
pub const NM_DEVICE_VXLAN_SRC_PORT_MIN: &'static [u8; 13usize] = b"src-port-min\0";
pub const NM_DEVICE_VXLAN_SRC_PORT_MAX: &'static [u8; 13usize] = b"src-port-max\0";
pub const NM_DEVICE_VXLAN_LEARNING: &'static [u8; 9usize] = b"learning\0";
pub const NM_DEVICE_VXLAN_AGEING: &'static [u8; 7usize] = b"ageing\0";
pub const NM_DEVICE_VXLAN_TOS: &'static [u8; 4usize] = b"tos\0";
pub const NM_DEVICE_VXLAN_TTL: &'static [u8; 4usize] = b"ttl\0";
pub const NM_DEVICE_VXLAN_LIMIT: &'static [u8; 6usize] = b"limit\0";
pub const NM_DEVICE_VXLAN_PROXY: &'static [u8; 6usize] = b"proxy\0";
pub const NM_DEVICE_VXLAN_RSC: &'static [u8; 4usize] = b"rsc\0";
pub const NM_DEVICE_VXLAN_L2MISS: &'static [u8; 7usize] = b"l2miss\0";
pub const NM_DEVICE_VXLAN_L3MISS: &'static [u8; 7usize] = b"l3miss\0";
pub const NM_DEVICE_VXLAN_DST_PORT: &'static [u8; 9usize] = b"dst-port\0";
pub const NM_DEVICE_WIFI_P2P_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_WIFI_P2P_PEERS: &'static [u8; 6usize] = b"peers\0";
pub const NM_DEVICE_WIFI_P2P_WFDIES: &'static [u8; 7usize] = b"wfdies\0";
pub const NM_DEVICE_WIFI_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_WIFI_PERMANENT_HW_ADDRESS: &'static [u8; 16usize] = b"perm-hw-address\0";
pub const NM_DEVICE_WIFI_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_DEVICE_WIFI_BITRATE: &'static [u8; 8usize] = b"bitrate\0";
pub const NM_DEVICE_WIFI_ACTIVE_ACCESS_POINT: &'static [u8; 20usize] = b"active-access-point\0";
pub const NM_DEVICE_WIFI_CAPABILITIES: &'static [u8; 22usize] = b"wireless-capabilities\0";
pub const NM_DEVICE_WIFI_ACCESS_POINTS: &'static [u8; 14usize] = b"access-points\0";
pub const NM_DEVICE_WIFI_LAST_SCAN: &'static [u8; 10usize] = b"last-scan\0";
pub const NM_DEVICE_WIMAX_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DEVICE_WIMAX_ACTIVE_NSP: &'static [u8; 11usize] = b"active-nsp\0";
pub const NM_DEVICE_WIMAX_CENTER_FREQUENCY: &'static [u8; 17usize] = b"center-frequency\0";
pub const NM_DEVICE_WIMAX_RSSI: &'static [u8; 5usize] = b"rssi\0";
pub const NM_DEVICE_WIMAX_CINR: &'static [u8; 5usize] = b"cinr\0";
pub const NM_DEVICE_WIMAX_TX_POWER: &'static [u8; 9usize] = b"tx-power\0";
pub const NM_DEVICE_WIMAX_BSID: &'static [u8; 5usize] = b"bsid\0";
pub const NM_DEVICE_WIMAX_NSPS: &'static [u8; 5usize] = b"nsps\0";
pub const NM_DEVICE_WIREGUARD_PUBLIC_KEY: &'static [u8; 11usize] = b"public-key\0";
pub const NM_DEVICE_WIREGUARD_LISTEN_PORT: &'static [u8; 12usize] = b"listen-port\0";
pub const NM_DEVICE_WIREGUARD_FWMARK: &'static [u8; 7usize] = b"fwmark\0";
pub const NM_DEVICE_WPAN_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_DHCP_CONFIG_FAMILY: &'static [u8; 7usize] = b"family\0";
pub const NM_DHCP_CONFIG_OPTIONS: &'static [u8; 8usize] = b"options\0";
pub const NM_IP_CONFIG_FAMILY: &'static [u8; 7usize] = b"family\0";
pub const NM_IP_CONFIG_GATEWAY: &'static [u8; 8usize] = b"gateway\0";
pub const NM_IP_CONFIG_ADDRESSES: &'static [u8; 10usize] = b"addresses\0";
pub const NM_IP_CONFIG_ROUTES: &'static [u8; 7usize] = b"routes\0";
pub const NM_IP_CONFIG_NAMESERVERS: &'static [u8; 12usize] = b"nameservers\0";
pub const NM_IP_CONFIG_DOMAINS: &'static [u8; 8usize] = b"domains\0";
pub const NM_IP_CONFIG_SEARCHES: &'static [u8; 9usize] = b"searches\0";
pub const NM_IP_CONFIG_WINS_SERVERS: &'static [u8; 13usize] = b"wins-servers\0";
pub const NM_REMOTE_CONNECTION_DBUS_CONNECTION: &'static [u8; 16usize] = b"dbus-connection\0";
pub const NM_REMOTE_CONNECTION_PATH: &'static [u8; 5usize] = b"path\0";
pub const NM_REMOTE_CONNECTION_UNSAVED: &'static [u8; 8usize] = b"unsaved\0";
pub const NM_REMOTE_CONNECTION_FLAGS: &'static [u8; 6usize] = b"flags\0";
pub const NM_REMOTE_CONNECTION_FILENAME: &'static [u8; 9usize] = b"filename\0";
pub const NM_REMOTE_CONNECTION_VISIBLE: &'static [u8; 8usize] = b"visible\0";
pub const NM_SETTING_6LOWPAN_SETTING_NAME: &'static [u8; 8usize] = b"6lowpan\0";
pub const NM_SETTING_6LOWPAN_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PATH: &'static [u8; 8usize] = b"file://\0";
pub const NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PKCS11: &'static [u8; 8usize] = b"pkcs11:\0";
pub const NM_SETTING_802_1X_SETTING_NAME: &'static [u8; 7usize] = b"802-1x\0";
pub const NM_SETTING_802_1X_EAP: &'static [u8; 4usize] = b"eap\0";
pub const NM_SETTING_802_1X_IDENTITY: &'static [u8; 9usize] = b"identity\0";
pub const NM_SETTING_802_1X_ANONYMOUS_IDENTITY: &'static [u8; 19usize] = b"anonymous-identity\0";
pub const NM_SETTING_802_1X_PAC_FILE: &'static [u8; 9usize] = b"pac-file\0";
pub const NM_SETTING_802_1X_CA_CERT: &'static [u8; 8usize] = b"ca-cert\0";
pub const NM_SETTING_802_1X_CA_CERT_PASSWORD: &'static [u8; 17usize] = b"ca-cert-password\0";
pub const NM_SETTING_802_1X_CA_CERT_PASSWORD_FLAGS: &'static [u8; 23usize] =
    b"ca-cert-password-flags\0";
pub const NM_SETTING_802_1X_CA_PATH: &'static [u8; 8usize] = b"ca-path\0";
pub const NM_SETTING_802_1X_SUBJECT_MATCH: &'static [u8; 14usize] = b"subject-match\0";
pub const NM_SETTING_802_1X_ALTSUBJECT_MATCHES: &'static [u8; 19usize] = b"altsubject-matches\0";
pub const NM_SETTING_802_1X_DOMAIN_SUFFIX_MATCH: &'static [u8; 20usize] = b"domain-suffix-match\0";
pub const NM_SETTING_802_1X_DOMAIN_MATCH: &'static [u8; 13usize] = b"domain-match\0";
pub const NM_SETTING_802_1X_CLIENT_CERT: &'static [u8; 12usize] = b"client-cert\0";
pub const NM_SETTING_802_1X_CLIENT_CERT_PASSWORD: &'static [u8; 21usize] =
    b"client-cert-password\0";
pub const NM_SETTING_802_1X_CLIENT_CERT_PASSWORD_FLAGS: &'static [u8; 27usize] =
    b"client-cert-password-flags\0";
pub const NM_SETTING_802_1X_PHASE1_PEAPVER: &'static [u8; 15usize] = b"phase1-peapver\0";
pub const NM_SETTING_802_1X_PHASE1_PEAPLABEL: &'static [u8; 17usize] = b"phase1-peaplabel\0";
pub const NM_SETTING_802_1X_PHASE1_FAST_PROVISIONING: &'static [u8; 25usize] =
    b"phase1-fast-provisioning\0";
pub const NM_SETTING_802_1X_PHASE1_AUTH_FLAGS: &'static [u8; 18usize] = b"phase1-auth-flags\0";
pub const NM_SETTING_802_1X_PHASE2_AUTH: &'static [u8; 12usize] = b"phase2-auth\0";
pub const NM_SETTING_802_1X_PHASE2_AUTHEAP: &'static [u8; 15usize] = b"phase2-autheap\0";
pub const NM_SETTING_802_1X_PHASE2_CA_CERT: &'static [u8; 15usize] = b"phase2-ca-cert\0";
pub const NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD: &'static [u8; 24usize] =
    b"phase2-ca-cert-password\0";
pub const NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD_FLAGS: &'static [u8; 30usize] =
    b"phase2-ca-cert-password-flags\0";
pub const NM_SETTING_802_1X_PHASE2_CA_PATH: &'static [u8; 15usize] = b"phase2-ca-path\0";
pub const NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH: &'static [u8; 21usize] =
    b"phase2-subject-match\0";
pub const NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES: &'static [u8; 26usize] =
    b"phase2-altsubject-matches\0";
pub const NM_SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH: &'static [u8; 27usize] =
    b"phase2-domain-suffix-match\0";
pub const NM_SETTING_802_1X_PHASE2_DOMAIN_MATCH: &'static [u8; 20usize] = b"phase2-domain-match\0";
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT: &'static [u8; 19usize] = b"phase2-client-cert\0";
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD: &'static [u8; 28usize] =
    b"phase2-client-cert-password\0";
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD_FLAGS: &'static [u8; 34usize] =
    b"phase2-client-cert-password-flags\0";
pub const NM_SETTING_802_1X_PASSWORD: &'static [u8; 9usize] = b"password\0";
pub const NM_SETTING_802_1X_PASSWORD_FLAGS: &'static [u8; 15usize] = b"password-flags\0";
pub const NM_SETTING_802_1X_PASSWORD_RAW: &'static [u8; 13usize] = b"password-raw\0";
pub const NM_SETTING_802_1X_PASSWORD_RAW_FLAGS: &'static [u8; 19usize] = b"password-raw-flags\0";
pub const NM_SETTING_802_1X_PRIVATE_KEY: &'static [u8; 12usize] = b"private-key\0";
pub const NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD: &'static [u8; 21usize] =
    b"private-key-password\0";
pub const NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS: &'static [u8; 27usize] =
    b"private-key-password-flags\0";
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY: &'static [u8; 19usize] = b"phase2-private-key\0";
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD: &'static [u8; 28usize] =
    b"phase2-private-key-password\0";
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS: &'static [u8; 34usize] =
    b"phase2-private-key-password-flags\0";
pub const NM_SETTING_802_1X_PIN: &'static [u8; 4usize] = b"pin\0";
pub const NM_SETTING_802_1X_PIN_FLAGS: &'static [u8; 10usize] = b"pin-flags\0";
pub const NM_SETTING_802_1X_SYSTEM_CA_CERTS: &'static [u8; 16usize] = b"system-ca-certs\0";
pub const NM_SETTING_802_1X_AUTH_TIMEOUT: &'static [u8; 13usize] = b"auth-timeout\0";
pub const NM_SETTING_802_1X_OPTIONAL: &'static [u8; 9usize] = b"optional\0";
pub const NM_SETTING_ADSL_SETTING_NAME: &'static [u8; 5usize] = b"adsl\0";
pub const NM_SETTING_ADSL_USERNAME: &'static [u8; 9usize] = b"username\0";
pub const NM_SETTING_ADSL_PASSWORD: &'static [u8; 9usize] = b"password\0";
pub const NM_SETTING_ADSL_PASSWORD_FLAGS: &'static [u8; 15usize] = b"password-flags\0";
pub const NM_SETTING_ADSL_PROTOCOL: &'static [u8; 9usize] = b"protocol\0";
pub const NM_SETTING_ADSL_ENCAPSULATION: &'static [u8; 14usize] = b"encapsulation\0";
pub const NM_SETTING_ADSL_VPI: &'static [u8; 4usize] = b"vpi\0";
pub const NM_SETTING_ADSL_VCI: &'static [u8; 4usize] = b"vci\0";
pub const NM_SETTING_ADSL_PROTOCOL_PPPOA: &'static [u8; 6usize] = b"pppoa\0";
pub const NM_SETTING_ADSL_PROTOCOL_PPPOE: &'static [u8; 6usize] = b"pppoe\0";
pub const NM_SETTING_ADSL_PROTOCOL_IPOATM: &'static [u8; 7usize] = b"ipoatm\0";
pub const NM_SETTING_ADSL_ENCAPSULATION_VCMUX: &'static [u8; 6usize] = b"vcmux\0";
pub const NM_SETTING_ADSL_ENCAPSULATION_LLC: &'static [u8; 4usize] = b"llc\0";
pub const NM_SETTING_BLUETOOTH_SETTING_NAME: &'static [u8; 10usize] = b"bluetooth\0";
pub const NM_SETTING_BLUETOOTH_BDADDR: &'static [u8; 7usize] = b"bdaddr\0";
pub const NM_SETTING_BLUETOOTH_TYPE: &'static [u8; 5usize] = b"type\0";
pub const NM_SETTING_BLUETOOTH_TYPE_DUN: &'static [u8; 4usize] = b"dun\0";
pub const NM_SETTING_BLUETOOTH_TYPE_PANU: &'static [u8; 5usize] = b"panu\0";
pub const NM_SETTING_BLUETOOTH_TYPE_NAP: &'static [u8; 4usize] = b"nap\0";
pub const NM_SETTING_BOND_SETTING_NAME: &'static [u8; 5usize] = b"bond\0";
pub const NM_SETTING_BOND_OPTIONS: &'static [u8; 8usize] = b"options\0";
pub const NM_SETTING_BOND_OPTION_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_SETTING_BOND_OPTION_MIIMON: &'static [u8; 7usize] = b"miimon\0";
pub const NM_SETTING_BOND_OPTION_DOWNDELAY: &'static [u8; 10usize] = b"downdelay\0";
pub const NM_SETTING_BOND_OPTION_UPDELAY: &'static [u8; 8usize] = b"updelay\0";
pub const NM_SETTING_BOND_OPTION_ARP_INTERVAL: &'static [u8; 13usize] = b"arp_interval\0";
pub const NM_SETTING_BOND_OPTION_ARP_IP_TARGET: &'static [u8; 14usize] = b"arp_ip_target\0";
pub const NM_SETTING_BOND_OPTION_ARP_VALIDATE: &'static [u8; 13usize] = b"arp_validate\0";
pub const NM_SETTING_BOND_OPTION_PRIMARY: &'static [u8; 8usize] = b"primary\0";
pub const NM_SETTING_BOND_OPTION_PRIMARY_RESELECT: &'static [u8; 17usize] = b"primary_reselect\0";
pub const NM_SETTING_BOND_OPTION_FAIL_OVER_MAC: &'static [u8; 14usize] = b"fail_over_mac\0";
pub const NM_SETTING_BOND_OPTION_USE_CARRIER: &'static [u8; 12usize] = b"use_carrier\0";
pub const NM_SETTING_BOND_OPTION_AD_SELECT: &'static [u8; 10usize] = b"ad_select\0";
pub const NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY: &'static [u8; 17usize] = b"xmit_hash_policy\0";
pub const NM_SETTING_BOND_OPTION_RESEND_IGMP: &'static [u8; 12usize] = b"resend_igmp\0";
pub const NM_SETTING_BOND_OPTION_LACP_RATE: &'static [u8; 10usize] = b"lacp_rate\0";
pub const NM_SETTING_BOND_OPTION_ACTIVE_SLAVE: &'static [u8; 13usize] = b"active_slave\0";
pub const NM_SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO: &'static [u8; 18usize] = b"ad_actor_sys_prio\0";
pub const NM_SETTING_BOND_OPTION_AD_ACTOR_SYSTEM: &'static [u8; 16usize] = b"ad_actor_system\0";
pub const NM_SETTING_BOND_OPTION_AD_USER_PORT_KEY: &'static [u8; 17usize] = b"ad_user_port_key\0";
pub const NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE: &'static [u8; 18usize] = b"all_slaves_active\0";
pub const NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS: &'static [u8; 16usize] = b"arp_all_targets\0";
pub const NM_SETTING_BOND_OPTION_MIN_LINKS: &'static [u8; 10usize] = b"min_links\0";
pub const NM_SETTING_BOND_OPTION_NUM_GRAT_ARP: &'static [u8; 13usize] = b"num_grat_arp\0";
pub const NM_SETTING_BOND_OPTION_NUM_UNSOL_NA: &'static [u8; 13usize] = b"num_unsol_na\0";
pub const NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE: &'static [u8; 18usize] = b"packets_per_slave\0";
pub const NM_SETTING_BOND_OPTION_TLB_DYNAMIC_LB: &'static [u8; 15usize] = b"tlb_dynamic_lb\0";
pub const NM_SETTING_BOND_OPTION_LP_INTERVAL: &'static [u8; 12usize] = b"lp_interval\0";
pub const NM_SETTING_BRIDGE_SETTING_NAME: &'static [u8; 7usize] = b"bridge\0";
pub const NM_SETTING_BRIDGE_MAC_ADDRESS: &'static [u8; 12usize] = b"mac-address\0";
pub const NM_SETTING_BRIDGE_STP: &'static [u8; 4usize] = b"stp\0";
pub const NM_SETTING_BRIDGE_PRIORITY: &'static [u8; 9usize] = b"priority\0";
pub const NM_SETTING_BRIDGE_FORWARD_DELAY: &'static [u8; 14usize] = b"forward-delay\0";
pub const NM_SETTING_BRIDGE_HELLO_TIME: &'static [u8; 11usize] = b"hello-time\0";
pub const NM_SETTING_BRIDGE_MAX_AGE: &'static [u8; 8usize] = b"max-age\0";
pub const NM_SETTING_BRIDGE_AGEING_TIME: &'static [u8; 12usize] = b"ageing-time\0";
pub const NM_SETTING_BRIDGE_GROUP_FORWARD_MASK: &'static [u8; 19usize] = b"group-forward-mask\0";
pub const NM_SETTING_BRIDGE_MULTICAST_HASH_MAX: &'static [u8; 19usize] = b"multicast-hash-max\0";
pub const NM_SETTING_BRIDGE_MULTICAST_LAST_MEMBER_COUNT: &'static [u8; 28usize] =
    b"multicast-last-member-count\0";
pub const NM_SETTING_BRIDGE_MULTICAST_LAST_MEMBER_INTERVAL: &'static [u8; 31usize] =
    b"multicast-last-member-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_MEMBERSHIP_INTERVAL: &'static [u8; 30usize] =
    b"multicast-membership-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_SNOOPING: &'static [u8; 19usize] = b"multicast-snooping\0";
pub const NM_SETTING_BRIDGE_MULTICAST_ROUTER: &'static [u8; 17usize] = b"multicast-router\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERIER: &'static [u8; 18usize] = b"multicast-querier\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERIER_INTERVAL: &'static [u8; 27usize] =
    b"multicast-querier-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERY_INTERVAL: &'static [u8; 25usize] =
    b"multicast-query-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERY_RESPONSE_INTERVAL: &'static [u8; 34usize] =
    b"multicast-query-response-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERY_USE_IFADDR: &'static [u8; 27usize] =
    b"multicast-query-use-ifaddr\0";
pub const NM_SETTING_BRIDGE_MULTICAST_STARTUP_QUERY_COUNT: &'static [u8; 30usize] =
    b"multicast-startup-query-count\0";
pub const NM_SETTING_BRIDGE_MULTICAST_STARTUP_QUERY_INTERVAL: &'static [u8; 33usize] =
    b"multicast-startup-query-interval\0";
pub const NM_SETTING_BRIDGE_VLAN_FILTERING: &'static [u8; 15usize] = b"vlan-filtering\0";
pub const NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID: &'static [u8; 18usize] = b"vlan-default-pvid\0";
pub const NM_SETTING_BRIDGE_VLANS: &'static [u8; 6usize] = b"vlans\0";
pub const NM_SETTING_BRIDGE_GROUP_ADDRESS: &'static [u8; 14usize] = b"group-address\0";
pub const NM_SETTING_BRIDGE_VLAN_PROTOCOL: &'static [u8; 14usize] = b"vlan-protocol\0";
pub const NM_SETTING_BRIDGE_VLAN_STATS_ENABLED: &'static [u8; 19usize] = b"vlan-stats-enabled\0";
pub const NM_BRIDGE_VLAN_VID_MIN: u32 = 1;
pub const NM_BRIDGE_VLAN_VID_MAX: u32 = 4094;
pub const NM_SETTING_BRIDGE_PORT_SETTING_NAME: &'static [u8; 12usize] = b"bridge-port\0";
pub const NM_SETTING_BRIDGE_PORT_PRIORITY: &'static [u8; 9usize] = b"priority\0";
pub const NM_SETTING_BRIDGE_PORT_PATH_COST: &'static [u8; 10usize] = b"path-cost\0";
pub const NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE: &'static [u8; 13usize] = b"hairpin-mode\0";
pub const NM_SETTING_BRIDGE_PORT_VLANS: &'static [u8; 6usize] = b"vlans\0";
pub const NM_SETTING_CDMA_SETTING_NAME: &'static [u8; 5usize] = b"cdma\0";
pub const NM_SETTING_CDMA_NUMBER: &'static [u8; 7usize] = b"number\0";
pub const NM_SETTING_CDMA_USERNAME: &'static [u8; 9usize] = b"username\0";
pub const NM_SETTING_CDMA_PASSWORD: &'static [u8; 9usize] = b"password\0";
pub const NM_SETTING_CDMA_PASSWORD_FLAGS: &'static [u8; 15usize] = b"password-flags\0";
pub const NM_SETTING_CDMA_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_SETTING_CONNECTION_SETTING_NAME: &'static [u8; 11usize] = b"connection\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN: i32 = -999;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX: u32 = 999;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT: u32 = 0;
pub const NM_SETTING_CONNECTION_ID: &'static [u8; 3usize] = b"id\0";
pub const NM_SETTING_CONNECTION_UUID: &'static [u8; 5usize] = b"uuid\0";
pub const NM_SETTING_CONNECTION_STABLE_ID: &'static [u8; 10usize] = b"stable-id\0";
pub const NM_SETTING_CONNECTION_INTERFACE_NAME: &'static [u8; 15usize] = b"interface-name\0";
pub const NM_SETTING_CONNECTION_TYPE: &'static [u8; 5usize] = b"type\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT: &'static [u8; 12usize] = b"autoconnect\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY: &'static [u8; 21usize] =
    b"autoconnect-priority\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES: &'static [u8; 20usize] =
    b"autoconnect-retries\0";
pub const NM_SETTING_CONNECTION_MULTI_CONNECT: &'static [u8; 14usize] = b"multi-connect\0";
pub const NM_SETTING_CONNECTION_TIMESTAMP: &'static [u8; 10usize] = b"timestamp\0";
pub const NM_SETTING_CONNECTION_READ_ONLY: &'static [u8; 10usize] = b"read-only\0";
pub const NM_SETTING_CONNECTION_PERMISSIONS: &'static [u8; 12usize] = b"permissions\0";
pub const NM_SETTING_CONNECTION_ZONE: &'static [u8; 5usize] = b"zone\0";
pub const NM_SETTING_CONNECTION_MASTER: &'static [u8; 7usize] = b"master\0";
pub const NM_SETTING_CONNECTION_SLAVE_TYPE: &'static [u8; 11usize] = b"slave-type\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES: &'static [u8; 19usize] =
    b"autoconnect-slaves\0";
pub const NM_SETTING_CONNECTION_SECONDARIES: &'static [u8; 12usize] = b"secondaries\0";
pub const NM_SETTING_CONNECTION_GATEWAY_PING_TIMEOUT: &'static [u8; 21usize] =
    b"gateway-ping-timeout\0";
pub const NM_SETTING_CONNECTION_METERED: &'static [u8; 8usize] = b"metered\0";
pub const NM_SETTING_CONNECTION_LLDP: &'static [u8; 5usize] = b"lldp\0";
pub const NM_SETTING_CONNECTION_AUTH_RETRIES: &'static [u8; 13usize] = b"auth-retries\0";
pub const NM_SETTING_CONNECTION_MDNS: &'static [u8; 5usize] = b"mdns\0";
pub const NM_SETTING_CONNECTION_LLMNR: &'static [u8; 6usize] = b"llmnr\0";
pub const NM_SETTING_CONNECTION_WAIT_DEVICE_TIMEOUT: &'static [u8; 20usize] =
    b"wait-device-timeout\0";
pub const NM_SETTING_CONNECTION_MUD_URL: &'static [u8; 8usize] = b"mud-url\0";
pub const NM_SETTING_DCB_SETTING_NAME: &'static [u8; 4usize] = b"dcb\0";
pub const NM_SETTING_DCB_FCOE_MODE_FABRIC: &'static [u8; 7usize] = b"fabric\0";
pub const NM_SETTING_DCB_FCOE_MODE_VN2VN: &'static [u8; 6usize] = b"vn2vn\0";
pub const NM_SETTING_DCB_APP_FCOE_FLAGS: &'static [u8; 15usize] = b"app-fcoe-flags\0";
pub const NM_SETTING_DCB_APP_FCOE_PRIORITY: &'static [u8; 18usize] = b"app-fcoe-priority\0";
pub const NM_SETTING_DCB_APP_FCOE_MODE: &'static [u8; 14usize] = b"app-fcoe-mode\0";
pub const NM_SETTING_DCB_APP_ISCSI_FLAGS: &'static [u8; 16usize] = b"app-iscsi-flags\0";
pub const NM_SETTING_DCB_APP_ISCSI_PRIORITY: &'static [u8; 19usize] = b"app-iscsi-priority\0";
pub const NM_SETTING_DCB_APP_FIP_FLAGS: &'static [u8; 14usize] = b"app-fip-flags\0";
pub const NM_SETTING_DCB_APP_FIP_PRIORITY: &'static [u8; 17usize] = b"app-fip-priority\0";
pub const NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS: &'static [u8; 28usize] =
    b"priority-flow-control-flags\0";
pub const NM_SETTING_DCB_PRIORITY_FLOW_CONTROL: &'static [u8; 22usize] = b"priority-flow-control\0";
pub const NM_SETTING_DCB_PRIORITY_GROUP_FLAGS: &'static [u8; 21usize] = b"priority-group-flags\0";
pub const NM_SETTING_DCB_PRIORITY_GROUP_ID: &'static [u8; 18usize] = b"priority-group-id\0";
pub const NM_SETTING_DCB_PRIORITY_GROUP_BANDWIDTH: &'static [u8; 25usize] =
    b"priority-group-bandwidth\0";
pub const NM_SETTING_DCB_PRIORITY_BANDWIDTH: &'static [u8; 19usize] = b"priority-bandwidth\0";
pub const NM_SETTING_DCB_PRIORITY_STRICT_BANDWIDTH: &'static [u8; 26usize] =
    b"priority-strict-bandwidth\0";
pub const NM_SETTING_DCB_PRIORITY_TRAFFIC_CLASS: &'static [u8; 23usize] =
    b"priority-traffic-class\0";
pub const NM_SETTING_DUMMY_SETTING_NAME: &'static [u8; 6usize] = b"dummy\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_ESP_HW_OFFLOAD: &'static [u8; 23usize] =
    b"feature-esp-hw-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_ESP_TX_CSUM_HW_OFFLOAD: &'static [u8; 31usize] =
    b"feature-esp-tx-csum-hw-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_FCOE_MTU: &'static [u8; 17usize] = b"feature-fcoe-mtu\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_GRO: &'static [u8; 12usize] = b"feature-gro\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_GSO: &'static [u8; 12usize] = b"feature-gso\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_HIGHDMA: &'static [u8; 16usize] = b"feature-highdma\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_HW_TC_OFFLOAD: &'static [u8; 22usize] =
    b"feature-hw-tc-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_L2_FWD_OFFLOAD: &'static [u8; 23usize] =
    b"feature-l2-fwd-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_LOOPBACK: &'static [u8; 17usize] = b"feature-loopback\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_LRO: &'static [u8; 12usize] = b"feature-lro\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_NTUPLE: &'static [u8; 15usize] = b"feature-ntuple\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX: &'static [u8; 11usize] = b"feature-rx\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RXHASH: &'static [u8; 15usize] = b"feature-rxhash\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RXVLAN: &'static [u8; 15usize] = b"feature-rxvlan\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_ALL: &'static [u8; 15usize] = b"feature-rx-all\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_FCS: &'static [u8; 15usize] = b"feature-rx-fcs\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_GRO_HW: &'static [u8; 18usize] = b"feature-rx-gro-hw\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_UDP_TUNNEL_PORT_OFFLOAD: &'static [u8; 35usize] =
    b"feature-rx-udp_tunnel-port-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_VLAN_FILTER: &'static [u8; 23usize] =
    b"feature-rx-vlan-filter\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_VLAN_STAG_FILTER: &'static [u8; 28usize] =
    b"feature-rx-vlan-stag-filter\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_VLAN_STAG_HW_PARSE: &'static [u8; 30usize] =
    b"feature-rx-vlan-stag-hw-parse\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_SG: &'static [u8; 11usize] = b"feature-sg\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TLS_HW_RECORD: &'static [u8; 22usize] =
    b"feature-tls-hw-record\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TLS_HW_TX_OFFLOAD: &'static [u8; 26usize] =
    b"feature-tls-hw-tx-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TSO: &'static [u8; 12usize] = b"feature-tso\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX: &'static [u8; 11usize] = b"feature-tx\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TXVLAN: &'static [u8; 15usize] = b"feature-txvlan\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_FCOE_CRC: &'static [u8; 29usize] =
    b"feature-tx-checksum-fcoe-crc\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IPV4: &'static [u8; 25usize] =
    b"feature-tx-checksum-ipv4\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IPV6: &'static [u8; 25usize] =
    b"feature-tx-checksum-ipv6\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IP_GENERIC: &'static [u8; 31usize] =
    b"feature-tx-checksum-ip-generic\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_SCTP: &'static [u8; 25usize] =
    b"feature-tx-checksum-sctp\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_ESP_SEGMENTATION: &'static [u8; 28usize] =
    b"feature-tx-esp-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_FCOE_SEGMENTATION: &'static [u8; 29usize] =
    b"feature-tx-fcoe-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GRE_CSUM_SEGMENTATION: &'static [u8; 33usize] =
    b"feature-tx-gre-csum-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GRE_SEGMENTATION: &'static [u8; 28usize] =
    b"feature-tx-gre-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GSO_PARTIAL: &'static [u8; 23usize] =
    b"feature-tx-gso-partial\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GSO_ROBUST: &'static [u8; 22usize] =
    b"feature-tx-gso-robust\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_IPXIP4_SEGMENTATION: &'static [u8; 31usize] =
    b"feature-tx-ipxip4-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_IPXIP6_SEGMENTATION: &'static [u8; 31usize] =
    b"feature-tx-ipxip6-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_NOCACHE_COPY: &'static [u8; 24usize] =
    b"feature-tx-nocache-copy\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_SCATTER_GATHER: &'static [u8; 26usize] =
    b"feature-tx-scatter-gather\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_SCATTER_GATHER_FRAGLIST: &'static [u8; 35usize] =
    b"feature-tx-scatter-gather-fraglist\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_SCTP_SEGMENTATION: &'static [u8; 29usize] =
    b"feature-tx-sctp-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP6_SEGMENTATION: &'static [u8; 29usize] =
    b"feature-tx-tcp6-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP_ECN_SEGMENTATION: &'static [u8; 32usize] =
    b"feature-tx-tcp-ecn-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP_MANGLEID_SEGMENTATION: &'static [u8; 37usize] =
    b"feature-tx-tcp-mangleid-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP_SEGMENTATION: &'static [u8; 28usize] =
    b"feature-tx-tcp-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_UDP_SEGMENTATION: &'static [u8; 28usize] =
    b"feature-tx-udp-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_UDP_TNL_CSUM_SEGMENTATION: &'static [u8; 37usize] =
    b"feature-tx-udp_tnl-csum-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_UDP_TNL_SEGMENTATION: &'static [u8; 32usize] =
    b"feature-tx-udp_tnl-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_VLAN_STAG_HW_INSERT: &'static [u8; 31usize] =
    b"feature-tx-vlan-stag-hw-insert\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_ADAPTIVE_RX: &'static [u8; 21usize] =
    b"coalesce-adaptive-rx\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_ADAPTIVE_TX: &'static [u8; 21usize] =
    b"coalesce-adaptive-tx\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_PKT_RATE_HIGH: &'static [u8; 23usize] =
    b"coalesce-pkt-rate-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_PKT_RATE_LOW: &'static [u8; 22usize] =
    b"coalesce-pkt-rate-low\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_FRAMES: &'static [u8; 19usize] = b"coalesce-rx-frames\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_FRAMES_HIGH: &'static [u8; 24usize] =
    b"coalesce-rx-frames-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_FRAMES_IRQ: &'static [u8; 23usize] =
    b"coalesce-rx-frames-irq\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_FRAMES_LOW: &'static [u8; 23usize] =
    b"coalesce-rx-frames-low\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_USECS: &'static [u8; 18usize] = b"coalesce-rx-usecs\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_USECS_HIGH: &'static [u8; 23usize] =
    b"coalesce-rx-usecs-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_USECS_IRQ: &'static [u8; 22usize] =
    b"coalesce-rx-usecs-irq\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_USECS_LOW: &'static [u8; 22usize] =
    b"coalesce-rx-usecs-low\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_SAMPLE_INTERVAL: &'static [u8; 25usize] =
    b"coalesce-sample-interval\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_STATS_BLOCK_USECS: &'static [u8; 27usize] =
    b"coalesce-stats-block-usecs\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_FRAMES: &'static [u8; 19usize] = b"coalesce-tx-frames\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_FRAMES_HIGH: &'static [u8; 24usize] =
    b"coalesce-tx-frames-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_FRAMES_IRQ: &'static [u8; 23usize] =
    b"coalesce-tx-frames-irq\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_FRAMES_LOW: &'static [u8; 23usize] =
    b"coalesce-tx-frames-low\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_USECS: &'static [u8; 18usize] = b"coalesce-tx-usecs\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_USECS_HIGH: &'static [u8; 23usize] =
    b"coalesce-tx-usecs-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_USECS_IRQ: &'static [u8; 22usize] =
    b"coalesce-tx-usecs-irq\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_USECS_LOW: &'static [u8; 22usize] =
    b"coalesce-tx-usecs-low\0";
pub const NM_ETHTOOL_OPTNAME_RING_RX: &'static [u8; 8usize] = b"ring-rx\0";
pub const NM_ETHTOOL_OPTNAME_RING_RX_JUMBO: &'static [u8; 14usize] = b"ring-rx-jumbo\0";
pub const NM_ETHTOOL_OPTNAME_RING_RX_MINI: &'static [u8; 13usize] = b"ring-rx-mini\0";
pub const NM_ETHTOOL_OPTNAME_RING_TX: &'static [u8; 8usize] = b"ring-tx\0";
pub const NM_SETTING_ETHTOOL_SETTING_NAME: &'static [u8; 8usize] = b"ethtool\0";
pub const NM_SETTING_GENERIC_SETTING_NAME: &'static [u8; 8usize] = b"generic\0";
pub const NM_SETTING_GSM_SETTING_NAME: &'static [u8; 4usize] = b"gsm\0";
pub const NM_SETTING_GSM_AUTO_CONFIG: &'static [u8; 12usize] = b"auto-config\0";
pub const NM_SETTING_GSM_USERNAME: &'static [u8; 9usize] = b"username\0";
pub const NM_SETTING_GSM_PASSWORD: &'static [u8; 9usize] = b"password\0";
pub const NM_SETTING_GSM_PASSWORD_FLAGS: &'static [u8; 15usize] = b"password-flags\0";
pub const NM_SETTING_GSM_APN: &'static [u8; 4usize] = b"apn\0";
pub const NM_SETTING_GSM_NETWORK_ID: &'static [u8; 11usize] = b"network-id\0";
pub const NM_SETTING_GSM_PIN: &'static [u8; 4usize] = b"pin\0";
pub const NM_SETTING_GSM_PIN_FLAGS: &'static [u8; 10usize] = b"pin-flags\0";
pub const NM_SETTING_GSM_HOME_ONLY: &'static [u8; 10usize] = b"home-only\0";
pub const NM_SETTING_GSM_DEVICE_ID: &'static [u8; 10usize] = b"device-id\0";
pub const NM_SETTING_GSM_SIM_ID: &'static [u8; 7usize] = b"sim-id\0";
pub const NM_SETTING_GSM_SIM_OPERATOR_ID: &'static [u8; 16usize] = b"sim-operator-id\0";
pub const NM_SETTING_GSM_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_SETTING_GSM_NUMBER: &'static [u8; 7usize] = b"number\0";
pub const NM_SETTING_INFINIBAND_SETTING_NAME: &'static [u8; 11usize] = b"infiniband\0";
pub const NM_SETTING_INFINIBAND_MAC_ADDRESS: &'static [u8; 12usize] = b"mac-address\0";
pub const NM_SETTING_INFINIBAND_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_SETTING_INFINIBAND_TRANSPORT_MODE: &'static [u8; 15usize] = b"transport-mode\0";
pub const NM_SETTING_INFINIBAND_P_KEY: &'static [u8; 6usize] = b"p-key\0";
pub const NM_SETTING_INFINIBAND_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_SETTING_SRIOV_SETTING_NAME: &'static [u8; 6usize] = b"sriov\0";
pub const NM_SETTING_SRIOV_TOTAL_VFS: &'static [u8; 10usize] = b"total-vfs\0";
pub const NM_SETTING_SRIOV_VFS: &'static [u8; 4usize] = b"vfs\0";
pub const NM_SETTING_SRIOV_AUTOPROBE_DRIVERS: &'static [u8; 18usize] = b"autoprobe-drivers\0";
pub const NM_SRIOV_VF_ATTRIBUTE_MAC: &'static [u8; 4usize] = b"mac\0";
pub const NM_SRIOV_VF_ATTRIBUTE_SPOOF_CHECK: &'static [u8; 12usize] = b"spoof-check\0";
pub const NM_SRIOV_VF_ATTRIBUTE_TRUST: &'static [u8; 6usize] = b"trust\0";
pub const NM_SRIOV_VF_ATTRIBUTE_MIN_TX_RATE: &'static [u8; 12usize] = b"min-tx-rate\0";
pub const NM_SRIOV_VF_ATTRIBUTE_MAX_TX_RATE: &'static [u8; 12usize] = b"max-tx-rate\0";
pub const NM_SETTING_TC_CONFIG_SETTING_NAME: &'static [u8; 3usize] = b"tc\0";
pub const NM_SETTING_TC_CONFIG_QDISCS: &'static [u8; 7usize] = b"qdiscs\0";
pub const NM_SETTING_TC_CONFIG_TFILTERS: &'static [u8; 9usize] = b"tfilters\0";
pub const NM_SETTING_WIRELESS_SECURITY_SETTING_NAME: &'static [u8; 25usize] =
    b"802-11-wireless-security\0";
pub const NM_SETTING_WIRELESS_SECURITY_KEY_MGMT: &'static [u8; 9usize] = b"key-mgmt\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX: &'static [u8; 14usize] = b"wep-tx-keyidx\0";
pub const NM_SETTING_WIRELESS_SECURITY_AUTH_ALG: &'static [u8; 9usize] = b"auth-alg\0";
pub const NM_SETTING_WIRELESS_SECURITY_PROTO: &'static [u8; 6usize] = b"proto\0";
pub const NM_SETTING_WIRELESS_SECURITY_PAIRWISE: &'static [u8; 9usize] = b"pairwise\0";
pub const NM_SETTING_WIRELESS_SECURITY_GROUP: &'static [u8; 6usize] = b"group\0";
pub const NM_SETTING_WIRELESS_SECURITY_PMF: &'static [u8; 4usize] = b"pmf\0";
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME: &'static [u8; 14usize] = b"leap-username\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY0: &'static [u8; 9usize] = b"wep-key0\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY1: &'static [u8; 9usize] = b"wep-key1\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY2: &'static [u8; 9usize] = b"wep-key2\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY3: &'static [u8; 9usize] = b"wep-key3\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS: &'static [u8; 14usize] = b"wep-key-flags\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE: &'static [u8; 13usize] = b"wep-key-type\0";
pub const NM_SETTING_WIRELESS_SECURITY_PSK: &'static [u8; 4usize] = b"psk\0";
pub const NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS: &'static [u8; 10usize] = b"psk-flags\0";
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD: &'static [u8; 14usize] = b"leap-password\0";
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS: &'static [u8; 20usize] =
    b"leap-password-flags\0";
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD: &'static [u8; 11usize] = b"wps-method\0";
pub const NM_SETTING_WIRELESS_SECURITY_FILS: &'static [u8; 5usize] = b"fils\0";
pub const NM_UTILS_HWADDR_LEN_MAX: u32 = 20;
pub const NM_UTILS_INET_ADDRSTRLEN: u32 = 46;
pub const NM_IP_ADDRESS_ATTRIBUTE_LABEL: &'static [u8; 6usize] = b"label\0";
pub const NM_IP_ROUTE_ATTRIBUTE_CWND: &'static [u8; 5usize] = b"cwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_FROM: &'static [u8; 5usize] = b"from\0";
pub const NM_IP_ROUTE_ATTRIBUTE_INITCWND: &'static [u8; 9usize] = b"initcwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_INITRWND: &'static [u8; 9usize] = b"initrwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND: &'static [u8; 10usize] = b"lock-cwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_INITCWND: &'static [u8; 14usize] = b"lock-initcwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_INITRWND: &'static [u8; 14usize] = b"lock-initrwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU: &'static [u8; 9usize] = b"lock-mtu\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_WINDOW: &'static [u8; 12usize] = b"lock-window\0";
pub const NM_IP_ROUTE_ATTRIBUTE_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_IP_ROUTE_ATTRIBUTE_ONLINK: &'static [u8; 7usize] = b"onlink\0";
pub const NM_IP_ROUTE_ATTRIBUTE_SCOPE: &'static [u8; 6usize] = b"scope\0";
pub const NM_IP_ROUTE_ATTRIBUTE_SRC: &'static [u8; 4usize] = b"src\0";
pub const NM_IP_ROUTE_ATTRIBUTE_TABLE: &'static [u8; 6usize] = b"table\0";
pub const NM_IP_ROUTE_ATTRIBUTE_TOS: &'static [u8; 4usize] = b"tos\0";
pub const NM_IP_ROUTE_ATTRIBUTE_TYPE: &'static [u8; 5usize] = b"type\0";
pub const NM_IP_ROUTE_ATTRIBUTE_WINDOW: &'static [u8; 7usize] = b"window\0";
pub const NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX: u32 = 30000;
pub const NM_SETTING_IP_CONFIG_METHOD: &'static [u8; 7usize] = b"method\0";
pub const NM_SETTING_IP_CONFIG_DNS: &'static [u8; 4usize] = b"dns\0";
pub const NM_SETTING_IP_CONFIG_DNS_SEARCH: &'static [u8; 11usize] = b"dns-search\0";
pub const NM_SETTING_IP_CONFIG_DNS_OPTIONS: &'static [u8; 12usize] = b"dns-options\0";
pub const NM_SETTING_IP_CONFIG_DNS_PRIORITY: &'static [u8; 13usize] = b"dns-priority\0";
pub const NM_SETTING_IP_CONFIG_ADDRESSES: &'static [u8; 10usize] = b"addresses\0";
pub const NM_SETTING_IP_CONFIG_GATEWAY: &'static [u8; 8usize] = b"gateway\0";
pub const NM_SETTING_IP_CONFIG_ROUTES: &'static [u8; 7usize] = b"routes\0";
pub const NM_SETTING_IP_CONFIG_ROUTE_METRIC: &'static [u8; 13usize] = b"route-metric\0";
pub const NM_SETTING_IP_CONFIG_ROUTE_TABLE: &'static [u8; 12usize] = b"route-table\0";
pub const NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES: &'static [u8; 19usize] = b"ignore-auto-routes\0";
pub const NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS: &'static [u8; 16usize] = b"ignore-auto-dns\0";
pub const NM_SETTING_IP_CONFIG_DHCP_HOSTNAME: &'static [u8; 14usize] = b"dhcp-hostname\0";
pub const NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME: &'static [u8; 19usize] = b"dhcp-send-hostname\0";
pub const NM_SETTING_IP_CONFIG_DHCP_HOSTNAME_FLAGS: &'static [u8; 20usize] =
    b"dhcp-hostname-flags\0";
pub const NM_SETTING_IP_CONFIG_NEVER_DEFAULT: &'static [u8; 14usize] = b"never-default\0";
pub const NM_SETTING_IP_CONFIG_MAY_FAIL: &'static [u8; 9usize] = b"may-fail\0";
pub const NM_SETTING_IP_CONFIG_DAD_TIMEOUT: &'static [u8; 12usize] = b"dad-timeout\0";
pub const NM_SETTING_IP_CONFIG_DHCP_TIMEOUT: &'static [u8; 13usize] = b"dhcp-timeout\0";
pub const NM_SETTING_IP_CONFIG_DHCP_IAID: &'static [u8; 10usize] = b"dhcp-iaid\0";
pub const NM_SETTING_IP_CONFIG_ROUTING_RULES: &'static [u8; 14usize] = b"routing-rules\0";
pub const NM_SETTING_DNS_OPTION_DEBUG: &'static [u8; 6usize] = b"debug\0";
pub const NM_SETTING_DNS_OPTION_NDOTS: &'static [u8; 6usize] = b"ndots\0";
pub const NM_SETTING_DNS_OPTION_TIMEOUT: &'static [u8; 8usize] = b"timeout\0";
pub const NM_SETTING_DNS_OPTION_ATTEMPTS: &'static [u8; 9usize] = b"attempts\0";
pub const NM_SETTING_DNS_OPTION_ROTATE: &'static [u8; 7usize] = b"rotate\0";
pub const NM_SETTING_DNS_OPTION_NO_CHECK_NAMES: &'static [u8; 15usize] = b"no-check-names\0";
pub const NM_SETTING_DNS_OPTION_INET6: &'static [u8; 6usize] = b"inet6\0";
pub const NM_SETTING_DNS_OPTION_IP6_BYTESTRING: &'static [u8; 15usize] = b"ip6-bytestring\0";
pub const NM_SETTING_DNS_OPTION_IP6_DOTINT: &'static [u8; 11usize] = b"ip6-dotint\0";
pub const NM_SETTING_DNS_OPTION_NO_IP6_DOTINT: &'static [u8; 14usize] = b"no-ip6-dotint\0";
pub const NM_SETTING_DNS_OPTION_EDNS0: &'static [u8; 6usize] = b"edns0\0";
pub const NM_SETTING_DNS_OPTION_SINGLE_REQUEST: &'static [u8; 15usize] = b"single-request\0";
pub const NM_SETTING_DNS_OPTION_SINGLE_REQUEST_REOPEN: &'static [u8; 22usize] =
    b"single-request-reopen\0";
pub const NM_SETTING_DNS_OPTION_NO_TLD_QUERY: &'static [u8; 13usize] = b"no-tld-query\0";
pub const NM_SETTING_DNS_OPTION_USE_VC: &'static [u8; 7usize] = b"use-vc\0";
pub const NM_SETTING_DNS_OPTION_NO_RELOAD: &'static [u8; 10usize] = b"no-reload\0";
pub const NM_SETTING_DNS_OPTION_TRUST_AD: &'static [u8; 9usize] = b"trust-ad\0";
pub const NM_SETTING_IP4_CONFIG_SETTING_NAME: &'static [u8; 5usize] = b"ipv4\0";
pub const NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID: &'static [u8; 15usize] = b"dhcp-client-id\0";
pub const NM_SETTING_IP4_CONFIG_DHCP_FQDN: &'static [u8; 10usize] = b"dhcp-fqdn\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_AUTO: &'static [u8; 5usize] = b"auto\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL: &'static [u8; 11usize] = b"link-local\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_MANUAL: &'static [u8; 7usize] = b"manual\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_SHARED: &'static [u8; 7usize] = b"shared\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_DISABLED: &'static [u8; 9usize] = b"disabled\0";
pub const NM_SETTING_IP6_CONFIG_SETTING_NAME: &'static [u8; 5usize] = b"ipv6\0";
pub const NM_SETTING_IP6_CONFIG_IP6_PRIVACY: &'static [u8; 12usize] = b"ip6-privacy\0";
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE: &'static [u8; 14usize] = b"addr-gen-mode\0";
pub const NM_SETTING_IP6_CONFIG_TOKEN: &'static [u8; 6usize] = b"token\0";
pub const NM_SETTING_IP6_CONFIG_DHCP_DUID: &'static [u8; 10usize] = b"dhcp-duid\0";
pub const NM_SETTING_IP6_CONFIG_RA_TIMEOUT: &'static [u8; 11usize] = b"ra-timeout\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_IGNORE: &'static [u8; 7usize] = b"ignore\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_AUTO: &'static [u8; 5usize] = b"auto\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_DHCP: &'static [u8; 5usize] = b"dhcp\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL: &'static [u8; 11usize] = b"link-local\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_MANUAL: &'static [u8; 7usize] = b"manual\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_SHARED: &'static [u8; 7usize] = b"shared\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_DISABLED: &'static [u8; 9usize] = b"disabled\0";
pub const NM_SETTING_MACSEC_SETTING_NAME: &'static [u8; 7usize] = b"macsec\0";
pub const NM_SETTING_MACSEC_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_SETTING_MACSEC_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_SETTING_MACSEC_ENCRYPT: &'static [u8; 8usize] = b"encrypt\0";
pub const NM_SETTING_MACSEC_MKA_CAK: &'static [u8; 8usize] = b"mka-cak\0";
pub const NM_SETTING_MACSEC_MKA_CAK_FLAGS: &'static [u8; 14usize] = b"mka-cak-flags\0";
pub const NM_SETTING_MACSEC_MKA_CKN: &'static [u8; 8usize] = b"mka-ckn\0";
pub const NM_SETTING_MACSEC_PORT: &'static [u8; 5usize] = b"port\0";
pub const NM_SETTING_MACSEC_VALIDATION: &'static [u8; 11usize] = b"validation\0";
pub const NM_SETTING_MACSEC_SEND_SCI: &'static [u8; 9usize] = b"send-sci\0";
pub const NM_SETTING_MACSEC_MKA_CAK_LENGTH: u32 = 32;
pub const NM_SETTING_MACSEC_MKA_CKN_LENGTH: u32 = 64;
pub const NM_SETTING_MACVLAN_SETTING_NAME: &'static [u8; 8usize] = b"macvlan\0";
pub const NM_SETTING_MACVLAN_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_SETTING_MACVLAN_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_SETTING_MACVLAN_PROMISCUOUS: &'static [u8; 12usize] = b"promiscuous\0";
pub const NM_SETTING_MACVLAN_TAP: &'static [u8; 4usize] = b"tap\0";
pub const NM_SETTING_MATCH_SETTING_NAME: &'static [u8; 6usize] = b"match\0";
pub const NM_SETTING_MATCH_INTERFACE_NAME: &'static [u8; 15usize] = b"interface-name\0";
pub const NM_SETTING_MATCH_KERNEL_COMMAND_LINE: &'static [u8; 20usize] = b"kernel-command-line\0";
pub const NM_SETTING_MATCH_DRIVER: &'static [u8; 7usize] = b"driver\0";
pub const NM_SETTING_MATCH_PATH: &'static [u8; 5usize] = b"path\0";
pub const NM_SETTING_OLPC_MESH_SETTING_NAME: &'static [u8; 17usize] = b"802-11-olpc-mesh\0";
pub const NM_SETTING_OLPC_MESH_SSID: &'static [u8; 5usize] = b"ssid\0";
pub const NM_SETTING_OLPC_MESH_CHANNEL: &'static [u8; 8usize] = b"channel\0";
pub const NM_SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS: &'static [u8; 21usize] =
    b"dhcp-anycast-address\0";
pub const NM_SETTING_OVS_BRIDGE_SETTING_NAME: &'static [u8; 11usize] = b"ovs-bridge\0";
pub const NM_SETTING_OVS_BRIDGE_FAIL_MODE: &'static [u8; 10usize] = b"fail-mode\0";
pub const NM_SETTING_OVS_BRIDGE_MCAST_SNOOPING_ENABLE: &'static [u8; 22usize] =
    b"mcast-snooping-enable\0";
pub const NM_SETTING_OVS_BRIDGE_RSTP_ENABLE: &'static [u8; 12usize] = b"rstp-enable\0";
pub const NM_SETTING_OVS_BRIDGE_STP_ENABLE: &'static [u8; 11usize] = b"stp-enable\0";
pub const NM_SETTING_OVS_BRIDGE_DATAPATH_TYPE: &'static [u8; 14usize] = b"datapath-type\0";
pub const NM_SETTING_OVS_INTERFACE_SETTING_NAME: &'static [u8; 14usize] = b"ovs-interface\0";
pub const NM_SETTING_OVS_INTERFACE_TYPE: &'static [u8; 5usize] = b"type\0";
pub const NM_SETTING_OVS_DPDK_SETTING_NAME: &'static [u8; 9usize] = b"ovs-dpdk\0";
pub const NM_SETTING_OVS_DPDK_DEVARGS: &'static [u8; 8usize] = b"devargs\0";
pub const NM_SETTING_OVS_PATCH_SETTING_NAME: &'static [u8; 10usize] = b"ovs-patch\0";
pub const NM_SETTING_OVS_PATCH_PEER: &'static [u8; 5usize] = b"peer\0";
pub const NM_SETTING_OVS_PORT_SETTING_NAME: &'static [u8; 9usize] = b"ovs-port\0";
pub const NM_SETTING_OVS_PORT_VLAN_MODE: &'static [u8; 10usize] = b"vlan-mode\0";
pub const NM_SETTING_OVS_PORT_TAG: &'static [u8; 4usize] = b"tag\0";
pub const NM_SETTING_OVS_PORT_LACP: &'static [u8; 5usize] = b"lacp\0";
pub const NM_SETTING_OVS_PORT_BOND_MODE: &'static [u8; 10usize] = b"bond-mode\0";
pub const NM_SETTING_OVS_PORT_BOND_UPDELAY: &'static [u8; 13usize] = b"bond-updelay\0";
pub const NM_SETTING_OVS_PORT_BOND_DOWNDELAY: &'static [u8; 15usize] = b"bond-downdelay\0";
pub const NM_SETTING_WIFI_P2P_SETTING_NAME: &'static [u8; 9usize] = b"wifi-p2p\0";
pub const NM_SETTING_WIFI_P2P_PEER: &'static [u8; 5usize] = b"peer\0";
pub const NM_SETTING_WIFI_P2P_WPS_METHOD: &'static [u8; 11usize] = b"wps-method\0";
pub const NM_SETTING_WIFI_P2P_WFD_IES: &'static [u8; 8usize] = b"wfd-ies\0";
pub const NM_SETTING_PPP_SETTING_NAME: &'static [u8; 4usize] = b"ppp\0";
pub const NM_SETTING_PPP_NOAUTH: &'static [u8; 7usize] = b"noauth\0";
pub const NM_SETTING_PPP_REFUSE_EAP: &'static [u8; 11usize] = b"refuse-eap\0";
pub const NM_SETTING_PPP_REFUSE_PAP: &'static [u8; 11usize] = b"refuse-pap\0";
pub const NM_SETTING_PPP_REFUSE_CHAP: &'static [u8; 12usize] = b"refuse-chap\0";
pub const NM_SETTING_PPP_REFUSE_MSCHAP: &'static [u8; 14usize] = b"refuse-mschap\0";
pub const NM_SETTING_PPP_REFUSE_MSCHAPV2: &'static [u8; 16usize] = b"refuse-mschapv2\0";
pub const NM_SETTING_PPP_NOBSDCOMP: &'static [u8; 10usize] = b"nobsdcomp\0";
pub const NM_SETTING_PPP_NODEFLATE: &'static [u8; 10usize] = b"nodeflate\0";
pub const NM_SETTING_PPP_NO_VJ_COMP: &'static [u8; 11usize] = b"no-vj-comp\0";
pub const NM_SETTING_PPP_REQUIRE_MPPE: &'static [u8; 13usize] = b"require-mppe\0";
pub const NM_SETTING_PPP_REQUIRE_MPPE_128: &'static [u8; 17usize] = b"require-mppe-128\0";
pub const NM_SETTING_PPP_MPPE_STATEFUL: &'static [u8; 14usize] = b"mppe-stateful\0";
pub const NM_SETTING_PPP_CRTSCTS: &'static [u8; 8usize] = b"crtscts\0";
pub const NM_SETTING_PPP_BAUD: &'static [u8; 5usize] = b"baud\0";
pub const NM_SETTING_PPP_MRU: &'static [u8; 4usize] = b"mru\0";
pub const NM_SETTING_PPP_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_SETTING_PPP_LCP_ECHO_FAILURE: &'static [u8; 17usize] = b"lcp-echo-failure\0";
pub const NM_SETTING_PPP_LCP_ECHO_INTERVAL: &'static [u8; 18usize] = b"lcp-echo-interval\0";
pub const NM_SETTING_PPPOE_SETTING_NAME: &'static [u8; 6usize] = b"pppoe\0";
pub const NM_SETTING_PPPOE_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_SETTING_PPPOE_SERVICE: &'static [u8; 8usize] = b"service\0";
pub const NM_SETTING_PPPOE_USERNAME: &'static [u8; 9usize] = b"username\0";
pub const NM_SETTING_PPPOE_PASSWORD: &'static [u8; 9usize] = b"password\0";
pub const NM_SETTING_PPPOE_PASSWORD_FLAGS: &'static [u8; 15usize] = b"password-flags\0";
pub const NM_SETTING_PROXY_SETTING_NAME: &'static [u8; 6usize] = b"proxy\0";
pub const NM_SETTING_PROXY_METHOD: &'static [u8; 7usize] = b"method\0";
pub const NM_SETTING_PROXY_BROWSER_ONLY: &'static [u8; 13usize] = b"browser-only\0";
pub const NM_SETTING_PROXY_PAC_URL: &'static [u8; 8usize] = b"pac-url\0";
pub const NM_SETTING_PROXY_PAC_SCRIPT: &'static [u8; 11usize] = b"pac-script\0";
pub const NM_SETTING_SERIAL_SETTING_NAME: &'static [u8; 7usize] = b"serial\0";
pub const NM_SETTING_SERIAL_BAUD: &'static [u8; 5usize] = b"baud\0";
pub const NM_SETTING_SERIAL_BITS: &'static [u8; 5usize] = b"bits\0";
pub const NM_SETTING_SERIAL_PARITY: &'static [u8; 7usize] = b"parity\0";
pub const NM_SETTING_SERIAL_STOPBITS: &'static [u8; 9usize] = b"stopbits\0";
pub const NM_SETTING_SERIAL_SEND_DELAY: &'static [u8; 11usize] = b"send-delay\0";
pub const NM_TEAM_LINK_WATCHER_ETHTOOL: &'static [u8; 8usize] = b"ethtool\0";
pub const NM_TEAM_LINK_WATCHER_ARP_PING: &'static [u8; 9usize] = b"arp_ping\0";
pub const NM_TEAM_LINK_WATCHER_NSNA_PING: &'static [u8; 10usize] = b"nsna_ping\0";
pub const NM_SETTING_TEAM_SETTING_NAME: &'static [u8; 5usize] = b"team\0";
pub const NM_SETTING_TEAM_CONFIG: &'static [u8; 7usize] = b"config\0";
pub const NM_SETTING_TEAM_NOTIFY_PEERS_COUNT: &'static [u8; 19usize] = b"notify-peers-count\0";
pub const NM_SETTING_TEAM_NOTIFY_PEERS_INTERVAL: &'static [u8; 22usize] =
    b"notify-peers-interval\0";
pub const NM_SETTING_TEAM_MCAST_REJOIN_COUNT: &'static [u8; 19usize] = b"mcast-rejoin-count\0";
pub const NM_SETTING_TEAM_MCAST_REJOIN_INTERVAL: &'static [u8; 22usize] =
    b"mcast-rejoin-interval\0";
pub const NM_SETTING_TEAM_RUNNER: &'static [u8; 7usize] = b"runner\0";
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY: &'static [u8; 21usize] = b"runner-hwaddr-policy\0";
pub const NM_SETTING_TEAM_RUNNER_TX_HASH: &'static [u8; 15usize] = b"runner-tx-hash\0";
pub const NM_SETTING_TEAM_RUNNER_TX_BALANCER: &'static [u8; 19usize] = b"runner-tx-balancer\0";
pub const NM_SETTING_TEAM_RUNNER_TX_BALANCER_INTERVAL: &'static [u8; 28usize] =
    b"runner-tx-balancer-interval\0";
pub const NM_SETTING_TEAM_RUNNER_ACTIVE: &'static [u8; 14usize] = b"runner-active\0";
pub const NM_SETTING_TEAM_RUNNER_FAST_RATE: &'static [u8; 17usize] = b"runner-fast-rate\0";
pub const NM_SETTING_TEAM_RUNNER_SYS_PRIO: &'static [u8; 16usize] = b"runner-sys-prio\0";
pub const NM_SETTING_TEAM_RUNNER_MIN_PORTS: &'static [u8; 17usize] = b"runner-min-ports\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY: &'static [u8; 25usize] =
    b"runner-agg-select-policy\0";
pub const NM_SETTING_TEAM_LINK_WATCHERS: &'static [u8; 14usize] = b"link-watchers\0";
pub const NM_SETTING_TEAM_RUNNER_BROADCAST: &'static [u8; 10usize] = b"broadcast\0";
pub const NM_SETTING_TEAM_RUNNER_ROUNDROBIN: &'static [u8; 11usize] = b"roundrobin\0";
pub const NM_SETTING_TEAM_RUNNER_RANDOM: &'static [u8; 7usize] = b"random\0";
pub const NM_SETTING_TEAM_RUNNER_ACTIVEBACKUP: &'static [u8; 13usize] = b"activebackup\0";
pub const NM_SETTING_TEAM_RUNNER_LOADBALANCE: &'static [u8; 12usize] = b"loadbalance\0";
pub const NM_SETTING_TEAM_RUNNER_LACP: &'static [u8; 5usize] = b"lacp\0";
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_SAME_ALL: &'static [u8; 9usize] = b"same_all\0";
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_BY_ACTIVE: &'static [u8; 10usize] = b"by_active\0";
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_ONLY_ACTIVE: &'static [u8; 12usize] =
    b"only_active\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_LACP_PRIO: &'static [u8; 10usize] =
    b"lacp_prio\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_LACP_PRIO_STABLE: &'static [u8; 17usize] =
    b"lacp_prio_stable\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_BANDWIDTH: &'static [u8; 10usize] =
    b"bandwidth\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_COUNT: &'static [u8; 6usize] = b"count\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_PORT_CONFIG: &'static [u8; 12usize] =
    b"port_config\0";
pub const NM_SETTING_TEAM_NOTIFY_PEERS_COUNT_ACTIVEBACKUP_DEFAULT: u32 = 1;
pub const NM_SETTING_TEAM_NOTIFY_MCAST_COUNT_ACTIVEBACKUP_DEFAULT: u32 = 1;
pub const NM_SETTING_TEAM_RUNNER_DEFAULT: &'static [u8; 11usize] = b"roundrobin\0";
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_DEFAULT: &'static [u8; 9usize] = b"same_all\0";
pub const NM_SETTING_TEAM_RUNNER_TX_BALANCER_INTERVAL_DEFAULT: u32 = 50;
pub const NM_SETTING_TEAM_RUNNER_SYS_PRIO_DEFAULT: u32 = 65535;
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_DEFAULT: &'static [u8; 10usize] = b"lacp_prio\0";
pub const NM_SETTING_TEAM_PORT_SETTING_NAME: &'static [u8; 10usize] = b"team-port\0";
pub const NM_SETTING_TEAM_PORT_CONFIG: &'static [u8; 7usize] = b"config\0";
pub const NM_SETTING_TEAM_PORT_QUEUE_ID: &'static [u8; 9usize] = b"queue-id\0";
pub const NM_SETTING_TEAM_PORT_PRIO: &'static [u8; 5usize] = b"prio\0";
pub const NM_SETTING_TEAM_PORT_STICKY: &'static [u8; 7usize] = b"sticky\0";
pub const NM_SETTING_TEAM_PORT_LACP_PRIO: &'static [u8; 10usize] = b"lacp-prio\0";
pub const NM_SETTING_TEAM_PORT_LACP_KEY: &'static [u8; 9usize] = b"lacp-key\0";
pub const NM_SETTING_TEAM_PORT_LINK_WATCHERS: &'static [u8; 14usize] = b"link-watchers\0";
pub const NM_SETTING_TEAM_PORT_QUEUE_ID_DEFAULT: i32 = -1;
pub const NM_SETTING_TEAM_PORT_LACP_PRIO_DEFAULT: u32 = 255;
pub const NM_SETTING_TUN_SETTING_NAME: &'static [u8; 4usize] = b"tun\0";
pub const NM_SETTING_TUN_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_SETTING_TUN_OWNER: &'static [u8; 6usize] = b"owner\0";
pub const NM_SETTING_TUN_GROUP: &'static [u8; 6usize] = b"group\0";
pub const NM_SETTING_TUN_PI: &'static [u8; 3usize] = b"pi\0";
pub const NM_SETTING_TUN_VNET_HDR: &'static [u8; 9usize] = b"vnet-hdr\0";
pub const NM_SETTING_TUN_MULTI_QUEUE: &'static [u8; 12usize] = b"multi-queue\0";
pub const NM_SETTING_USER_SETTING_NAME: &'static [u8; 5usize] = b"user\0";
pub const NM_SETTING_USER_DATA: &'static [u8; 5usize] = b"data\0";
pub const NM_SETTING_VLAN_SETTING_NAME: &'static [u8; 5usize] = b"vlan\0";
pub const NM_SETTING_VLAN_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_SETTING_VLAN_ID: &'static [u8; 3usize] = b"id\0";
pub const NM_SETTING_VLAN_FLAGS: &'static [u8; 6usize] = b"flags\0";
pub const NM_SETTING_VLAN_INGRESS_PRIORITY_MAP: &'static [u8; 21usize] = b"ingress-priority-map\0";
pub const NM_SETTING_VLAN_EGRESS_PRIORITY_MAP: &'static [u8; 20usize] = b"egress-priority-map\0";
pub const NM_SETTING_VPN_SETTING_NAME: &'static [u8; 4usize] = b"vpn\0";
pub const NM_SETTING_VPN_SERVICE_TYPE: &'static [u8; 13usize] = b"service-type\0";
pub const NM_SETTING_VPN_USER_NAME: &'static [u8; 10usize] = b"user-name\0";
pub const NM_SETTING_VPN_PERSISTENT: &'static [u8; 11usize] = b"persistent\0";
pub const NM_SETTING_VPN_DATA: &'static [u8; 5usize] = b"data\0";
pub const NM_SETTING_VPN_SECRETS: &'static [u8; 8usize] = b"secrets\0";
pub const NM_SETTING_VPN_TIMEOUT: &'static [u8; 8usize] = b"timeout\0";
pub const NM_SETTING_VRF_SETTING_NAME: &'static [u8; 4usize] = b"vrf\0";
pub const NM_SETTING_VRF_TABLE: &'static [u8; 6usize] = b"table\0";
pub const NM_SETTING_VXLAN_SETTING_NAME: &'static [u8; 6usize] = b"vxlan\0";
pub const NM_SETTING_VXLAN_PARENT: &'static [u8; 7usize] = b"parent\0";
pub const NM_SETTING_VXLAN_ID: &'static [u8; 3usize] = b"id\0";
pub const NM_SETTING_VXLAN_LOCAL: &'static [u8; 6usize] = b"local\0";
pub const NM_SETTING_VXLAN_REMOTE: &'static [u8; 7usize] = b"remote\0";
pub const NM_SETTING_VXLAN_SOURCE_PORT_MIN: &'static [u8; 16usize] = b"source-port-min\0";
pub const NM_SETTING_VXLAN_SOURCE_PORT_MAX: &'static [u8; 16usize] = b"source-port-max\0";
pub const NM_SETTING_VXLAN_DESTINATION_PORT: &'static [u8; 17usize] = b"destination-port\0";
pub const NM_SETTING_VXLAN_TOS: &'static [u8; 4usize] = b"tos\0";
pub const NM_SETTING_VXLAN_TTL: &'static [u8; 4usize] = b"ttl\0";
pub const NM_SETTING_VXLAN_AGEING: &'static [u8; 7usize] = b"ageing\0";
pub const NM_SETTING_VXLAN_LIMIT: &'static [u8; 6usize] = b"limit\0";
pub const NM_SETTING_VXLAN_PROXY: &'static [u8; 6usize] = b"proxy\0";
pub const NM_SETTING_VXLAN_LEARNING: &'static [u8; 9usize] = b"learning\0";
pub const NM_SETTING_VXLAN_RSC: &'static [u8; 4usize] = b"rsc\0";
pub const NM_SETTING_VXLAN_L2_MISS: &'static [u8; 8usize] = b"l2-miss\0";
pub const NM_SETTING_VXLAN_L3_MISS: &'static [u8; 8usize] = b"l3-miss\0";
pub const NM_SETTING_WIMAX_SETTING_NAME: &'static [u8; 6usize] = b"wimax\0";
pub const NM_SETTING_WIMAX_NETWORK_NAME: &'static [u8; 13usize] = b"network-name\0";
pub const NM_SETTING_WIMAX_MAC_ADDRESS: &'static [u8; 12usize] = b"mac-address\0";
pub const NM_SETTING_WIRED_SETTING_NAME: &'static [u8; 15usize] = b"802-3-ethernet\0";
pub const NM_SETTING_WIRED_PORT: &'static [u8; 5usize] = b"port\0";
pub const NM_SETTING_WIRED_SPEED: &'static [u8; 6usize] = b"speed\0";
pub const NM_SETTING_WIRED_DUPLEX: &'static [u8; 7usize] = b"duplex\0";
pub const NM_SETTING_WIRED_AUTO_NEGOTIATE: &'static [u8; 15usize] = b"auto-negotiate\0";
pub const NM_SETTING_WIRED_MAC_ADDRESS: &'static [u8; 12usize] = b"mac-address\0";
pub const NM_SETTING_WIRED_CLONED_MAC_ADDRESS: &'static [u8; 19usize] = b"cloned-mac-address\0";
pub const NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK: &'static [u8; 26usize] =
    b"generate-mac-address-mask\0";
pub const NM_SETTING_WIRED_MAC_ADDRESS_BLACKLIST: &'static [u8; 22usize] =
    b"mac-address-blacklist\0";
pub const NM_SETTING_WIRED_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_SETTING_WIRED_S390_SUBCHANNELS: &'static [u8; 17usize] = b"s390-subchannels\0";
pub const NM_SETTING_WIRED_S390_NETTYPE: &'static [u8; 13usize] = b"s390-nettype\0";
pub const NM_SETTING_WIRED_S390_OPTIONS: &'static [u8; 13usize] = b"s390-options\0";
pub const NM_SETTING_WIRED_WAKE_ON_LAN: &'static [u8; 12usize] = b"wake-on-lan\0";
pub const NM_SETTING_WIRED_WAKE_ON_LAN_PASSWORD: &'static [u8; 21usize] = b"wake-on-lan-password\0";
pub const NM_WIREGUARD_PUBLIC_KEY_LEN: u32 = 32;
pub const NM_WIREGUARD_SYMMETRIC_KEY_LEN: u32 = 32;
pub const NM_SETTING_WIREGUARD_SETTING_NAME: &'static [u8; 10usize] = b"wireguard\0";
pub const NM_SETTING_WIREGUARD_FWMARK: &'static [u8; 7usize] = b"fwmark\0";
pub const NM_SETTING_WIREGUARD_LISTEN_PORT: &'static [u8; 12usize] = b"listen-port\0";
pub const NM_SETTING_WIREGUARD_PRIVATE_KEY: &'static [u8; 12usize] = b"private-key\0";
pub const NM_SETTING_WIREGUARD_PRIVATE_KEY_FLAGS: &'static [u8; 18usize] = b"private-key-flags\0";
pub const NM_SETTING_WIREGUARD_PEERS: &'static [u8; 6usize] = b"peers\0";
pub const NM_SETTING_WIREGUARD_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_SETTING_WIREGUARD_PEER_ROUTES: &'static [u8; 12usize] = b"peer-routes\0";
pub const NM_SETTING_WIREGUARD_IP4_AUTO_DEFAULT_ROUTE: &'static [u8; 23usize] =
    b"ip4-auto-default-route\0";
pub const NM_SETTING_WIREGUARD_IP6_AUTO_DEFAULT_ROUTE: &'static [u8; 23usize] =
    b"ip6-auto-default-route\0";
pub const NM_WIREGUARD_PEER_ATTR_ALLOWED_IPS: &'static [u8; 12usize] = b"allowed-ips\0";
pub const NM_WIREGUARD_PEER_ATTR_ENDPOINT: &'static [u8; 9usize] = b"endpoint\0";
pub const NM_WIREGUARD_PEER_ATTR_PERSISTENT_KEEPALIVE: &'static [u8; 21usize] =
    b"persistent-keepalive\0";
pub const NM_WIREGUARD_PEER_ATTR_PRESHARED_KEY: &'static [u8; 14usize] = b"preshared-key\0";
pub const NM_WIREGUARD_PEER_ATTR_PRESHARED_KEY_FLAGS: &'static [u8; 20usize] =
    b"preshared-key-flags\0";
pub const NM_WIREGUARD_PEER_ATTR_PUBLIC_KEY: &'static [u8; 11usize] = b"public-key\0";
pub const NM_SETTING_WIRELESS_SETTING_NAME: &'static [u8; 16usize] = b"802-11-wireless\0";
pub const NM_SETTING_WIRELESS_SSID: &'static [u8; 5usize] = b"ssid\0";
pub const NM_SETTING_WIRELESS_MODE: &'static [u8; 5usize] = b"mode\0";
pub const NM_SETTING_WIRELESS_BAND: &'static [u8; 5usize] = b"band\0";
pub const NM_SETTING_WIRELESS_CHANNEL: &'static [u8; 8usize] = b"channel\0";
pub const NM_SETTING_WIRELESS_BSSID: &'static [u8; 6usize] = b"bssid\0";
pub const NM_SETTING_WIRELESS_RATE: &'static [u8; 5usize] = b"rate\0";
pub const NM_SETTING_WIRELESS_TX_POWER: &'static [u8; 9usize] = b"tx-power\0";
pub const NM_SETTING_WIRELESS_MAC_ADDRESS: &'static [u8; 12usize] = b"mac-address\0";
pub const NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS: &'static [u8; 19usize] = b"cloned-mac-address\0";
pub const NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK: &'static [u8; 26usize] =
    b"generate-mac-address-mask\0";
pub const NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST: &'static [u8; 22usize] =
    b"mac-address-blacklist\0";
pub const NM_SETTING_WIRELESS_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_SETTING_WIRELESS_SEEN_BSSIDS: &'static [u8; 12usize] = b"seen-bssids\0";
pub const NM_SETTING_WIRELESS_HIDDEN: &'static [u8; 7usize] = b"hidden\0";
pub const NM_SETTING_WIRELESS_POWERSAVE: &'static [u8; 10usize] = b"powersave\0";
pub const NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION: &'static [u8; 26usize] =
    b"mac-address-randomization\0";
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN: &'static [u8; 13usize] = b"wake-on-wlan\0";
pub const NM_SETTING_WIRELESS_MODE_ADHOC: &'static [u8; 6usize] = b"adhoc\0";
pub const NM_SETTING_WIRELESS_MODE_AP: &'static [u8; 3usize] = b"ap\0";
pub const NM_SETTING_WIRELESS_MODE_INFRA: &'static [u8; 15usize] = b"infrastructure\0";
pub const NM_SETTING_WIRELESS_MODE_MESH: &'static [u8; 5usize] = b"mesh\0";
pub const NM_SETTING_WPAN_SETTING_NAME: &'static [u8; 5usize] = b"wpan\0";
pub const NM_SETTING_WPAN_MAC_ADDRESS: &'static [u8; 12usize] = b"mac-address\0";
pub const NM_SETTING_WPAN_PAN_ID: &'static [u8; 7usize] = b"pan-id\0";
pub const NM_SETTING_WPAN_SHORT_ADDRESS: &'static [u8; 14usize] = b"short-address\0";
pub const NM_SETTING_WPAN_PAGE: &'static [u8; 5usize] = b"page\0";
pub const NM_SETTING_WPAN_CHANNEL: &'static [u8; 8usize] = b"channel\0";
pub const NM_SETTING_WPAN_PAGE_DEFAULT: i32 = -1;
pub const NM_SETTING_WPAN_CHANNEL_DEFAULT: i32 = -1;
pub const NM_DBUS_PATH_VPN: &'static [u8; 44usize] =
    b"/org/freedesktop/NetworkManager/VPN/Manager\0";
pub const NM_DBUS_INTERFACE_VPN: &'static [u8; 43usize] =
    b"org.freedesktop.NetworkManager.VPN.Manager\0";
pub const NM_DBUS_PATH_VPN_CONNECTION: &'static [u8; 47usize] =
    b"/org/freedesktop/NetworkManager/VPN/Connection\0";
pub const NM_DBUS_INTERFACE_VPN_CONNECTION: &'static [u8; 46usize] =
    b"org.freedesktop.NetworkManager.VPN.Connection\0";
pub const NM_VPN_DBUS_PLUGIN_PATH: &'static [u8; 43usize] =
    b"/org/freedesktop/NetworkManager/VPN/Plugin\0";
pub const NM_VPN_DBUS_PLUGIN_INTERFACE: &'static [u8; 42usize] =
    b"org.freedesktop.NetworkManager.VPN.Plugin\0";
pub const NM_DBUS_NO_ACTIVE_VPN_CONNECTION: &'static [u8; 68usize] =
    b"org.freedesktop.NetworkManager.VPNConnections.NoActiveVPNConnection\0";
pub const NM_DBUS_NO_VPN_CONNECTIONS: &'static [u8; 63usize] =
    b"org.freedesktop.NetworkManager.VPNConnections.NoVPNConnections\0";
pub const NM_DBUS_INVALID_VPN_CONNECTION: &'static [u8; 67usize] =
    b"org.freedesktop.NetworkManager.VPNConnections.InvalidVPNConnection\0";
pub const NM_DBUS_VPN_ERROR_PREFIX: &'static [u8; 41usize] =
    b"org.freedesktop.NetworkManager.VPN.Error\0";
pub const NM_DBUS_VPN_STARTING_IN_PROGRESS: &'static [u8; 19usize] = b"StartingInProgress\0";
pub const NM_DBUS_VPN_ALREADY_STARTED: &'static [u8; 15usize] = b"AlreadyStarted\0";
pub const NM_DBUS_VPN_STOPPING_IN_PROGRESS: &'static [u8; 19usize] = b"StoppingInProgress\0";
pub const NM_DBUS_VPN_ALREADY_STOPPED: &'static [u8; 15usize] = b"AlreadyStopped\0";
pub const NM_DBUS_VPN_WRONG_STATE: &'static [u8; 11usize] = b"WrongState\0";
pub const NM_DBUS_VPN_BAD_ARGUMENTS: &'static [u8; 13usize] = b"BadArguments\0";
pub const NM_DBUS_VPN_INTERACTIVE_NOT_SUPPORTED: &'static [u8; 24usize] =
    b"InteractiveNotSupported\0";
pub const NM_DBUS_VPN_SIGNAL_LOGIN_BANNER: &'static [u8; 12usize] = b"LoginBanner\0";
pub const NM_DBUS_VPN_SIGNAL_LOGIN_FAILED: &'static [u8; 12usize] = b"LoginFailed\0";
pub const NM_DBUS_VPN_SIGNAL_LAUNCH_FAILED: &'static [u8; 13usize] = b"LaunchFailed\0";
pub const NM_DBUS_VPN_SIGNAL_CONNECT_FAILED: &'static [u8; 14usize] = b"ConnectFailed\0";
pub const NM_DBUS_VPN_SIGNAL_VPN_CONFIG_BAD: &'static [u8; 13usize] = b"VPNConfigBad\0";
pub const NM_DBUS_VPN_SIGNAL_IP_CONFIG_BAD: &'static [u8; 12usize] = b"IPConfigBad\0";
pub const NM_DBUS_VPN_SIGNAL_STATE_CHANGE: &'static [u8; 12usize] = b"StateChange\0";
pub const NM_DBUS_VPN_SIGNAL_IP4_CONFIG: &'static [u8; 10usize] = b"IP4Config\0";
pub const NM_VPN_PLUGIN_CONFIG_TUNDEV: &'static [u8; 7usize] = b"tundev\0";
pub const NM_VPN_PLUGIN_CONFIG_PROXY_PAC: &'static [u8; 4usize] = b"pac\0";
pub const NM_VPN_PLUGIN_CONFIG_BANNER: &'static [u8; 7usize] = b"banner\0";
pub const NM_VPN_PLUGIN_CONFIG_EXT_GATEWAY: &'static [u8; 8usize] = b"gateway\0";
pub const NM_VPN_PLUGIN_CONFIG_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_VPN_PLUGIN_CONFIG_HAS_IP4: &'static [u8; 8usize] = b"has-ip4\0";
pub const NM_VPN_PLUGIN_CONFIG_HAS_IP6: &'static [u8; 8usize] = b"has-ip6\0";
pub const NM_VPN_PLUGIN_CAN_PERSIST: &'static [u8; 12usize] = b"can-persist\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY: &'static [u8; 17usize] = b"internal-gateway\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_ADDRESS: &'static [u8; 8usize] = b"address\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_PTP: &'static [u8; 4usize] = b"ptp\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_PREFIX: &'static [u8; 7usize] = b"prefix\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_DNS: &'static [u8; 4usize] = b"dns\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_NBNS: &'static [u8; 5usize] = b"nbns\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_MSS: &'static [u8; 4usize] = b"mss\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_DOMAIN: &'static [u8; 7usize] = b"domain\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_DOMAINS: &'static [u8; 8usize] = b"domains\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_ROUTES: &'static [u8; 7usize] = b"routes\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_PRESERVE_ROUTES: &'static [u8; 16usize] = b"preserve-routes\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT: &'static [u8; 14usize] = b"never-default\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_BANNER: &'static [u8; 7usize] = b"banner\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_EXT_GATEWAY: &'static [u8; 8usize] = b"gateway\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_MTU: &'static [u8; 4usize] = b"mtu\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_TUNDEV: &'static [u8; 7usize] = b"tundev\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_INT_GATEWAY: &'static [u8; 17usize] = b"internal-gateway\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_ADDRESS: &'static [u8; 8usize] = b"address\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_PTP: &'static [u8; 4usize] = b"ptp\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_PREFIX: &'static [u8; 7usize] = b"prefix\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_DNS: &'static [u8; 4usize] = b"dns\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_MSS: &'static [u8; 4usize] = b"mss\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_DOMAIN: &'static [u8; 7usize] = b"domain\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_DOMAINS: &'static [u8; 8usize] = b"domains\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_ROUTES: &'static [u8; 7usize] = b"routes\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_PRESERVE_ROUTES: &'static [u8; 16usize] = b"preserve-routes\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_NEVER_DEFAULT: &'static [u8; 14usize] = b"never-default\0";
pub const NM_VPN_CONNECTION_VPN_STATE: &'static [u8; 10usize] = b"vpn-state\0";
pub const NM_VPN_CONNECTION_BANNER: &'static [u8; 7usize] = b"banner\0";
pub const NM_VPN_EDITOR_PLUGIN_NAME: &'static [u8; 5usize] = b"name\0";
pub const NM_VPN_EDITOR_PLUGIN_DESCRIPTION: &'static [u8; 12usize] = b"description\0";
pub const NM_VPN_EDITOR_PLUGIN_SERVICE: &'static [u8; 8usize] = b"service\0";
pub const NM_VPN_PLUGIN_INFO_NAME: &'static [u8; 5usize] = b"name\0";
pub const NM_VPN_PLUGIN_INFO_FILENAME: &'static [u8; 9usize] = b"filename\0";
pub const NM_VPN_PLUGIN_INFO_KEYFILE: &'static [u8; 8usize] = b"keyfile\0";
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_CONNECTION: &'static [u8; 15usize] = b"VPN Connection\0";
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_LIBNM: &'static [u8; 6usize] = b"libnm\0";
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_GNOME: &'static [u8; 6usize] = b"GNOME\0";
pub const NM_VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME: &'static [u8; 13usize] = b"service-name\0";
pub const NM_VPN_SERVICE_PLUGIN_DBUS_WATCH_PEER: &'static [u8; 11usize] = b"watch-peer\0";
pub const NM_VPN_SERVICE_PLUGIN_STATE: &'static [u8; 6usize] = b"state\0";
pub const NM_WIFI_P2P_PEER_FLAGS: &'static [u8; 6usize] = b"flags\0";
pub const NM_WIFI_P2P_PEER_NAME: &'static [u8; 5usize] = b"name\0";
pub const NM_WIFI_P2P_PEER_MANUFACTURER: &'static [u8; 13usize] = b"manufacturer\0";
pub const NM_WIFI_P2P_PEER_MODEL: &'static [u8; 6usize] = b"model\0";
pub const NM_WIFI_P2P_PEER_MODEL_NUMBER: &'static [u8; 13usize] = b"model-number\0";
pub const NM_WIFI_P2P_PEER_SERIAL: &'static [u8; 7usize] = b"serial\0";
pub const NM_WIFI_P2P_PEER_WFD_IES: &'static [u8; 8usize] = b"wfd-ies\0";
pub const NM_WIFI_P2P_PEER_HW_ADDRESS: &'static [u8; 11usize] = b"hw-address\0";
pub const NM_WIFI_P2P_PEER_STRENGTH: &'static [u8; 9usize] = b"strength\0";
pub const NM_WIFI_P2P_PEER_LAST_SEEN: &'static [u8; 10usize] = b"last-seen\0";
pub const NM_WIMAX_NSP_NAME: &'static [u8; 5usize] = b"name\0";
pub const NM_WIMAX_NSP_SIGNAL_QUALITY: &'static [u8; 15usize] = b"signal-quality\0";
pub const NM_WIMAX_NSP_NETWORK_TYPE: &'static [u8; 13usize] = b"network-type\0";
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type gchar = ::std::os::raw::c_char;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub const NMCapability_NM_CAPABILITY_TEAM: NMCapability = 1;
pub const NMCapability_NM_CAPABILITY_OVS: NMCapability = 2;
#[doc = " NMCapability:"]
#[doc = " @NM_CAPABILITY_TEAM: Teams can be managed. This means the team device plugin"]
#[doc = "   is loaded."]
#[doc = " @NM_CAPABILITY_OVS: OpenVSwitch can be managed. This means the OVS device plugin"]
#[doc = "   is loaded. Since: 1.24"]
#[doc = ""]
#[doc = " #NMCapability names the numbers in the Capabilities property."]
#[doc = " Capabilities are positive numbers. They are part of stable API"]
#[doc = " and a certain capability number is guaranteed not to change."]
#[doc = ""]
#[doc = " The range 0x7000 - 0x7FFF of capabilities is guaranteed not to be"]
#[doc = " used by upstream NetworkManager. It could thus be used for downstream"]
#[doc = " extensions."]
pub type NMCapability = ::std::os::raw::c_uint;
pub const NMState_NM_STATE_UNKNOWN: NMState = 0;
pub const NMState_NM_STATE_ASLEEP: NMState = 10;
pub const NMState_NM_STATE_DISCONNECTED: NMState = 20;
pub const NMState_NM_STATE_DISCONNECTING: NMState = 30;
pub const NMState_NM_STATE_CONNECTING: NMState = 40;
pub const NMState_NM_STATE_CONNECTED_LOCAL: NMState = 50;
pub const NMState_NM_STATE_CONNECTED_SITE: NMState = 60;
pub const NMState_NM_STATE_CONNECTED_GLOBAL: NMState = 70;
#[doc = " NMState:"]
#[doc = " @NM_STATE_UNKNOWN: Networking state is unknown. This indicates a daemon error"]
#[doc = "    that makes it unable to reasonably assess the state. In such event the"]
#[doc = "    applications are expected to assume Internet connectivity might be present"]
#[doc = "    and not disable controls that require network access."]
#[doc = "    The graphical shells may hide the network accessibility indicator altogether"]
#[doc = "    since no meaningful status indication can be provided."]
#[doc = " @NM_STATE_ASLEEP: Networking is not enabled, the system is being suspended or"]
#[doc = "    resumed from suspend."]
#[doc = " @NM_STATE_DISCONNECTED: There is no active network connection."]
#[doc = "    The graphical shell should indicate  no network connectivity and the"]
#[doc = "    applications should not attempt to access the network."]
#[doc = " @NM_STATE_DISCONNECTING: Network connections are being cleaned up."]
#[doc = "    The applications should tear down their network sessions."]
#[doc = " @NM_STATE_CONNECTING: A network connection is being started"]
#[doc = "    The graphical shell should indicate the network is being connected while"]
#[doc = "    the applications should still make no attempts to connect the network."]
#[doc = " @NM_STATE_CONNECTED_LOCAL: There is only local IPv4 and/or IPv6 connectivity,"]
#[doc = "    but no default route to access the Internet. The graphical shell should"]
#[doc = "    indicate no network connectivity."]
#[doc = " @NM_STATE_CONNECTED_SITE: There is only site-wide IPv4 and/or IPv6 connectivity."]
#[doc = "    This means a default route is available, but the Internet connectivity check"]
#[doc = "    (see \"Connectivity\" property) did not succeed. The graphical shell should"]
#[doc = "    indicate limited network connectivity."]
#[doc = " @NM_STATE_CONNECTED_GLOBAL: There is global IPv4 and/or IPv6 Internet connectivity"]
#[doc = "    This means the Internet connectivity check succeeded, the graphical shell should"]
#[doc = "    indicate full network connectivity."]
#[doc = ""]
#[doc = " #NMState values indicate the current overall networking state."]
pub type NMState = ::std::os::raw::c_uint;
pub const NMConnectivityState_NM_CONNECTIVITY_UNKNOWN: NMConnectivityState = 0;
pub const NMConnectivityState_NM_CONNECTIVITY_NONE: NMConnectivityState = 1;
pub const NMConnectivityState_NM_CONNECTIVITY_PORTAL: NMConnectivityState = 2;
pub const NMConnectivityState_NM_CONNECTIVITY_LIMITED: NMConnectivityState = 3;
pub const NMConnectivityState_NM_CONNECTIVITY_FULL: NMConnectivityState = 4;
#[doc = " NMConnectivityState:"]
#[doc = " @NM_CONNECTIVITY_UNKNOWN: Network connectivity is unknown. This means the"]
#[doc = "   connectivity checks are disabled (e.g. on server installations) or has"]
#[doc = "   not run yet. The graphical shell should assume the Internet connection"]
#[doc = "   might be available and not present a captive portal window."]
#[doc = " @NM_CONNECTIVITY_NONE: The host is not connected to any network. There's"]
#[doc = "   no active connection that contains a default route to the internet and"]
#[doc = "   thus it makes no sense to even attempt a connectivity check. The graphical"]
#[doc = "   shell should use this state to indicate the network connection is unavailable."]
#[doc = " @NM_CONNECTIVITY_PORTAL: The Internet connection is hijacked by a captive"]
#[doc = "   portal gateway. The graphical shell may open a sandboxed web browser window"]
#[doc = "   (because the captive portals typically attempt a man-in-the-middle attacks"]
#[doc = "   against the https connections) for the purpose of authenticating to a gateway"]
#[doc = "   and retrigger the connectivity check with CheckConnectivity() when the"]
#[doc = "   browser window is dismissed."]
#[doc = " @NM_CONNECTIVITY_LIMITED: The host is connected to a network, does not appear"]
#[doc = "   to be able to reach the full Internet, but a captive portal has not been"]
#[doc = "   detected."]
#[doc = " @NM_CONNECTIVITY_FULL: The host is connected to a network, and"]
#[doc = "   appears to be able to reach the full Internet."]
pub type NMConnectivityState = ::std::os::raw::c_uint;
pub const NMDeviceType_NM_DEVICE_TYPE_UNKNOWN: NMDeviceType = 0;
pub const NMDeviceType_NM_DEVICE_TYPE_ETHERNET: NMDeviceType = 1;
pub const NMDeviceType_NM_DEVICE_TYPE_WIFI: NMDeviceType = 2;
pub const NMDeviceType_NM_DEVICE_TYPE_UNUSED1: NMDeviceType = 3;
pub const NMDeviceType_NM_DEVICE_TYPE_UNUSED2: NMDeviceType = 4;
pub const NMDeviceType_NM_DEVICE_TYPE_BT: NMDeviceType = 5;
pub const NMDeviceType_NM_DEVICE_TYPE_OLPC_MESH: NMDeviceType = 6;
pub const NMDeviceType_NM_DEVICE_TYPE_WIMAX: NMDeviceType = 7;
pub const NMDeviceType_NM_DEVICE_TYPE_MODEM: NMDeviceType = 8;
pub const NMDeviceType_NM_DEVICE_TYPE_INFINIBAND: NMDeviceType = 9;
pub const NMDeviceType_NM_DEVICE_TYPE_BOND: NMDeviceType = 10;
pub const NMDeviceType_NM_DEVICE_TYPE_VLAN: NMDeviceType = 11;
pub const NMDeviceType_NM_DEVICE_TYPE_ADSL: NMDeviceType = 12;
pub const NMDeviceType_NM_DEVICE_TYPE_BRIDGE: NMDeviceType = 13;
pub const NMDeviceType_NM_DEVICE_TYPE_GENERIC: NMDeviceType = 14;
pub const NMDeviceType_NM_DEVICE_TYPE_TEAM: NMDeviceType = 15;
pub const NMDeviceType_NM_DEVICE_TYPE_TUN: NMDeviceType = 16;
pub const NMDeviceType_NM_DEVICE_TYPE_IP_TUNNEL: NMDeviceType = 17;
pub const NMDeviceType_NM_DEVICE_TYPE_MACVLAN: NMDeviceType = 18;
pub const NMDeviceType_NM_DEVICE_TYPE_VXLAN: NMDeviceType = 19;
pub const NMDeviceType_NM_DEVICE_TYPE_VETH: NMDeviceType = 20;
pub const NMDeviceType_NM_DEVICE_TYPE_MACSEC: NMDeviceType = 21;
pub const NMDeviceType_NM_DEVICE_TYPE_DUMMY: NMDeviceType = 22;
pub const NMDeviceType_NM_DEVICE_TYPE_PPP: NMDeviceType = 23;
pub const NMDeviceType_NM_DEVICE_TYPE_OVS_INTERFACE: NMDeviceType = 24;
pub const NMDeviceType_NM_DEVICE_TYPE_OVS_PORT: NMDeviceType = 25;
pub const NMDeviceType_NM_DEVICE_TYPE_OVS_BRIDGE: NMDeviceType = 26;
pub const NMDeviceType_NM_DEVICE_TYPE_WPAN: NMDeviceType = 27;
pub const NMDeviceType_NM_DEVICE_TYPE_6LOWPAN: NMDeviceType = 28;
pub const NMDeviceType_NM_DEVICE_TYPE_WIREGUARD: NMDeviceType = 29;
pub const NMDeviceType_NM_DEVICE_TYPE_WIFI_P2P: NMDeviceType = 30;
pub const NMDeviceType_NM_DEVICE_TYPE_VRF: NMDeviceType = 31;
#[doc = " NMDeviceType:"]
#[doc = " @NM_DEVICE_TYPE_UNKNOWN: unknown device"]
#[doc = " @NM_DEVICE_TYPE_GENERIC: generic support for unrecognized device types"]
#[doc = " @NM_DEVICE_TYPE_ETHERNET: a wired ethernet device"]
#[doc = " @NM_DEVICE_TYPE_WIFI: an 802.11 Wi-Fi device"]
#[doc = " @NM_DEVICE_TYPE_UNUSED1: not used"]
#[doc = " @NM_DEVICE_TYPE_UNUSED2: not used"]
#[doc = " @NM_DEVICE_TYPE_BT: a Bluetooth device supporting PAN or DUN access protocols"]
#[doc = " @NM_DEVICE_TYPE_OLPC_MESH: an OLPC XO mesh networking device"]
#[doc = " @NM_DEVICE_TYPE_WIMAX: an 802.16e Mobile WiMAX broadband device"]
#[doc = " @NM_DEVICE_TYPE_MODEM: a modem supporting analog telephone, CDMA/EVDO,"]
#[doc = " GSM/UMTS, or LTE network access protocols"]
#[doc = " @NM_DEVICE_TYPE_INFINIBAND: an IP-over-InfiniBand device"]
#[doc = " @NM_DEVICE_TYPE_BOND: a bond master interface"]
#[doc = " @NM_DEVICE_TYPE_VLAN: an 802.1Q VLAN interface"]
#[doc = " @NM_DEVICE_TYPE_ADSL: ADSL modem"]
#[doc = " @NM_DEVICE_TYPE_BRIDGE: a bridge master interface"]
#[doc = " @NM_DEVICE_TYPE_TEAM: a team master interface"]
#[doc = " @NM_DEVICE_TYPE_TUN: a TUN or TAP interface"]
#[doc = " @NM_DEVICE_TYPE_IP_TUNNEL: a IP tunnel interface"]
#[doc = " @NM_DEVICE_TYPE_MACVLAN: a MACVLAN interface"]
#[doc = " @NM_DEVICE_TYPE_VXLAN: a VXLAN interface"]
#[doc = " @NM_DEVICE_TYPE_VETH: a VETH interface"]
#[doc = " @NM_DEVICE_TYPE_MACSEC: a MACsec interface"]
#[doc = " @NM_DEVICE_TYPE_DUMMY: a dummy interface"]
#[doc = " @NM_DEVICE_TYPE_PPP: a PPP interface"]
#[doc = " @NM_DEVICE_TYPE_OVS_INTERFACE: a Open vSwitch interface"]
#[doc = " @NM_DEVICE_TYPE_OVS_PORT: a Open vSwitch port"]
#[doc = " @NM_DEVICE_TYPE_OVS_BRIDGE: a Open vSwitch bridge"]
#[doc = " @NM_DEVICE_TYPE_WPAN: a IEEE 802.15.4 (WPAN) MAC Layer Device"]
#[doc = " @NM_DEVICE_TYPE_6LOWPAN: 6LoWPAN interface"]
#[doc = " @NM_DEVICE_TYPE_WIREGUARD: a WireGuard interface"]
#[doc = " @NM_DEVICE_TYPE_WIFI_P2P: an 802.11 Wi-Fi P2P device (Since: 1.16)"]
#[doc = " @NM_DEVICE_TYPE_VRF: A VRF (Virtual Routing and Forwarding) interface (Since: 1.24)"]
#[doc = ""]
#[doc = " #NMDeviceType values indicate the type of hardware represented by a"]
#[doc = " device object."]
pub type NMDeviceType = ::std::os::raw::c_uint;
pub const NMDeviceCapabilities_NM_DEVICE_CAP_NONE: NMDeviceCapabilities = 0;
pub const NMDeviceCapabilities_NM_DEVICE_CAP_NM_SUPPORTED: NMDeviceCapabilities = 1;
pub const NMDeviceCapabilities_NM_DEVICE_CAP_CARRIER_DETECT: NMDeviceCapabilities = 2;
pub const NMDeviceCapabilities_NM_DEVICE_CAP_IS_SOFTWARE: NMDeviceCapabilities = 4;
pub const NMDeviceCapabilities_NM_DEVICE_CAP_SRIOV: NMDeviceCapabilities = 8;
#[doc = " NMDeviceCapabilities:"]
#[doc = " @NM_DEVICE_CAP_NONE: device has no special capabilities"]
#[doc = " @NM_DEVICE_CAP_NM_SUPPORTED: NetworkManager supports this device"]
#[doc = " @NM_DEVICE_CAP_CARRIER_DETECT: this device can indicate carrier status"]
#[doc = " @NM_DEVICE_CAP_IS_SOFTWARE: this device is a software device"]
#[doc = " @NM_DEVICE_CAP_SRIOV: this device supports single-root I/O virtualization"]
#[doc = ""]
#[doc = " General device capability flags."]
pub type NMDeviceCapabilities = ::std::os::raw::c_uint;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_NONE: NMDeviceWifiCapabilities = 0;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_CIPHER_WEP40: NMDeviceWifiCapabilities = 1;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_CIPHER_WEP104: NMDeviceWifiCapabilities = 2;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_CIPHER_TKIP: NMDeviceWifiCapabilities = 4;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_CIPHER_CCMP: NMDeviceWifiCapabilities = 8;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_WPA: NMDeviceWifiCapabilities = 16;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_RSN: NMDeviceWifiCapabilities = 32;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_AP: NMDeviceWifiCapabilities = 64;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_ADHOC: NMDeviceWifiCapabilities = 128;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_FREQ_VALID: NMDeviceWifiCapabilities = 256;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_FREQ_2GHZ: NMDeviceWifiCapabilities = 512;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_FREQ_5GHZ: NMDeviceWifiCapabilities = 1024;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_MESH: NMDeviceWifiCapabilities = 4096;
pub const NMDeviceWifiCapabilities_NM_WIFI_DEVICE_CAP_IBSS_RSN: NMDeviceWifiCapabilities = 8192;
#[doc = " NMDeviceWifiCapabilities:"]
#[doc = " @NM_WIFI_DEVICE_CAP_NONE: device has no encryption/authentication capabilities"]
#[doc = " @NM_WIFI_DEVICE_CAP_CIPHER_WEP40: device supports 40/64-bit WEP encryption"]
#[doc = " @NM_WIFI_DEVICE_CAP_CIPHER_WEP104: device supports 104/128-bit WEP encryption"]
#[doc = " @NM_WIFI_DEVICE_CAP_CIPHER_TKIP: device supports TKIP encryption"]
#[doc = " @NM_WIFI_DEVICE_CAP_CIPHER_CCMP: device supports AES/CCMP encryption"]
#[doc = " @NM_WIFI_DEVICE_CAP_WPA: device supports WPA1 authentication"]
#[doc = " @NM_WIFI_DEVICE_CAP_RSN: device supports WPA2/RSN authentication"]
#[doc = " @NM_WIFI_DEVICE_CAP_AP: device supports Access Point mode"]
#[doc = " @NM_WIFI_DEVICE_CAP_ADHOC: device supports Ad-Hoc mode"]
#[doc = " @NM_WIFI_DEVICE_CAP_FREQ_VALID: device reports frequency capabilities"]
#[doc = " @NM_WIFI_DEVICE_CAP_FREQ_2GHZ: device supports 2.4GHz frequencies"]
#[doc = " @NM_WIFI_DEVICE_CAP_FREQ_5GHZ: device supports 5GHz frequencies"]
#[doc = " @NM_WIFI_DEVICE_CAP_MESH: device supports acting as a mesh point. Since: 1.20."]
#[doc = " @NM_WIFI_DEVICE_CAP_IBSS_RSN: device supports WPA2/RSN in an IBSS network. Since: 1.22."]
#[doc = ""]
#[doc = " 802.11 specific device encryption and authentication capabilities."]
pub type NMDeviceWifiCapabilities = ::std::os::raw::c_uint;
pub const NM80211ApFlags_NM_802_11_AP_FLAGS_NONE: NM80211ApFlags = 0;
pub const NM80211ApFlags_NM_802_11_AP_FLAGS_PRIVACY: NM80211ApFlags = 1;
pub const NM80211ApFlags_NM_802_11_AP_FLAGS_WPS: NM80211ApFlags = 2;
pub const NM80211ApFlags_NM_802_11_AP_FLAGS_WPS_PBC: NM80211ApFlags = 4;
pub const NM80211ApFlags_NM_802_11_AP_FLAGS_WPS_PIN: NM80211ApFlags = 8;
#[doc = " NM80211ApFlags:"]
#[doc = " @NM_802_11_AP_FLAGS_NONE: access point has no special capabilities"]
#[doc = " @NM_802_11_AP_FLAGS_PRIVACY: access point requires authentication and"]
#[doc = " encryption (usually means WEP)"]
#[doc = " @NM_802_11_AP_FLAGS_WPS: access point supports some WPS method"]
#[doc = " @NM_802_11_AP_FLAGS_WPS_PBC: access point supports push-button WPS"]
#[doc = " @NM_802_11_AP_FLAGS_WPS_PIN: access point supports PIN-based WPS"]
#[doc = ""]
#[doc = " 802.11 access point flags."]
pub type NM80211ApFlags = ::std::os::raw::c_uint;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_NONE: NM80211ApSecurityFlags = 0;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_PAIR_WEP40: NM80211ApSecurityFlags = 1;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_PAIR_WEP104: NM80211ApSecurityFlags = 2;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_PAIR_TKIP: NM80211ApSecurityFlags = 4;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_PAIR_CCMP: NM80211ApSecurityFlags = 8;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_GROUP_WEP40: NM80211ApSecurityFlags = 16;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_GROUP_WEP104: NM80211ApSecurityFlags = 32;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_GROUP_TKIP: NM80211ApSecurityFlags = 64;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_GROUP_CCMP: NM80211ApSecurityFlags = 128;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_KEY_MGMT_PSK: NM80211ApSecurityFlags = 256;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_KEY_MGMT_802_1X: NM80211ApSecurityFlags = 512;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_KEY_MGMT_SAE: NM80211ApSecurityFlags = 1024;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_KEY_MGMT_OWE: NM80211ApSecurityFlags = 2048;
pub const NM80211ApSecurityFlags_NM_802_11_AP_SEC_KEY_MGMT_OWE_TM: NM80211ApSecurityFlags = 4096;
#[doc = " NM80211ApSecurityFlags:"]
#[doc = " @NM_802_11_AP_SEC_NONE: the access point has no special security requirements"]
#[doc = " @NM_802_11_AP_SEC_PAIR_WEP40: 40/64-bit WEP is supported for"]
#[doc = " pairwise/unicast encryption"]
#[doc = " @NM_802_11_AP_SEC_PAIR_WEP104: 104/128-bit WEP is supported for"]
#[doc = " pairwise/unicast encryption"]
#[doc = " @NM_802_11_AP_SEC_PAIR_TKIP: TKIP is supported for pairwise/unicast encryption"]
#[doc = " @NM_802_11_AP_SEC_PAIR_CCMP: AES/CCMP is supported for pairwise/unicast encryption"]
#[doc = " @NM_802_11_AP_SEC_GROUP_WEP40: 40/64-bit WEP is supported for group/broadcast"]
#[doc = " encryption"]
#[doc = " @NM_802_11_AP_SEC_GROUP_WEP104: 104/128-bit WEP is supported for"]
#[doc = " group/broadcast encryption"]
#[doc = " @NM_802_11_AP_SEC_GROUP_TKIP: TKIP is supported for group/broadcast encryption"]
#[doc = " @NM_802_11_AP_SEC_GROUP_CCMP: AES/CCMP is supported for group/broadcast"]
#[doc = " encryption"]
#[doc = " @NM_802_11_AP_SEC_KEY_MGMT_PSK: WPA/RSN Pre-Shared Key encryption is"]
#[doc = " supported"]
#[doc = " @NM_802_11_AP_SEC_KEY_MGMT_802_1X: 802.1x authentication and key management"]
#[doc = " is supported"]
#[doc = " @NM_802_11_AP_SEC_KEY_MGMT_SAE: WPA/RSN Simultaneous Authentication of Equals is"]
#[doc = " supported"]
#[doc = " @NM_802_11_AP_SEC_KEY_MGMT_OWE: WPA/RSN Opportunistic Wireless Encryption is"]
#[doc = " supported"]
#[doc = " @NM_802_11_AP_SEC_KEY_MGMT_OWE_TM: WPA/RSN Opportunistic Wireless Encryption"]
#[doc = " transition mode is supported. Since: 1.26."]
#[doc = ""]
#[doc = " 802.11 access point security and authentication flags.  These flags describe"]
#[doc = " the current security requirements of an access point as determined from the"]
#[doc = " access point's beacon."]
pub type NM80211ApSecurityFlags = ::std::os::raw::c_uint;
pub const NM80211Mode_NM_802_11_MODE_UNKNOWN: NM80211Mode = 0;
pub const NM80211Mode_NM_802_11_MODE_ADHOC: NM80211Mode = 1;
pub const NM80211Mode_NM_802_11_MODE_INFRA: NM80211Mode = 2;
pub const NM80211Mode_NM_802_11_MODE_AP: NM80211Mode = 3;
pub const NM80211Mode_NM_802_11_MODE_MESH: NM80211Mode = 4;
#[doc = " NM80211Mode:"]
#[doc = " @NM_802_11_MODE_UNKNOWN: the device or access point mode is unknown"]
#[doc = " @NM_802_11_MODE_ADHOC: for both devices and access point objects, indicates"]
#[doc = "   the object is part of an Ad-Hoc 802.11 network without a central"]
#[doc = "   coordinating access point."]
#[doc = " @NM_802_11_MODE_INFRA: the device or access point is in infrastructure mode."]
#[doc = "   For devices, this indicates the device is an 802.11 client/station.  For"]
#[doc = "   access point objects, this indicates the object is an access point that"]
#[doc = "   provides connectivity to clients."]
#[doc = " @NM_802_11_MODE_AP: the device is an access point/hotspot.  Not valid for"]
#[doc = "   access point objects; used only for hotspot mode on the local machine."]
#[doc = " @NM_802_11_MODE_MESH: the device is a 802.11s mesh point. Since: 1.20."]
#[doc = ""]
#[doc = " Indicates the 802.11 mode an access point or device is currently in."]
pub type NM80211Mode = ::std::os::raw::c_uint;
pub const NMBluetoothCapabilities_NM_BT_CAPABILITY_NONE: NMBluetoothCapabilities = 0;
pub const NMBluetoothCapabilities_NM_BT_CAPABILITY_DUN: NMBluetoothCapabilities = 1;
pub const NMBluetoothCapabilities_NM_BT_CAPABILITY_NAP: NMBluetoothCapabilities = 2;
#[doc = " NMBluetoothCapabilities:"]
#[doc = " @NM_BT_CAPABILITY_NONE: device has no usable capabilities"]
#[doc = " @NM_BT_CAPABILITY_DUN: device provides Dial-Up Networking capability"]
#[doc = " @NM_BT_CAPABILITY_NAP: device provides Network Access Point capability"]
#[doc = ""]
#[doc = " #NMBluetoothCapabilities values indicate the usable capabilities of a"]
#[doc = " Bluetooth device."]
pub type NMBluetoothCapabilities = ::std::os::raw::c_uint;
pub const NMDeviceModemCapabilities_NM_DEVICE_MODEM_CAPABILITY_NONE: NMDeviceModemCapabilities = 0;
pub const NMDeviceModemCapabilities_NM_DEVICE_MODEM_CAPABILITY_POTS: NMDeviceModemCapabilities = 1;
pub const NMDeviceModemCapabilities_NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO:
    NMDeviceModemCapabilities = 2;
pub const NMDeviceModemCapabilities_NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS: NMDeviceModemCapabilities =
    4;
pub const NMDeviceModemCapabilities_NM_DEVICE_MODEM_CAPABILITY_LTE: NMDeviceModemCapabilities = 8;
#[doc = " NMDeviceModemCapabilities:"]
#[doc = " @NM_DEVICE_MODEM_CAPABILITY_NONE: modem has no usable capabilities"]
#[doc = " @NM_DEVICE_MODEM_CAPABILITY_POTS: modem uses the analog wired telephone"]
#[doc = " network and is not a wireless/cellular device"]
#[doc = " @NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO: modem supports at least one of CDMA"]
#[doc = " 1xRTT, EVDO revision 0, EVDO revision A, or EVDO revision B"]
#[doc = " @NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS: modem supports at least one of GSM,"]
#[doc = " GPRS, EDGE, UMTS, HSDPA, HSUPA, or HSPA+ packet switched data capability"]
#[doc = " @NM_DEVICE_MODEM_CAPABILITY_LTE: modem has LTE data capability"]
#[doc = ""]
#[doc = " #NMDeviceModemCapabilities values indicate the generic radio access"]
#[doc = " technology families a modem device supports.  For more information on the"]
#[doc = " specific access technologies the device supports use the ModemManager D-Bus"]
#[doc = " API."]
pub type NMDeviceModemCapabilities = ::std::os::raw::c_uint;
pub const NMWimaxNspNetworkType_NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN: NMWimaxNspNetworkType = 0;
pub const NMWimaxNspNetworkType_NM_WIMAX_NSP_NETWORK_TYPE_HOME: NMWimaxNspNetworkType = 1;
pub const NMWimaxNspNetworkType_NM_WIMAX_NSP_NETWORK_TYPE_PARTNER: NMWimaxNspNetworkType = 2;
pub const NMWimaxNspNetworkType_NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER: NMWimaxNspNetworkType =
    3;
#[doc = " NMWimaxNspNetworkType:"]
#[doc = " @NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN: unknown network type"]
#[doc = " @NM_WIMAX_NSP_NETWORK_TYPE_HOME: home network"]
#[doc = " @NM_WIMAX_NSP_NETWORK_TYPE_PARTNER: partner network"]
#[doc = " @NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER: roaming partner network"]
#[doc = ""]
#[doc = " WiMAX network type."]
pub type NMWimaxNspNetworkType = ::std::os::raw::c_uint;
pub const NMDeviceState_NM_DEVICE_STATE_UNKNOWN: NMDeviceState = 0;
pub const NMDeviceState_NM_DEVICE_STATE_UNMANAGED: NMDeviceState = 10;
pub const NMDeviceState_NM_DEVICE_STATE_UNAVAILABLE: NMDeviceState = 20;
pub const NMDeviceState_NM_DEVICE_STATE_DISCONNECTED: NMDeviceState = 30;
pub const NMDeviceState_NM_DEVICE_STATE_PREPARE: NMDeviceState = 40;
pub const NMDeviceState_NM_DEVICE_STATE_CONFIG: NMDeviceState = 50;
pub const NMDeviceState_NM_DEVICE_STATE_NEED_AUTH: NMDeviceState = 60;
pub const NMDeviceState_NM_DEVICE_STATE_IP_CONFIG: NMDeviceState = 70;
pub const NMDeviceState_NM_DEVICE_STATE_IP_CHECK: NMDeviceState = 80;
pub const NMDeviceState_NM_DEVICE_STATE_SECONDARIES: NMDeviceState = 90;
pub const NMDeviceState_NM_DEVICE_STATE_ACTIVATED: NMDeviceState = 100;
pub const NMDeviceState_NM_DEVICE_STATE_DEACTIVATING: NMDeviceState = 110;
pub const NMDeviceState_NM_DEVICE_STATE_FAILED: NMDeviceState = 120;
#[doc = " NMDeviceState:"]
#[doc = " @NM_DEVICE_STATE_UNKNOWN: the device's state is unknown"]
#[doc = " @NM_DEVICE_STATE_UNMANAGED: the device is recognized, but not managed by"]
#[doc = "   NetworkManager"]
#[doc = " @NM_DEVICE_STATE_UNAVAILABLE: the device is managed by NetworkManager, but"]
#[doc = "   is not available for use.  Reasons may include the wireless switched off,"]
#[doc = "   missing firmware, no ethernet carrier, missing supplicant or modem manager,"]
#[doc = "   etc."]
#[doc = " @NM_DEVICE_STATE_DISCONNECTED: the device can be activated, but is currently"]
#[doc = "   idle and not connected to a network."]
#[doc = " @NM_DEVICE_STATE_PREPARE: the device is preparing the connection to the"]
#[doc = "   network.  This may include operations like changing the MAC address,"]
#[doc = "   setting physical link properties, and anything else required to connect"]
#[doc = "   to the requested network."]
#[doc = " @NM_DEVICE_STATE_CONFIG: the device is connecting to the requested network."]
#[doc = "   This may include operations like associating with the Wi-Fi AP, dialing"]
#[doc = "   the modem, connecting to the remote Bluetooth device, etc."]
#[doc = " @NM_DEVICE_STATE_NEED_AUTH: the device requires more information to continue"]
#[doc = "   connecting to the requested network.  This includes secrets like WiFi"]
#[doc = "   passphrases, login passwords, PIN codes, etc."]
#[doc = " @NM_DEVICE_STATE_IP_CONFIG: the device is requesting IPv4 and/or IPv6"]
#[doc = "   addresses and routing information from the network."]
#[doc = " @NM_DEVICE_STATE_IP_CHECK: the device is checking whether further action is"]
#[doc = "   required for the requested network connection.  This may include checking"]
#[doc = "   whether only local network access is available, whether a captive portal"]
#[doc = "   is blocking access to the Internet, etc."]
#[doc = " @NM_DEVICE_STATE_SECONDARIES: the device is waiting for a secondary"]
#[doc = "   connection (like a VPN) which must activated before the device can be"]
#[doc = "   activated"]
#[doc = " @NM_DEVICE_STATE_ACTIVATED: the device has a network connection, either local"]
#[doc = "   or global."]
#[doc = " @NM_DEVICE_STATE_DEACTIVATING: a disconnection from the current network"]
#[doc = "   connection was requested, and the device is cleaning up resources used for"]
#[doc = "   that connection.  The network connection may still be valid."]
#[doc = " @NM_DEVICE_STATE_FAILED: the device failed to connect to the requested"]
#[doc = "   network and is cleaning up the connection request"]
pub type NMDeviceState = ::std::os::raw::c_uint;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_NONE: NMDeviceStateReason = 0;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_UNKNOWN: NMDeviceStateReason = 1;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_NOW_MANAGED: NMDeviceStateReason = 2;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_NOW_UNMANAGED: NMDeviceStateReason = 3;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_CONFIG_FAILED: NMDeviceStateReason = 4;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE: NMDeviceStateReason = 5;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED: NMDeviceStateReason = 6;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_NO_SECRETS: NMDeviceStateReason = 7;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT: NMDeviceStateReason = 8;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED: NMDeviceStateReason =
    9;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED: NMDeviceStateReason = 10;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT: NMDeviceStateReason = 11;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_PPP_START_FAILED: NMDeviceStateReason = 12;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_PPP_DISCONNECT: NMDeviceStateReason = 13;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_PPP_FAILED: NMDeviceStateReason = 14;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_DHCP_START_FAILED: NMDeviceStateReason = 15;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_DHCP_ERROR: NMDeviceStateReason = 16;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_DHCP_FAILED: NMDeviceStateReason = 17;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SHARED_START_FAILED: NMDeviceStateReason = 18;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SHARED_FAILED: NMDeviceStateReason = 19;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED: NMDeviceStateReason = 20;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_AUTOIP_ERROR: NMDeviceStateReason = 21;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_AUTOIP_FAILED: NMDeviceStateReason = 22;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_BUSY: NMDeviceStateReason = 23;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE: NMDeviceStateReason = 24;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER: NMDeviceStateReason = 25;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT: NMDeviceStateReason = 26;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED: NMDeviceStateReason = 27;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED: NMDeviceStateReason = 28;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_APN_FAILED: NMDeviceStateReason = 29;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING:
    NMDeviceStateReason = 30;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED: NMDeviceStateReason =
    31;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT: NMDeviceStateReason =
    32;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED: NMDeviceStateReason =
    33;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED: NMDeviceStateReason = 34;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_FIRMWARE_MISSING: NMDeviceStateReason = 35;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_REMOVED: NMDeviceStateReason = 36;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SLEEPING: NMDeviceStateReason = 37;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_CONNECTION_REMOVED: NMDeviceStateReason = 38;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_USER_REQUESTED: NMDeviceStateReason = 39;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_CARRIER: NMDeviceStateReason = 40;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED: NMDeviceStateReason = 41;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE: NMDeviceStateReason = 42;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND: NMDeviceStateReason = 43;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_BT_FAILED: NMDeviceStateReason = 44;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED: NMDeviceStateReason = 45;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED: NMDeviceStateReason = 46;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED: NMDeviceStateReason = 47;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_GSM_SIM_WRONG: NMDeviceStateReason = 48;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_INFINIBAND_MODE: NMDeviceStateReason = 49;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED: NMDeviceStateReason = 50;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_BR2684_FAILED: NMDeviceStateReason = 51;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE:
    NMDeviceStateReason = 52;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SSID_NOT_FOUND: NMDeviceStateReason = 53;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED:
    NMDeviceStateReason = 54;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED: NMDeviceStateReason = 55;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED: NMDeviceStateReason = 56;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_FAILED: NMDeviceStateReason = 57;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_MODEM_AVAILABLE: NMDeviceStateReason = 58;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT: NMDeviceStateReason = 59;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_NEW_ACTIVATION: NMDeviceStateReason = 60;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_PARENT_CHANGED: NMDeviceStateReason = 61;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED: NMDeviceStateReason =
    62;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_OVSDB_FAILED: NMDeviceStateReason = 63;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE: NMDeviceStateReason = 64;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED: NMDeviceStateReason =
    65;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED:
    NMDeviceStateReason = 66;
pub const NMDeviceStateReason_NM_DEVICE_STATE_REASON_PEER_NOT_FOUND: NMDeviceStateReason = 67;
#[doc = " NMDeviceStateReason:"]
#[doc = " @NM_DEVICE_STATE_REASON_NONE: No reason given"]
#[doc = " @NM_DEVICE_STATE_REASON_UNKNOWN: Unknown error"]
#[doc = " @NM_DEVICE_STATE_REASON_NOW_MANAGED: Device is now managed"]
#[doc = " @NM_DEVICE_STATE_REASON_NOW_UNMANAGED: Device is now unmanaged"]
#[doc = " @NM_DEVICE_STATE_REASON_CONFIG_FAILED: The device could not be readied for configuration"]
#[doc = " @NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE: IP configuration could not be reserved (no available address, timeout, etc)"]
#[doc = " @NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED: The IP config is no longer valid"]
#[doc = " @NM_DEVICE_STATE_REASON_NO_SECRETS: Secrets were required, but not provided"]
#[doc = " @NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT: 802.1x supplicant disconnected"]
#[doc = " @NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED: 802.1x supplicant configuration failed"]
#[doc = " @NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED: 802.1x supplicant failed"]
#[doc = " @NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT: 802.1x supplicant took too long to authenticate"]
#[doc = " @NM_DEVICE_STATE_REASON_PPP_START_FAILED: PPP service failed to start"]
#[doc = " @NM_DEVICE_STATE_REASON_PPP_DISCONNECT: PPP service disconnected"]
#[doc = " @NM_DEVICE_STATE_REASON_PPP_FAILED: PPP failed"]
#[doc = " @NM_DEVICE_STATE_REASON_DHCP_START_FAILED: DHCP client failed to start"]
#[doc = " @NM_DEVICE_STATE_REASON_DHCP_ERROR: DHCP client error"]
#[doc = " @NM_DEVICE_STATE_REASON_DHCP_FAILED: DHCP client failed"]
#[doc = " @NM_DEVICE_STATE_REASON_SHARED_START_FAILED: Shared connection service failed to start"]
#[doc = " @NM_DEVICE_STATE_REASON_SHARED_FAILED: Shared connection service failed"]
#[doc = " @NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED: AutoIP service failed to start"]
#[doc = " @NM_DEVICE_STATE_REASON_AUTOIP_ERROR: AutoIP service error"]
#[doc = " @NM_DEVICE_STATE_REASON_AUTOIP_FAILED: AutoIP service failed"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_BUSY: The line is busy"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE: No dial tone"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER: No carrier could be established"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT: The dialing request timed out"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED: The dialing attempt failed"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED: Modem initialization failed"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_APN_FAILED: Failed to select the specified APN"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING: Not searching for networks"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED: Network registration denied"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT: Network registration timed out"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED: Failed to register with the requested network"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED: PIN check failed"]
#[doc = " @NM_DEVICE_STATE_REASON_FIRMWARE_MISSING: Necessary firmware for the device may be missing"]
#[doc = " @NM_DEVICE_STATE_REASON_REMOVED: The device was removed"]
#[doc = " @NM_DEVICE_STATE_REASON_SLEEPING: NetworkManager went to sleep"]
#[doc = " @NM_DEVICE_STATE_REASON_CONNECTION_REMOVED: The device's active connection disappeared"]
#[doc = " @NM_DEVICE_STATE_REASON_USER_REQUESTED: Device disconnected by user or client"]
#[doc = " @NM_DEVICE_STATE_REASON_CARRIER: Carrier/link changed"]
#[doc = " @NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED: The device's existing connection was assumed"]
#[doc = " @NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE: The supplicant is now available"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND: The modem could not be found"]
#[doc = " @NM_DEVICE_STATE_REASON_BT_FAILED: The Bluetooth connection failed or timed out"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED: GSM Modem's SIM Card not inserted"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED: GSM Modem's SIM Pin required"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED: GSM Modem's SIM Puk required"]
#[doc = " @NM_DEVICE_STATE_REASON_GSM_SIM_WRONG: GSM Modem's SIM wrong"]
#[doc = " @NM_DEVICE_STATE_REASON_INFINIBAND_MODE: InfiniBand device does not support connected mode"]
#[doc = " @NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED: A dependency of the connection failed"]
#[doc = " @NM_DEVICE_STATE_REASON_BR2684_FAILED: Problem with the RFC 2684 Ethernet over ADSL bridge"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE: ModemManager not running"]
#[doc = " @NM_DEVICE_STATE_REASON_SSID_NOT_FOUND: The Wi-Fi network could not be found"]
#[doc = " @NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED: A secondary connection of the base connection failed"]
#[doc = " @NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED: DCB or FCoE setup failed"]
#[doc = " @NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED: teamd control failed"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_FAILED: Modem failed or no longer available"]
#[doc = " @NM_DEVICE_STATE_REASON_MODEM_AVAILABLE: Modem now ready and available"]
#[doc = " @NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT: SIM PIN was incorrect"]
#[doc = " @NM_DEVICE_STATE_REASON_NEW_ACTIVATION: New connection activation was enqueued"]
#[doc = " @NM_DEVICE_STATE_REASON_PARENT_CHANGED: the device's parent changed"]
#[doc = " @NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED: the device parent's management changed"]
#[doc = " @NM_DEVICE_STATE_REASON_OVSDB_FAILED: problem communicating with Open vSwitch database"]
#[doc = " @NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE: a duplicate IP address was detected"]
#[doc = " @NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED: The selected IP method is not supported"]
#[doc = " @NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED: configuration of SR-IOV parameters failed"]
#[doc = " @NM_DEVICE_STATE_REASON_PEER_NOT_FOUND: The Wi-Fi P2P peer could not be found"]
#[doc = ""]
#[doc = " Device state change reason codes"]
pub type NMDeviceStateReason = ::std::os::raw::c_uint;
pub const NMMetered_NM_METERED_UNKNOWN: NMMetered = 0;
pub const NMMetered_NM_METERED_YES: NMMetered = 1;
pub const NMMetered_NM_METERED_NO: NMMetered = 2;
pub const NMMetered_NM_METERED_GUESS_YES: NMMetered = 3;
pub const NMMetered_NM_METERED_GUESS_NO: NMMetered = 4;
#[doc = " NMMetered:"]
#[doc = " @NM_METERED_UNKNOWN:     The metered status is unknown"]
#[doc = " @NM_METERED_YES:         Metered, the value was explicitly configured"]
#[doc = " @NM_METERED_NO:          Not metered, the value was explicitly configured"]
#[doc = " @NM_METERED_GUESS_YES:   Metered, the value was guessed"]
#[doc = " @NM_METERED_GUESS_NO:    Not metered, the value was guessed"]
#[doc = ""]
#[doc = " The NMMetered enum has two different purposes: one is to configure"]
#[doc = " \"connection.metered\" setting of a connection profile in #NMSettingConnection, and"]
#[doc = " the other is to express the actual metered state of the #NMDevice at a given moment."]
#[doc = ""]
#[doc = " For the connection profile only #NM_METERED_UNKNOWN, #NM_METERED_NO"]
#[doc = " and #NM_METERED_YES are allowed."]
#[doc = ""]
#[doc = " The device's metered state at runtime is determined by the profile"]
#[doc = " which is currently active. If the profile explicitly specifies #NM_METERED_NO"]
#[doc = " or #NM_METERED_YES, then the device's metered state is as such."]
#[doc = " If the connection profile leaves it undecided at #NM_METERED_UNKNOWN (the default),"]
#[doc = " then NetworkManager tries to guess the metered state, for example based on the"]
#[doc = " device type or on DHCP options (like Android devices exposing a \"ANDROID_METERED\""]
#[doc = " DHCP vendor option). This then leads to either #NM_METERED_GUESS_NO or #NM_METERED_GUESS_YES."]
#[doc = ""]
#[doc = " Most applications probably should treat the runtime state #NM_METERED_GUESS_YES"]
#[doc = " like #NM_METERED_YES, and all other states as not metered."]
#[doc = ""]
#[doc = " Note that the per-device metered states are then combined to a global metered"]
#[doc = " state. This is basically the metered state of the device with the best default"]
#[doc = " route. However, that generalization of a global metered state may not be correct"]
#[doc = " if the default routes for IPv4 and IPv6 are on different devices, or if policy"]
#[doc = " routing is configured. In general, the global metered state tries to express whether"]
#[doc = " the traffic is likely metered, but since that depends on the traffic itself,"]
#[doc = " there is not one answer in all cases. Hence, an application may want to consider"]
#[doc = " the per-device's metered states."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub type NMMetered = ::std::os::raw::c_uint;
pub const NMConnectionMultiConnect_NM_CONNECTION_MULTI_CONNECT_DEFAULT: NMConnectionMultiConnect =
    0;
pub const NMConnectionMultiConnect_NM_CONNECTION_MULTI_CONNECT_SINGLE: NMConnectionMultiConnect = 1;
pub const NMConnectionMultiConnect_NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE:
    NMConnectionMultiConnect = 2;
pub const NMConnectionMultiConnect_NM_CONNECTION_MULTI_CONNECT_MULTIPLE: NMConnectionMultiConnect =
    3;
#[doc = " NMConnectionMultiConnect:"]
#[doc = " @NM_CONNECTION_MULTI_CONNECT_DEFAULT: indicates that the per-connection"]
#[doc = "   setting is unspecified. In this case, it will fallback to the default"]
#[doc = "   value, which is %NM_CONNECTION_MULTI_CONNECT_SINGLE."]
#[doc = " @NM_CONNECTION_MULTI_CONNECT_SINGLE: the connection profile can only"]
#[doc = "   be active once at each moment. Activating a profile that is already active,"]
#[doc = "   will first deactivate it."]
#[doc = " @NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE: the profile can"]
#[doc = "   be manually activated multiple times on different devices. However,"]
#[doc = "   regarding autoconnect, the profile will autoconnect only if it is"]
#[doc = "   currently not connected otherwise."]
#[doc = " @NM_CONNECTION_MULTI_CONNECT_MULTIPLE: the profile can autoactivate"]
#[doc = "   and be manually activated multiple times together."]
#[doc = ""]
#[doc = " Since: 1.14"]
pub type NMConnectionMultiConnect = ::std::os::raw::c_uint;
pub const NMActiveConnectionState_NM_ACTIVE_CONNECTION_STATE_UNKNOWN: NMActiveConnectionState = 0;
pub const NMActiveConnectionState_NM_ACTIVE_CONNECTION_STATE_ACTIVATING: NMActiveConnectionState =
    1;
pub const NMActiveConnectionState_NM_ACTIVE_CONNECTION_STATE_ACTIVATED: NMActiveConnectionState = 2;
pub const NMActiveConnectionState_NM_ACTIVE_CONNECTION_STATE_DEACTIVATING: NMActiveConnectionState =
    3;
pub const NMActiveConnectionState_NM_ACTIVE_CONNECTION_STATE_DEACTIVATED: NMActiveConnectionState =
    4;
#[doc = " NMActiveConnectionState:"]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_UNKNOWN: the state of the connection is unknown"]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_ACTIVATING: a network connection is being prepared"]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_ACTIVATED: there is a connection to the network"]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_DEACTIVATING: the network connection is being"]
#[doc = "   torn down and cleaned up"]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_DEACTIVATED: the network connection is disconnected"]
#[doc = "   and will be removed"]
#[doc = ""]
#[doc = " #NMActiveConnectionState values indicate the state of a connection to a"]
#[doc = " specific network while it is starting, connected, or disconnecting from that"]
#[doc = " network."]
pub type NMActiveConnectionState = ::std::os::raw::c_uint;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN:
    NMActiveConnectionStateReason = 0;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_NONE:
    NMActiveConnectionStateReason = 1;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED:
    NMActiveConnectionStateReason = 2;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED:
    NMActiveConnectionStateReason = 3;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED:
    NMActiveConnectionStateReason = 4;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID:
    NMActiveConnectionStateReason = 5;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT:
    NMActiveConnectionStateReason = 6;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT:
    NMActiveConnectionStateReason = 7;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED:
    NMActiveConnectionStateReason = 8;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS:
    NMActiveConnectionStateReason = 9;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED:
    NMActiveConnectionStateReason = 10;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED:
    NMActiveConnectionStateReason = 11;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED:
    NMActiveConnectionStateReason = 12;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED:
    NMActiveConnectionStateReason = 13;
pub const NMActiveConnectionStateReason_NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED:
    NMActiveConnectionStateReason = 14;
#[doc = " NMActiveConnectionStateReason:"]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN: The reason for the active connection"]
#[doc = "   state change is unknown."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_NONE: No reason was given for the active"]
#[doc = "   connection state change."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED: The active connection changed"]
#[doc = "   state because the user disconnected it."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED: The active connection"]
#[doc = "   changed state because the device it was using was disconnected."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED: The service providing the"]
#[doc = "   VPN connection was stopped."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID: The IP config of the active"]
#[doc = "   connection was invalid."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT: The connection attempt to"]
#[doc = "   the VPN service timed out."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT: A timeout occurred"]
#[doc = "   while starting the service providing the VPN connection."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED: Starting the service"]
#[doc = "   providing the VPN connection failed."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS: Necessary secrets for the"]
#[doc = "   connection were not provided."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED: Authentication to the"]
#[doc = "   server failed."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED: The connection was"]
#[doc = "   deleted from settings."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED: Master connection of this"]
#[doc = "   connection failed to activate."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED: Could not create the"]
#[doc = "   software device link."]
#[doc = " @NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED: The device this connection"]
#[doc = "   depended on disappeared."]
#[doc = ""]
#[doc = " Active connection state reasons."]
#[doc = ""]
#[doc = " Since: 1.8"]
pub type NMActiveConnectionStateReason = ::std::os::raw::c_uint;
pub const NMSecretAgentGetSecretsFlags_NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE:
    NMSecretAgentGetSecretsFlags = 0;
pub const NMSecretAgentGetSecretsFlags_NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION:
    NMSecretAgentGetSecretsFlags = 1;
pub const NMSecretAgentGetSecretsFlags_NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW:
    NMSecretAgentGetSecretsFlags = 2;
pub const NMSecretAgentGetSecretsFlags_NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED:
    NMSecretAgentGetSecretsFlags = 4;
pub const NMSecretAgentGetSecretsFlags_NM_SECRET_AGENT_GET_SECRETS_FLAG_WPS_PBC_ACTIVE:
    NMSecretAgentGetSecretsFlags = 8;
pub const NMSecretAgentGetSecretsFlags_NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM:
    NMSecretAgentGetSecretsFlags = 2147483648;
pub const NMSecretAgentGetSecretsFlags_NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS:
    NMSecretAgentGetSecretsFlags = 1073741824;
#[doc = " NMSecretAgentGetSecretsFlags:"]
#[doc = " @NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE: no special behavior; by default no"]
#[doc = "   user interaction is allowed and requests for secrets are fulfilled from"]
#[doc = "   persistent storage, or if no secrets are available an error is returned."]
#[doc = " @NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION: allows the request to"]
#[doc = "   interact with the user, possibly prompting via UI for secrets if any are"]
#[doc = "   required, or if none are found in persistent storage."]
#[doc = " @NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW: explicitly prompt for new"]
#[doc = "   secrets from the user.  This flag signals that NetworkManager thinks any"]
#[doc = "   existing secrets are invalid or wrong.  This flag implies that interaction"]
#[doc = "   is allowed."]
#[doc = " @NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED: set if the request was"]
#[doc = "   initiated by user-requested action via the D-Bus interface, as opposed to"]
#[doc = "   automatically initiated by NetworkManager in response to (for example) scan"]
#[doc = "   results or carrier changes."]
#[doc = " @NM_SECRET_AGENT_GET_SECRETS_FLAG_WPS_PBC_ACTIVE: indicates that WPS enrollment"]
#[doc = "   is active with PBC method. The agent may suggest that the user pushes a button"]
#[doc = "   on the router instead of supplying a PSK."]
#[doc = " @NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM: Internal flag, not part of"]
#[doc = "   the D-Bus API."]
#[doc = " @NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS: Internal flag, not part of"]
#[doc = "   the D-Bus API."]
#[doc = ""]
#[doc = " #NMSecretAgentGetSecretsFlags values modify the behavior of a GetSecrets request."]
pub type NMSecretAgentGetSecretsFlags = ::std::os::raw::c_uint;
pub const NMSecretAgentCapabilities_NM_SECRET_AGENT_CAPABILITY_NONE: NMSecretAgentCapabilities = 0;
pub const NMSecretAgentCapabilities_NM_SECRET_AGENT_CAPABILITY_VPN_HINTS:
    NMSecretAgentCapabilities = 1;
pub const NMSecretAgentCapabilities_NM_SECRET_AGENT_CAPABILITY_LAST: NMSecretAgentCapabilities = 1;
#[doc = " NMSecretAgentCapabilities:"]
#[doc = " @NM_SECRET_AGENT_CAPABILITY_NONE: the agent supports no special capabilities"]
#[doc = " @NM_SECRET_AGENT_CAPABILITY_VPN_HINTS: the agent supports passing hints to"]
#[doc = " VPN plugin authentication dialogs."]
#[doc = " @NM_SECRET_AGENT_CAPABILITY_LAST: bounds checking value; should not be used."]
#[doc = ""]
#[doc = " #NMSecretAgentCapabilities indicate various capabilities of the agent."]
pub type NMSecretAgentCapabilities = ::std::os::raw::c_uint;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_UNKNOWN: NMIPTunnelMode = 0;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_IPIP: NMIPTunnelMode = 1;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_GRE: NMIPTunnelMode = 2;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_SIT: NMIPTunnelMode = 3;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_ISATAP: NMIPTunnelMode = 4;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_VTI: NMIPTunnelMode = 5;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_IP6IP6: NMIPTunnelMode = 6;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_IPIP6: NMIPTunnelMode = 7;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_IP6GRE: NMIPTunnelMode = 8;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_VTI6: NMIPTunnelMode = 9;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_GRETAP: NMIPTunnelMode = 10;
pub const NMIPTunnelMode_NM_IP_TUNNEL_MODE_IP6GRETAP: NMIPTunnelMode = 11;
#[doc = " NMIPTunnelMode:"]
#[doc = " @NM_IP_TUNNEL_MODE_UNKNOWN:   Unknown/unset tunnel mode"]
#[doc = " @NM_IP_TUNNEL_MODE_IPIP:      IP in IP tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_GRE:       GRE tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_SIT:       SIT tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_ISATAP:    ISATAP tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_VTI:       VTI tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_IP6IP6:    IPv6 in IPv6 tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_IPIP6:     IPv4 in IPv6 tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_IP6GRE:    IPv6 GRE tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_VTI6:      IPv6 VTI tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_GRETAP:    GRETAP tunnel"]
#[doc = " @NM_IP_TUNNEL_MODE_IP6GRETAP: IPv6 GRETAP tunnel"]
#[doc = ""]
#[doc = " The tunneling mode."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub type NMIPTunnelMode = ::std::os::raw::c_uint;
pub const NMCheckpointCreateFlags_NM_CHECKPOINT_CREATE_FLAG_NONE: NMCheckpointCreateFlags = 0;
pub const NMCheckpointCreateFlags_NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL: NMCheckpointCreateFlags =
    1;
pub const NMCheckpointCreateFlags_NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS:
    NMCheckpointCreateFlags = 2;
pub const NMCheckpointCreateFlags_NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES:
    NMCheckpointCreateFlags = 4;
pub const NMCheckpointCreateFlags_NM_CHECKPOINT_CREATE_FLAG_ALLOW_OVERLAPPING:
    NMCheckpointCreateFlags = 8;
#[doc = " NMCheckpointCreateFlags:"]
#[doc = " @NM_CHECKPOINT_CREATE_FLAG_NONE: no flags"]
#[doc = " @NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL: when creating"]
#[doc = "   a new checkpoint, destroy all existing ones."]
#[doc = " @NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS: upon rollback,"]
#[doc = "   delete any new connection added after the checkpoint (Since: 1.6)"]
#[doc = " @NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES: upon rollback,"]
#[doc = "   disconnect any new device appeared after the checkpoint (Since: 1.6)"]
#[doc = " @NM_CHECKPOINT_CREATE_FLAG_ALLOW_OVERLAPPING: by default, creating"]
#[doc = "   a checkpoint fails if there are already existing checkoints that"]
#[doc = "   reference the same devices. With this flag, creation of such"]
#[doc = "   checkpoints is allowed, however, if an older checkpoint"]
#[doc = "   that references overlapping devices gets rolled back, it will"]
#[doc = "   automatically destroy this checkpoint during rollback. This"]
#[doc = "   allows to create several overlapping checkpoints in parallel,"]
#[doc = "   and rollback to them at will. With the special case that"]
#[doc = "   rolling back to an older checkpoint will invalidate all"]
#[doc = "   overlapping younger checkpoints. This opts-in that the"]
#[doc = "   checkpoint can be automatically destroyed by the rollback"]
#[doc = "   of an older checkpoint. (Since: 1.12)"]
#[doc = ""]
#[doc = " The flags for CheckpointCreate call"]
#[doc = ""]
#[doc = " Since: 1.4 (gi flags generated since 1.12)"]
pub type NMCheckpointCreateFlags = ::std::os::raw::c_uint;
pub const NMRollbackResult_NM_ROLLBACK_RESULT_OK: NMRollbackResult = 0;
pub const NMRollbackResult_NM_ROLLBACK_RESULT_ERR_NO_DEVICE: NMRollbackResult = 1;
pub const NMRollbackResult_NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED: NMRollbackResult = 2;
pub const NMRollbackResult_NM_ROLLBACK_RESULT_ERR_FAILED: NMRollbackResult = 3;
#[doc = " NMRollbackResult:"]
#[doc = " @NM_ROLLBACK_RESULT_OK: the rollback succeeded."]
#[doc = " @NM_ROLLBACK_RESULT_ERR_NO_DEVICE: the device no longer exists."]
#[doc = " @NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED: the device is now unmanaged."]
#[doc = " @NM_ROLLBACK_RESULT_ERR_FAILED: other errors during rollback."]
#[doc = ""]
#[doc = " The result of a checkpoint Rollback() operation for a specific device."]
#[doc = ""]
#[doc = " Since: 1.4"]
pub type NMRollbackResult = ::std::os::raw::c_uint;
pub const NMSettingsConnectionFlags_NM_SETTINGS_CONNECTION_FLAG_NONE: NMSettingsConnectionFlags = 0;
pub const NMSettingsConnectionFlags_NM_SETTINGS_CONNECTION_FLAG_UNSAVED: NMSettingsConnectionFlags =
    1;
pub const NMSettingsConnectionFlags_NM_SETTINGS_CONNECTION_FLAG_NM_GENERATED:
    NMSettingsConnectionFlags = 2;
pub const NMSettingsConnectionFlags_NM_SETTINGS_CONNECTION_FLAG_VOLATILE:
    NMSettingsConnectionFlags = 4;
pub const NMSettingsConnectionFlags_NM_SETTINGS_CONNECTION_FLAG_EXTERNAL:
    NMSettingsConnectionFlags = 8;
#[doc = " NMSettingsConnectionFlags:"]
#[doc = " @NM_SETTINGS_CONNECTION_FLAG_NONE: an alias for numeric zero, no flags set."]
#[doc = " @NM_SETTINGS_CONNECTION_FLAG_UNSAVED: the connection is not saved to disk."]
#[doc = "   That either means, that the connection is in-memory only and currently"]
#[doc = "   is not backed by a file. Or, that the connection is backed by a file,"]
#[doc = "   but has modifications in-memory that were not persisted to disk."]
#[doc = " @NM_SETTINGS_CONNECTION_FLAG_NM_GENERATED: A connection is \"nm-generated\" if"]
#[doc = "  it was generated by NetworkManger. If the connection gets modified or saved"]
#[doc = "  by the user, the flag gets cleared. A nm-generated is also unsaved"]
#[doc = "  and has no backing file as it is in-memory only."]
#[doc = " @NM_SETTINGS_CONNECTION_FLAG_VOLATILE: The connection will be deleted"]
#[doc = "  when it disconnects. That is for in-memory connections (unsaved), which are"]
#[doc = "  currently active but deleted on disconnect. Volatile connections are"]
#[doc = "  always unsaved, but they are also no backing file on disk and are entirely"]
#[doc = "  in-memory only."]
#[doc = " @NM_SETTINGS_CONNECTION_FLAG_EXTERNAL: the profile was generated to represent"]
#[doc = "  an external configuration of a networking device. Since: 1.26"]
#[doc = ""]
#[doc = " Flags describing the current activation state."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type NMSettingsConnectionFlags = ::std::os::raw::c_uint;
pub const NMActivationStateFlags_NM_ACTIVATION_STATE_FLAG_NONE: NMActivationStateFlags = 0;
pub const NMActivationStateFlags_NM_ACTIVATION_STATE_FLAG_IS_MASTER: NMActivationStateFlags = 1;
pub const NMActivationStateFlags_NM_ACTIVATION_STATE_FLAG_IS_SLAVE: NMActivationStateFlags = 2;
pub const NMActivationStateFlags_NM_ACTIVATION_STATE_FLAG_LAYER2_READY: NMActivationStateFlags = 4;
pub const NMActivationStateFlags_NM_ACTIVATION_STATE_FLAG_IP4_READY: NMActivationStateFlags = 8;
pub const NMActivationStateFlags_NM_ACTIVATION_STATE_FLAG_IP6_READY: NMActivationStateFlags = 16;
pub const NMActivationStateFlags_NM_ACTIVATION_STATE_FLAG_MASTER_HAS_SLAVES:
    NMActivationStateFlags = 32;
pub const NMActivationStateFlags_NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY:
    NMActivationStateFlags = 64;
pub const NMActivationStateFlags_NM_ACTIVATION_STATE_FLAG_EXTERNAL: NMActivationStateFlags = 128;
#[doc = " NMActivationStateFlags:"]
#[doc = " @NM_ACTIVATION_STATE_FLAG_NONE: an alias for numeric zero, no flags set."]
#[doc = " @NM_ACTIVATION_STATE_FLAG_IS_MASTER: the device is a master."]
#[doc = " @NM_ACTIVATION_STATE_FLAG_IS_SLAVE: the device is a slave."]
#[doc = " @NM_ACTIVATION_STATE_FLAG_LAYER2_READY: layer2 is activated and ready."]
#[doc = " @NM_ACTIVATION_STATE_FLAG_IP4_READY: IPv4 setting is completed."]
#[doc = " @NM_ACTIVATION_STATE_FLAG_IP6_READY: IPv6 setting is completed."]
#[doc = " @NM_ACTIVATION_STATE_FLAG_MASTER_HAS_SLAVES: The master has any slave devices attached."]
#[doc = "   This only makes sense if the device is a master."]
#[doc = " @NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY: the lifetime"]
#[doc = "   of the activation is bound to the visilibity of the connection profile,"]
#[doc = "   which in turn depends on \"connection.permissions\" and whether a session"]
#[doc = "   for the user exists. Since: 1.16"]
#[doc = " @NM_ACTIVATION_STATE_FLAG_EXTERNAL: the active connection was generated to"]
#[doc = "  represent an external configuration of a networking device. Since: 1.26"]
#[doc = ""]
#[doc = " Flags describing the current activation state."]
#[doc = ""]
#[doc = " Since: 1.10"]
pub type NMActivationStateFlags = ::std::os::raw::c_uint;
pub const NMSettingsAddConnection2Flags_NM_SETTINGS_ADD_CONNECTION2_FLAG_NONE:
    NMSettingsAddConnection2Flags = 0;
pub const NMSettingsAddConnection2Flags_NM_SETTINGS_ADD_CONNECTION2_FLAG_TO_DISK:
    NMSettingsAddConnection2Flags = 1;
pub const NMSettingsAddConnection2Flags_NM_SETTINGS_ADD_CONNECTION2_FLAG_IN_MEMORY:
    NMSettingsAddConnection2Flags = 2;
pub const NMSettingsAddConnection2Flags_NM_SETTINGS_ADD_CONNECTION2_FLAG_BLOCK_AUTOCONNECT:
    NMSettingsAddConnection2Flags = 32;
#[doc = " NMSettingsAddConnection2Flags:"]
#[doc = " @NM_SETTINGS_ADD_CONNECTION2_FLAG_NONE: an alias for numeric zero, no flags set."]
#[doc = " @NM_SETTINGS_ADD_CONNECTION2_FLAG_TO_DISK: to persist the connection to disk."]
#[doc = " @NM_SETTINGS_ADD_CONNECTION2_FLAG_IN_MEMORY: to make the connection in-memory only."]
#[doc = " @NM_SETTINGS_ADD_CONNECTION2_FLAG_BLOCK_AUTOCONNECT: usually, when the connection"]
#[doc = "   has autoconnect enabled and gets added, it becomes eligible to autoconnect"]
#[doc = "   right away. Setting this flag, disables autoconnect until the connection"]
#[doc = "   is manually activated."]
#[doc = ""]
#[doc = " Numeric flags for the \"flags\" argument of AddConnection2() D-Bus API."]
#[doc = ""]
#[doc = " Since: 1.20"]
pub type NMSettingsAddConnection2Flags = ::std::os::raw::c_uint;
pub const NMSettingsUpdate2Flags_NM_SETTINGS_UPDATE2_FLAG_NONE: NMSettingsUpdate2Flags = 0;
pub const NMSettingsUpdate2Flags_NM_SETTINGS_UPDATE2_FLAG_TO_DISK: NMSettingsUpdate2Flags = 1;
pub const NMSettingsUpdate2Flags_NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY: NMSettingsUpdate2Flags = 2;
pub const NMSettingsUpdate2Flags_NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED:
    NMSettingsUpdate2Flags = 4;
pub const NMSettingsUpdate2Flags_NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY: NMSettingsUpdate2Flags =
    8;
pub const NMSettingsUpdate2Flags_NM_SETTINGS_UPDATE2_FLAG_VOLATILE: NMSettingsUpdate2Flags = 16;
pub const NMSettingsUpdate2Flags_NM_SETTINGS_UPDATE2_FLAG_BLOCK_AUTOCONNECT:
    NMSettingsUpdate2Flags = 32;
pub const NMSettingsUpdate2Flags_NM_SETTINGS_UPDATE2_FLAG_NO_REAPPLY: NMSettingsUpdate2Flags = 64;
#[doc = " NMSettingsUpdate2Flags:"]
#[doc = " @NM_SETTINGS_UPDATE2_FLAG_NONE: an alias for numeric zero, no flags set."]
#[doc = " @NM_SETTINGS_UPDATE2_FLAG_TO_DISK: to persist the connection to disk."]
#[doc = " @NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY: makes the profile in-memory."]
#[doc = "   Note that such profiles are stored in keyfile format under /run."]
#[doc = "   If the file is already in-memory, the file in /run is updated in-place."]
#[doc = "   Otherwise, the previous storage for the profile is left unchanged"]
#[doc = "   on disk, and the in-memory copy shadows it."]
#[doc = "   Note that the original filename of the previous persistent storage (if any)"]
#[doc = "   is remembered. That means, when later persisting the profile again to disk,"]
#[doc = "   the file on disk will be overwritten again."]
#[doc = "   Likewise, when finally deleting the profile, both the storage from /run"]
#[doc = "   and persistent storage are deleted (or if the persistent storage does not"]
#[doc = "   allow deletion, and nmmeta file is written to mark the UUID as deleted)."]
#[doc = " @NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED: this is almost the same"]
#[doc = "   as %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY, with one difference: when later deleting"]
#[doc = "   the profile, the original profile will not be deleted. Instead a nmmeta"]
#[doc = "   file is written to /run to indicate that the profile is gone."]
#[doc = "   Note that if such a nmmeta tombstone file exists and hides a file in persistant"]
#[doc = "   storage, then when re-adding the profile with the same UUID, then the original"]
#[doc = "   storage is taken over again."]
#[doc = " @NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY: this is like %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY,"]
#[doc = "   but if the connection has a corresponding file on persistent storage, the file"]
#[doc = "   will be deleted right away. If the profile is later again persisted to disk,"]
#[doc = "   a new, unused filename will be chosen."]
#[doc = " @NM_SETTINGS_UPDATE2_FLAG_VOLATILE: This can be specified with either"]
#[doc = "   %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY, %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED"]
#[doc = "   or %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY."]
#[doc = "   After making the connection in-memory only, the connection is marked"]
#[doc = "   as volatile. That means, if the connection is currently not active"]
#[doc = "   it will be deleted right away. Otherwise, it is marked to for deletion"]
#[doc = "   once the connection deactivates. A volatile connection cannot autoactivate"]
#[doc = "   again (because it's about to be deleted), but a manual activation will"]
#[doc = "   clear the volatile flag."]
#[doc = " @NM_SETTINGS_UPDATE2_FLAG_BLOCK_AUTOCONNECT: usually, when the connection"]
#[doc = "   has autoconnect enabled and is modified, it becomes eligible to autoconnect"]
#[doc = "   right away. Setting this flag, disables autoconnect until the connection"]
#[doc = "   is manually activated."]
#[doc = " @NM_SETTINGS_UPDATE2_FLAG_NO_REAPPLY: when a profile gets modified that is"]
#[doc = "   currently active, then these changes don't take effect for the active"]
#[doc = "   device unless the profile gets reactivated or the configuration reapplied."]
#[doc = "   There are two exceptions: by default \"connection.zone\" and \"connection.metered\""]
#[doc = "   properties take effect immediately. Specify this flag to prevent these"]
#[doc = "   properties to take effect, so that the change is restricted to modify"]
#[doc = "   the profile. Since: 1.20."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type NMSettingsUpdate2Flags = ::std::os::raw::c_uint;
pub const NMTernary_NM_TERNARY_DEFAULT: NMTernary = -1;
pub const NMTernary_NM_TERNARY_FALSE: NMTernary = 0;
pub const NMTernary_NM_TERNARY_TRUE: NMTernary = 1;
#[doc = " NMTernary:"]
#[doc = " @NM_TERNARY_DEFAULT: use the globally-configured default value."]
#[doc = " @NM_TERNARY_FALSE: the option is disabled."]
#[doc = " @NM_TERNARY_TRUE: the option is enabled."]
#[doc = ""]
#[doc = " An boolean value that can be overridden by a default."]
#[doc = ""]
#[doc = " Since: 1.14"]
pub type NMTernary = ::std::os::raw::c_int;
pub const NMManagerReloadFlags_NM_MANAGER_RELOAD_FLAG_NONE: NMManagerReloadFlags = 0;
pub const NMManagerReloadFlags_NM_MANAGER_RELOAD_FLAG_CONF: NMManagerReloadFlags = 1;
pub const NMManagerReloadFlags_NM_MANAGER_RELOAD_FLAG_DNS_RC: NMManagerReloadFlags = 2;
pub const NMManagerReloadFlags_NM_MANAGER_RELOAD_FLAG_DNS_FULL: NMManagerReloadFlags = 4;
pub const NMManagerReloadFlags_NM_MANAGER_RELOAD_FLAG_ALL: NMManagerReloadFlags = 7;
#[doc = " NMManagerReloadFlags:"]
#[doc = " @NM_MANAGER_RELOAD_FLAG_NONE: an alias for numeric zero, no flags set. This"]
#[doc = "   reloads everything that is supported and is identical to a SIGHUP."]
#[doc = " @NM_MANAGER_RELOAD_FLAG_CONF: reload the NetworkManager.conf configuration"]
#[doc = "   from disk. Note that this does not include connections, which can be"]
#[doc = "   reloaded via Setting's ReloadConnections()."]
#[doc = " @NM_MANAGER_RELOAD_FLAG_DNS_RC: update DNS configuration, which usually"]
#[doc = "   involves writing /etc/resolv.conf anew."]
#[doc = " @NM_MANAGER_RELOAD_FLAG_DNS_FULL: means to restart the DNS plugin. This"]
#[doc = "   is for example useful when using dnsmasq plugin, which uses additional"]
#[doc = "   configuration in /etc/NetworkManager/dnsmasq.d. If you edit those files,"]
#[doc = "   you can restart the DNS plugin. This action shortly interrupts name"]
#[doc = "   resolution."]
#[doc = " @NM_MANAGER_RELOAD_FLAG_ALL: all flags."]
#[doc = ""]
#[doc = " Flags for the manager Reload() call."]
#[doc = ""]
#[doc = " Since: 1.22"]
pub type NMManagerReloadFlags = ::std::os::raw::c_uint;
pub const NMDeviceInterfaceFlags_NM_DEVICE_INTERFACE_FLAG_NONE: NMDeviceInterfaceFlags = 0;
pub const NMDeviceInterfaceFlags_NM_DEVICE_INTERFACE_FLAG_UP: NMDeviceInterfaceFlags = 1;
pub const NMDeviceInterfaceFlags_NM_DEVICE_INTERFACE_FLAG_LOWER_UP: NMDeviceInterfaceFlags = 2;
pub const NMDeviceInterfaceFlags_NM_DEVICE_INTERFACE_FLAG_CARRIER: NMDeviceInterfaceFlags = 65536;
#[doc = " NMDeviceInterfaceFlags:"]
#[doc = " @NM_DEVICE_INTERFACE_FLAG_NONE: an alias for numeric zero, no flags set."]
#[doc = " @NM_DEVICE_INTERFACE_FLAG_UP: the interface is enabled from the"]
#[doc = "   administrative point of view. Corresponds to kernel IFF_UP."]
#[doc = " @NM_DEVICE_INTERFACE_FLAG_LOWER_UP: the physical link is up. Corresponds"]
#[doc = "   to kernel IFF_LOWER_UP."]
#[doc = " @NM_DEVICE_INTERFACE_FLAG_CARRIER: the interface has carrier. In most"]
#[doc = "   cases this is equal to the value of @NM_DEVICE_INTERFACE_FLAG_LOWER_UP."]
#[doc = "   However some devices have a non-standard carrier detection mechanism."]
#[doc = ""]
#[doc = " Flags for a network interface."]
#[doc = ""]
#[doc = " Since: 1.22"]
pub type NMDeviceInterfaceFlags = ::std::os::raw::c_uint;
pub const NMClientPermission_NM_CLIENT_PERMISSION_NONE: NMClientPermission = 0;
pub const NMClientPermission_NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK: NMClientPermission = 1;
pub const NMClientPermission_NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI: NMClientPermission = 2;
pub const NMClientPermission_NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN: NMClientPermission = 3;
pub const NMClientPermission_NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX: NMClientPermission = 4;
pub const NMClientPermission_NM_CLIENT_PERMISSION_SLEEP_WAKE: NMClientPermission = 5;
pub const NMClientPermission_NM_CLIENT_PERMISSION_NETWORK_CONTROL: NMClientPermission = 6;
pub const NMClientPermission_NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED: NMClientPermission = 7;
pub const NMClientPermission_NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN: NMClientPermission = 8;
pub const NMClientPermission_NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM: NMClientPermission = 9;
pub const NMClientPermission_NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN: NMClientPermission = 10;
pub const NMClientPermission_NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME: NMClientPermission = 11;
pub const NMClientPermission_NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS: NMClientPermission =
    12;
pub const NMClientPermission_NM_CLIENT_PERMISSION_RELOAD: NMClientPermission = 13;
pub const NMClientPermission_NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK: NMClientPermission = 14;
pub const NMClientPermission_NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS: NMClientPermission =
    15;
pub const NMClientPermission_NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK:
    NMClientPermission = 16;
pub const NMClientPermission_NM_CLIENT_PERMISSION_WIFI_SCAN: NMClientPermission = 17;
pub const NMClientPermission_NM_CLIENT_PERMISSION_LAST: NMClientPermission = 17;
#[doc = " NMClientPermission:"]
#[doc = " @NM_CLIENT_PERMISSION_NONE: unknown or no permission"]
#[doc = " @NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK: controls whether networking"]
#[doc = "  can be globally enabled or disabled"]
#[doc = " @NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI: controls whether Wi-Fi can be"]
#[doc = "  globally enabled or disabled"]
#[doc = " @NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN: controls whether WWAN (3G) can be"]
#[doc = "  globally enabled or disabled"]
#[doc = " @NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX: controls whether WiMAX can be"]
#[doc = "  globally enabled or disabled"]
#[doc = " @NM_CLIENT_PERMISSION_SLEEP_WAKE: controls whether the client can ask"]
#[doc = "  NetworkManager to sleep and wake"]
#[doc = " @NM_CLIENT_PERMISSION_NETWORK_CONTROL: controls whether networking connections"]
#[doc = "  can be started, stopped, and changed"]
#[doc = " @NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED: controls whether a password"]
#[doc = "  protected Wi-Fi hotspot can be created"]
#[doc = " @NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN: controls whether an open Wi-Fi hotspot"]
#[doc = "  can be created"]
#[doc = " @NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM: controls whether connections"]
#[doc = "  that are available to all users can be modified"]
#[doc = " @NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN: controls whether connections"]
#[doc = "  owned by the current user can be modified"]
#[doc = " @NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME: controls whether the"]
#[doc = "  persistent hostname can be changed"]
#[doc = " @NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS: modify persistent global"]
#[doc = "  DNS configuration"]
#[doc = " @NM_CLIENT_PERMISSION_RELOAD: controls access to Reload."]
#[doc = " @NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK: permission to create checkpoints."]
#[doc = " @NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS: controls whether device"]
#[doc = "  statistics can be globally enabled or disabled"]
#[doc = " @NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK: controls whether"]
#[doc = "  connectivity check can be enabled or disabled"]
#[doc = " @NM_CLIENT_PERMISSION_WIFI_SCAN: controls whether wifi scans can be performed"]
#[doc = " @NM_CLIENT_PERMISSION_LAST: a reserved boundary value"]
#[doc = ""]
#[doc = " #NMClientPermission values indicate various permissions that NetworkManager"]
#[doc = " clients can obtain to perform certain tasks on behalf of the current user."]
pub type NMClientPermission = ::std::os::raw::c_uint;
pub const NMClientPermissionResult_NM_CLIENT_PERMISSION_RESULT_UNKNOWN: NMClientPermissionResult =
    0;
pub const NMClientPermissionResult_NM_CLIENT_PERMISSION_RESULT_YES: NMClientPermissionResult = 1;
pub const NMClientPermissionResult_NM_CLIENT_PERMISSION_RESULT_AUTH: NMClientPermissionResult = 2;
pub const NMClientPermissionResult_NM_CLIENT_PERMISSION_RESULT_NO: NMClientPermissionResult = 3;
#[doc = " NMClientPermissionResult:"]
#[doc = " @NM_CLIENT_PERMISSION_RESULT_UNKNOWN: unknown or no authorization"]
#[doc = " @NM_CLIENT_PERMISSION_RESULT_YES: the permission is available"]
#[doc = " @NM_CLIENT_PERMISSION_RESULT_AUTH: authorization is necessary before the"]
#[doc = "  permission is available"]
#[doc = " @NM_CLIENT_PERMISSION_RESULT_NO: permission to perform the operation is"]
#[doc = "  denied by system policy"]
#[doc = ""]
#[doc = " #NMClientPermissionResult values indicate what authorizations and permissions"]
#[doc = " the user requires to obtain a given #NMClientPermission"]
pub type NMClientPermissionResult = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_connection_serialization_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_capability_get_type() -> GType;
}
extern "C" {
    pub fn nm_state_get_type() -> GType;
}
extern "C" {
    pub fn nm_connectivity_state_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_type_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_capabilities_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_wifi_capabilities_get_type() -> GType;
}
extern "C" {
    pub fn nm_802_11_ap_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_802_11_ap_security_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_802_11_mode_get_type() -> GType;
}
extern "C" {
    pub fn nm_bluetooth_capabilities_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_modem_capabilities_get_type() -> GType;
}
extern "C" {
    pub fn nm_wimax_nsp_network_type_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_state_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_state_reason_get_type() -> GType;
}
extern "C" {
    pub fn nm_metered_get_type() -> GType;
}
extern "C" {
    pub fn nm_connection_multi_connect_get_type() -> GType;
}
extern "C" {
    pub fn nm_active_connection_state_get_type() -> GType;
}
extern "C" {
    pub fn nm_active_connection_state_reason_get_type() -> GType;
}
extern "C" {
    pub fn nm_secret_agent_get_secrets_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_secret_agent_capabilities_get_type() -> GType;
}
extern "C" {
    pub fn nm_ip_tunnel_mode_get_type() -> GType;
}
extern "C" {
    pub fn nm_checkpoint_create_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_settings_connection_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_activation_state_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_settings_add_connection2_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_settings_update2_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_ternary_get_type() -> GType;
}
extern "C" {
    pub fn nm_manager_reload_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_interface_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_client_permission_get_type() -> GType;
}
extern "C" {
    pub fn nm_client_permission_result_get_type() -> GType;
}
extern "C" {
    pub fn nm_agent_manager_error_get_type() -> GType;
}
extern "C" {
    pub fn nm_connection_error_get_type() -> GType;
}
extern "C" {
    pub fn nm_crypto_error_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_error_get_type() -> GType;
}
extern "C" {
    pub fn nm_manager_error_get_type() -> GType;
}
extern "C" {
    pub fn nm_secret_agent_error_get_type() -> GType;
}
extern "C" {
    pub fn nm_settings_error_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_plugin_error_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_802_1x_ck_format_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_802_1x_ck_scheme_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_802_1x_auth_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_connection_autoconnect_slaves_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_connection_lldp_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_connection_mdns_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_connection_llmnr_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_dcb_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_ip_address_cmp_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_ip_routing_rule_as_string_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_dhcp_hostname_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_ip_tunnel_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ip6_config_privacy_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ip6_config_addr_gen_mode_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_macsec_mode_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_macsec_validation_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_macvlan_mode_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_proxy_method_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_serial_parity_get_type() -> GType;
}
extern "C" {
    pub fn nm_sriov_vf_vlan_protocol_get_type() -> GType;
}
extern "C" {
    pub fn nm_team_link_watcher_arp_ping_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_tun_mode_get_type() -> GType;
}
extern "C" {
    pub fn nm_vlan_priority_map_get_type() -> GType;
}
extern "C" {
    pub fn nm_vlan_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wired_wake_on_lan_get_type() -> GType;
}
extern "C" {
    pub fn nm_wep_key_type_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wireless_security_pmf_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wireless_security_wps_method_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wireless_security_fils_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wireless_wake_on_wlan_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wireless_powersave_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_secret_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_compare_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_mac_randomization_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_diff_result_get_type() -> GType;
}
extern "C" {
    pub fn nm_utils_security_type_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_service_state_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_connection_state_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_connection_state_reason_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_plugin_failure_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_capability_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMConnection {
    _unused: [u8; 0],
}
pub type NMConnection = _NMConnection;
pub type NMSetting = _NMSetting;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSetting6Lowpan {
    _unused: [u8; 0],
}
pub type NMSetting6Lowpan = _NMSetting6Lowpan;
pub type NMSetting8021x = _NMSetting8021x;
pub type NMSettingAdsl = _NMSettingAdsl;
pub type NMSettingBluetooth = _NMSettingBluetooth;
pub type NMSettingBond = _NMSettingBond;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingBridge {
    _unused: [u8; 0],
}
pub type NMSettingBridge = _NMSettingBridge;
pub type NMSettingBridgePort = _NMSettingBridgePort;
pub type NMSettingCdma = _NMSettingCdma;
pub type NMSettingConnection = _NMSettingConnection;
pub type NMSettingDcb = _NMSettingDcb;
pub type NMSettingDummy = _NMSettingDummy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingEthtool {
    _unused: [u8; 0],
}
pub type NMSettingEthtool = _NMSettingEthtool;
pub type NMSettingGeneric = _NMSettingGeneric;
pub type NMSettingGsm = _NMSettingGsm;
pub type NMSettingIP4Config = _NMSettingIP4Config;
pub type NMSettingIP6Config = _NMSettingIP6Config;
pub type NMSettingIPConfig = _NMSettingIPConfig;
pub type NMSettingIPTunnel = _NMSettingIPTunnel;
pub type NMSettingInfiniband = _NMSettingInfiniband;
pub type NMSettingMacsec = _NMSettingMacsec;
pub type NMSettingMacvlan = _NMSettingMacvlan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingMatch {
    _unused: [u8; 0],
}
pub type NMSettingMatch = _NMSettingMatch;
pub type NMSettingOlpcMesh = _NMSettingOlpcMesh;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsBridge {
    _unused: [u8; 0],
}
pub type NMSettingOvsBridge = _NMSettingOvsBridge;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsDpdk {
    _unused: [u8; 0],
}
pub type NMSettingOvsDpdk = _NMSettingOvsDpdk;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsInterface {
    _unused: [u8; 0],
}
pub type NMSettingOvsInterface = _NMSettingOvsInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsPatch {
    _unused: [u8; 0],
}
pub type NMSettingOvsPatch = _NMSettingOvsPatch;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsPort {
    _unused: [u8; 0],
}
pub type NMSettingOvsPort = _NMSettingOvsPort;
pub type NMSettingPpp = _NMSettingPpp;
pub type NMSettingPppoe = _NMSettingPppoe;
pub type NMSettingProxy = _NMSettingProxy;
pub type NMSettingSerial = _NMSettingSerial;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingSriov {
    _unused: [u8; 0],
}
pub type NMSettingSriov = _NMSettingSriov;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingTCConfig {
    _unused: [u8; 0],
}
pub type NMSettingTCConfig = _NMSettingTCConfig;
pub type NMSettingTeam = _NMSettingTeam;
pub type NMSettingTeamPort = _NMSettingTeamPort;
pub type NMSettingTun = _NMSettingTun;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingUser {
    _unused: [u8; 0],
}
pub type NMSettingUser = _NMSettingUser;
pub type NMSettingVlan = _NMSettingVlan;
pub type NMSettingVpn = _NMSettingVpn;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingVrf {
    _unused: [u8; 0],
}
pub type NMSettingVrf = _NMSettingVrf;
pub type NMSettingVxlan = _NMSettingVxlan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWifiP2P {
    _unused: [u8; 0],
}
pub type NMSettingWifiP2P = _NMSettingWifiP2P;
pub type NMSettingWimax = _NMSettingWimax;
pub type NMSettingWired = _NMSettingWired;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWireGuard {
    _unused: [u8; 0],
}
pub type NMSettingWireGuard = _NMSettingWireGuard;
pub type NMSettingWireless = _NMSettingWireless;
pub type NMSettingWirelessSecurity = _NMSettingWirelessSecurity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWpan {
    _unused: [u8; 0],
}
pub type NMSettingWpan = _NMSettingWpan;
pub type NMSimpleConnection = _NMSimpleConnection;
pub type NMUtilsPredicateStr =
    ::std::option::Option<unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> gboolean>;
pub const NMSettingSecretFlags_NM_SETTING_SECRET_FLAG_NONE: NMSettingSecretFlags = 0;
pub const NMSettingSecretFlags_NM_SETTING_SECRET_FLAG_AGENT_OWNED: NMSettingSecretFlags = 1;
pub const NMSettingSecretFlags_NM_SETTING_SECRET_FLAG_NOT_SAVED: NMSettingSecretFlags = 2;
pub const NMSettingSecretFlags_NM_SETTING_SECRET_FLAG_NOT_REQUIRED: NMSettingSecretFlags = 4;
#[doc = " NMSettingSecretFlags:"]
#[doc = " @NM_SETTING_SECRET_FLAG_NONE: the system is responsible for providing and"]
#[doc = " storing this secret (default)"]
#[doc = " @NM_SETTING_SECRET_FLAG_AGENT_OWNED: a user secret agent is responsible"]
#[doc = " for providing and storing this secret; when it is required agents will be"]
#[doc = " asked to retrieve it"]
#[doc = " @NM_SETTING_SECRET_FLAG_NOT_SAVED: this secret should not be saved, but"]
#[doc = " should be requested from the user each time it is needed"]
#[doc = " @NM_SETTING_SECRET_FLAG_NOT_REQUIRED: in situations where it cannot be"]
#[doc = " automatically determined that the secret is required (some VPNs and PPP"]
#[doc = " providers don't require all secrets) this flag indicates that the specific"]
#[doc = " secret is not required"]
#[doc = ""]
#[doc = " These flags indicate specific behavior related to handling of a secret.  Each"]
#[doc = " secret has a corresponding set of these flags which indicate how the secret"]
#[doc = " is to be stored and/or requested when it is needed."]
#[doc = ""]
pub type NMSettingSecretFlags = ::std::os::raw::c_uint;
pub const NMSettingCompareFlags_NM_SETTING_COMPARE_FLAG_EXACT: NMSettingCompareFlags = 0;
pub const NMSettingCompareFlags_NM_SETTING_COMPARE_FLAG_FUZZY: NMSettingCompareFlags = 1;
pub const NMSettingCompareFlags_NM_SETTING_COMPARE_FLAG_IGNORE_ID: NMSettingCompareFlags = 2;
pub const NMSettingCompareFlags_NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS: NMSettingCompareFlags = 4;
pub const NMSettingCompareFlags_NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS:
    NMSettingCompareFlags = 8;
pub const NMSettingCompareFlags_NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS:
    NMSettingCompareFlags = 16;
pub const NMSettingCompareFlags_NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT:
    NMSettingCompareFlags = 32;
pub const NMSettingCompareFlags_NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT:
    NMSettingCompareFlags = 64;
pub const NMSettingCompareFlags_NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP: NMSettingCompareFlags =
    128;
#[doc = " NMSettingCompareFlags:"]
#[doc = " @NM_SETTING_COMPARE_FLAG_EXACT: match all properties exactly"]
#[doc = " @NM_SETTING_COMPARE_FLAG_FUZZY: match only important attributes, like SSID,"]
#[doc = "   type, security settings, etc.  Does not match, for example, connection ID"]
#[doc = "   or UUID."]
#[doc = " @NM_SETTING_COMPARE_FLAG_IGNORE_ID: ignore the connection's ID"]
#[doc = " @NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS: ignore all secrets"]
#[doc = " @NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS: ignore secrets for which"]
#[doc = "   the secret's flags indicate the secret is owned by a user secret agent"]
#[doc = "   (ie, the secret's flag includes @NM_SETTING_SECRET_FLAG_AGENT_OWNED)"]
#[doc = " @NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS: ignore secrets for which"]
#[doc = "   the secret's flags indicate the secret should not be saved to persistent"]
#[doc = "   storage (ie, the secret's flag includes @NM_SETTING_SECRET_FLAG_NOT_SAVED)"]
#[doc = " @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT: if this flag is set,"]
#[doc = "   nm_setting_diff() and nm_connection_diff() will also include properties that"]
#[doc = "   are set to their default value. See also @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT."]
#[doc = " @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT: if this flag is set,"]
#[doc = "   nm_setting_diff() and nm_connection_diff() will not include properties that"]
#[doc = "   are set to their default value. This is the opposite of"]
#[doc = "   @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT. If both flags are set together,"]
#[doc = "   @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT wins. If both flags are unset,"]
#[doc = "   this means to exclude default properties if there is a setting to compare,"]
#[doc = "   but include all properties, if the setting 'b' is missing. This is the legacy"]
#[doc = "   behaviour of libnm-util, where nm_setting_diff() behaved differently depending"]
#[doc = "   on whether the setting 'b' was available. If @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT"]
#[doc = "   is set, nm_setting_diff() will also set the flags @NM_SETTING_DIFF_RESULT_IN_A_DEFAULT"]
#[doc = "   and @NM_SETTING_DIFF_RESULT_IN_B_DEFAULT, if the values are default values."]
#[doc = " @NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP: ignore the connection's timestamp"]
#[doc = ""]
#[doc = " These flags modify the comparison behavior when comparing two settings or"]
#[doc = " two connections."]
#[doc = ""]
pub type NMSettingCompareFlags = ::std::os::raw::c_uint;
pub const NMSettingMacRandomization_NM_SETTING_MAC_RANDOMIZATION_DEFAULT:
    NMSettingMacRandomization = 0;
pub const NMSettingMacRandomization_NM_SETTING_MAC_RANDOMIZATION_NEVER: NMSettingMacRandomization =
    1;
pub const NMSettingMacRandomization_NM_SETTING_MAC_RANDOMIZATION_ALWAYS: NMSettingMacRandomization =
    2;
#[doc = " NMSettingMacRandomization:"]
#[doc = " @NM_SETTING_MAC_RANDOMIZATION_DEFAULT: the default value, which unless"]
#[doc = " overridden by user-controlled defaults configuration, is \"never\"."]
#[doc = " @NM_SETTING_MAC_RANDOMIZATION_NEVER: the device's MAC address is always used."]
#[doc = " @NM_SETTING_MAC_RANDOMIZATION_ALWAYS: a random MAC address is used."]
#[doc = ""]
#[doc = " Controls if and how the MAC address of a device is randomzied."]
pub type NMSettingMacRandomization = ::std::os::raw::c_uint;
#[doc = " NMSetting:"]
#[doc = ""]
#[doc = " The NMSetting struct contains only private data."]
#[doc = " It should only be accessed through the functions described below."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSetting {
    pub parent: GObject,
}
#[test]
fn bindgen_test_layout__NMSetting() {
    assert_eq!(
        ::std::mem::size_of::<_NMSetting>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSetting))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSetting>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSetting))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSetting>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSetting),
            "::",
            stringify!(parent)
        )
    );
}
#[doc = " NMSettingClearSecretsWithFlagsFn:"]
#[doc = " @setting: The setting for which secrets are being iterated"]
#[doc = " @secret: The secret's name"]
#[doc = " @flags: The secret's flags, eg %NM_SETTING_SECRET_FLAG_AGENT_OWNED"]
#[doc = " @user_data: User data passed to nm_connection_clear_secrets_with_flags()"]
#[doc = ""]
#[doc = " Returns: %TRUE to clear the secret, %FALSE to not clear the secret"]
pub type NMSettingClearSecretsWithFlagsFn = ::std::option::Option<
    unsafe extern "C" fn(
        setting: *mut NMSetting,
        secret: *const ::std::os::raw::c_char,
        flags: NMSettingSecretFlags,
        user_data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMMetaSettingInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettInfoSetting {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettInfoProperty {
    _unused: [u8; 0],
}
#[doc = " NMSettingValueIterFn:"]
#[doc = " @setting: The setting for which properties are being iterated, given to"]
#[doc = " nm_setting_enumerate_values()"]
#[doc = " @key: The value/property name"]
#[doc = " @value: The property's value"]
#[doc = " @flags: The property's flags, like %NM_SETTING_PARAM_SECRET"]
#[doc = " @user_data: User data passed to nm_setting_enumerate_values()"]
pub type NMSettingValueIterFn = ::std::option::Option<
    unsafe extern "C" fn(
        setting: *mut NMSetting,
        key: *const ::std::os::raw::c_char,
        value: *const GValue,
        flags: GParamFlags,
        user_data: gpointer,
    ),
>;
pub type _NMConnectionForEachSecretFunc = ::std::option::Option<
    unsafe extern "C" fn(flags: NMSettingSecretFlags, user_data: gpointer) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingClass {
    pub parent: GObjectClass,
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(
            setting: *mut NMSetting,
            connection: *mut NMConnection,
            error: *mut *mut GError,
        ) -> ::std::os::raw::c_int,
    >,
    pub verify_secrets: ::std::option::Option<
        unsafe extern "C" fn(
            setting: *mut NMSetting,
            connection: *mut NMConnection,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub need_secrets:
        ::std::option::Option<unsafe extern "C" fn(setting: *mut NMSetting) -> *mut GPtrArray>,
    pub update_one_secret: ::std::option::Option<
        unsafe extern "C" fn(
            setting: *mut NMSetting,
            key: *const ::std::os::raw::c_char,
            value: *mut GVariant,
            error: *mut *mut GError,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_secret_flags: ::std::option::Option<
        unsafe extern "C" fn(
            setting: *mut NMSetting,
            secret_name: *const ::std::os::raw::c_char,
            out_flags: *mut NMSettingSecretFlags,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_secret_flags: ::std::option::Option<
        unsafe extern "C" fn(
            setting: *mut NMSetting,
            secret_name: *const ::std::os::raw::c_char,
            flags: NMSettingSecretFlags,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub clear_secrets: ::std::option::Option<
        unsafe extern "C" fn(
            sett_info: *const _NMSettInfoSetting,
            property_idx: guint,
            setting: *mut NMSetting,
            func: NMSettingClearSecretsWithFlagsFn,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub compare_property: ::std::option::Option<
        unsafe extern "C" fn(
            sett_info: *const _NMSettInfoSetting,
            property_idx: guint,
            con_a: *mut NMConnection,
            set_a: *mut NMSetting,
            con_b: *mut NMConnection,
            set_b: *mut NMSetting,
            flags: NMSettingCompareFlags,
        ) -> NMTernary,
    >,
    pub duplicate_copy_properties: ::std::option::Option<
        unsafe extern "C" fn(
            sett_info: *const _NMSettInfoSetting,
            src: *mut NMSetting,
            dst: *mut NMSetting,
        ),
    >,
    pub enumerate_values: ::std::option::Option<
        unsafe extern "C" fn(
            property_info: *const _NMSettInfoProperty,
            setting: *mut NMSetting,
            func: NMSettingValueIterFn,
            user_data: gpointer,
        ),
    >,
    pub aggregate: ::std::option::Option<
        unsafe extern "C" fn(
            setting: *mut NMSetting,
            type_i: ::std::os::raw::c_int,
            arg: gpointer,
        ) -> gboolean,
    >,
    pub for_each_secret: ::std::option::Option<
        unsafe extern "C" fn(
            setting: *mut NMSetting,
            secret_name: *const ::std::os::raw::c_char,
            val: *mut GVariant,
            remove_non_secrets: gboolean,
            callback: _NMConnectionForEachSecretFunc,
            callback_data: gpointer,
            setting_builder: *mut GVariantBuilder,
        ),
    >,
    pub init_from_dbus: ::std::option::Option<
        unsafe extern "C" fn(
            setting: *mut NMSetting,
            keys: *mut GHashTable,
            setting_dict: *mut GVariant,
            connection_dict: *mut GVariant,
            parse_flags: guint,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 1usize],
    pub setting_info: *const _NMMetaSettingInfo,
}
#[test]
fn bindgen_test_layout_NMSettingClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingClass>(),
        256usize,
        concat!("Size of: ", stringify!(NMSettingClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).verify as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).verify_secrets as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(verify_secrets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).need_secrets as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(need_secrets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMSettingClass>())).update_one_secret as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(update_one_secret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).get_secret_flags as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(get_secret_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).set_secret_flags as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(set_secret_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).clear_secrets as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(clear_secrets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).compare_property as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(compare_property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMSettingClass>())).duplicate_copy_properties as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(duplicate_copy_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).enumerate_values as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(enumerate_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).aggregate as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(aggregate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).for_each_secret as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(for_each_secret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).init_from_dbus as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(init_from_dbus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).padding as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingClass>())).setting_info as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingClass),
            "::",
            stringify!(setting_info)
        )
    );
}
extern "C" {
    pub fn nm_setting_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_lookup_type(name: *const ::std::os::raw::c_char) -> GType;
}
extern "C" {
    pub fn nm_setting_duplicate(setting: *mut NMSetting) -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_get_name(setting: *mut NMSetting) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_verify(
        setting: *mut NMSetting,
        connection: *mut NMConnection,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_verify_secrets(
        setting: *mut NMSetting,
        connection: *mut NMConnection,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_compare(
        a: *mut NMSetting,
        b: *mut NMSetting,
        flags: NMSettingCompareFlags,
    ) -> gboolean;
}
pub const NMSettingDiffResult_NM_SETTING_DIFF_RESULT_UNKNOWN: NMSettingDiffResult = 0;
pub const NMSettingDiffResult_NM_SETTING_DIFF_RESULT_IN_A: NMSettingDiffResult = 1;
pub const NMSettingDiffResult_NM_SETTING_DIFF_RESULT_IN_B: NMSettingDiffResult = 2;
pub const NMSettingDiffResult_NM_SETTING_DIFF_RESULT_IN_A_DEFAULT: NMSettingDiffResult = 4;
pub const NMSettingDiffResult_NM_SETTING_DIFF_RESULT_IN_B_DEFAULT: NMSettingDiffResult = 8;
#[doc = " NMSettingDiffResult:"]
#[doc = " @NM_SETTING_DIFF_RESULT_UNKNOWN: unknown result"]
#[doc = " @NM_SETTING_DIFF_RESULT_IN_A: the property is present in setting A"]
#[doc = " @NM_SETTING_DIFF_RESULT_IN_B: the property is present in setting B"]
#[doc = " @NM_SETTING_DIFF_RESULT_IN_A_DEFAULT: the property is present in"]
#[doc = " setting A but is set to the default value. This flag is only set,"]
#[doc = " if you specify @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT."]
#[doc = " @NM_SETTING_DIFF_RESULT_IN_B_DEFAULT: analog to @NM_SETTING_DIFF_RESULT_IN_A_DEFAULT."]
#[doc = ""]
#[doc = " These values indicate the result of a setting difference operation."]
pub type NMSettingDiffResult = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_setting_diff(
        a: *mut NMSetting,
        b: *mut NMSetting,
        flags: NMSettingCompareFlags,
        invert_results: gboolean,
        results: *mut *mut GHashTable,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_enumerate_values(
        setting: *mut NMSetting,
        func: NMSettingValueIterFn,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_setting_to_string(setting: *mut NMSetting) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_get_secret_flags(
        setting: *mut NMSetting,
        secret_name: *const ::std::os::raw::c_char,
        out_flags: *mut NMSettingSecretFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_set_secret_flags(
        setting: *mut NMSetting,
        secret_name: *const ::std::os::raw::c_char,
        flags: NMSettingSecretFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_option_get(
        setting: *mut NMSetting,
        opt_name: *const ::std::os::raw::c_char,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_setting_option_get_boolean(
        setting: *mut NMSetting,
        opt_name: *const ::std::os::raw::c_char,
        out_value: *mut gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_option_get_uint32(
        setting: *mut NMSetting,
        opt_name: *const ::std::os::raw::c_char,
        out_value: *mut guint32,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_option_set(
        setting: *mut NMSetting,
        opt_name: *const ::std::os::raw::c_char,
        variant: *mut GVariant,
    );
}
extern "C" {
    pub fn nm_setting_option_set_uint32(
        setting: *mut NMSetting,
        opt_name: *const ::std::os::raw::c_char,
        value: guint32,
    );
}
extern "C" {
    pub fn nm_setting_option_set_boolean(
        setting: *mut NMSetting,
        opt_name: *const ::std::os::raw::c_char,
        value: gboolean,
    );
}
extern "C" {
    pub fn nm_setting_option_get_all_names(
        setting: *mut NMSetting,
        out_len: *mut guint,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_option_clear_by_name(setting: *mut NMSetting, predicate: NMUtilsPredicateStr);
}
extern "C" {
    pub fn nm_setting_get_dbus_property_type(
        setting: *mut NMSetting,
        property_name: *const ::std::os::raw::c_char,
    ) -> *const GVariantType;
}
pub const NMAgentManagerError_NM_AGENT_MANAGER_ERROR_FAILED: NMAgentManagerError = 0;
pub const NMAgentManagerError_NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED: NMAgentManagerError = 1;
pub const NMAgentManagerError_NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER: NMAgentManagerError = 2;
pub const NMAgentManagerError_NM_AGENT_MANAGER_ERROR_NOT_REGISTERED: NMAgentManagerError = 3;
pub const NMAgentManagerError_NM_AGENT_MANAGER_ERROR_NO_SECRETS: NMAgentManagerError = 4;
pub const NMAgentManagerError_NM_AGENT_MANAGER_ERROR_USER_CANCELED: NMAgentManagerError = 5;
#[doc = " NMAgentManagerError:"]
#[doc = " @NM_AGENT_MANAGER_ERROR_FAILED: unknown or unspecified error"]
#[doc = " @NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED: The caller does not have permission"]
#[doc = "   to register a secret agent, or is trying to register the same secret agent"]
#[doc = "   twice."]
#[doc = " @NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER: The identifier is not a valid"]
#[doc = "   secret agent identifier."]
#[doc = " @NM_AGENT_MANAGER_ERROR_NOT_REGISTERED: The caller tried to unregister an agent"]
#[doc = "   that was not registered."]
#[doc = " @NM_AGENT_MANAGER_ERROR_NO_SECRETS: No secret agent returned secrets for this"]
#[doc = "   request"]
#[doc = " @NM_AGENT_MANAGER_ERROR_USER_CANCELED: The user canceled the secrets request."]
#[doc = ""]
#[doc = " Errors returned from the secret-agent manager."]
#[doc = ""]
#[doc = " These errors may be returned from operations that could cause secrets to be"]
#[doc = " requested (such as nm_client_activate_connection()), and correspond to D-Bus"]
#[doc = " errors in the \"org.freedesktop.NetworkManager.AgentManager\" namespace."]
pub type NMAgentManagerError = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_agent_manager_error_quark() -> GQuark;
}
pub const NMConnectionError_NM_CONNECTION_ERROR_FAILED: NMConnectionError = 0;
pub const NMConnectionError_NM_CONNECTION_ERROR_SETTING_NOT_FOUND: NMConnectionError = 1;
pub const NMConnectionError_NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND: NMConnectionError = 2;
pub const NMConnectionError_NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET: NMConnectionError = 3;
pub const NMConnectionError_NM_CONNECTION_ERROR_MISSING_SETTING: NMConnectionError = 4;
pub const NMConnectionError_NM_CONNECTION_ERROR_INVALID_SETTING: NMConnectionError = 5;
pub const NMConnectionError_NM_CONNECTION_ERROR_MISSING_PROPERTY: NMConnectionError = 6;
pub const NMConnectionError_NM_CONNECTION_ERROR_INVALID_PROPERTY: NMConnectionError = 7;
#[doc = " NMConnectionError:"]
#[doc = " @NM_CONNECTION_ERROR_FAILED: unknown or unclassified error"]
#[doc = " @NM_CONNECTION_ERROR_SETTING_NOT_FOUND: the #NMConnection object"]
#[doc = "   did not contain the specified #NMSetting object"]
#[doc = " @NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND: the #NMConnection did not contain the"]
#[doc = "   requested #NMSetting property"]
#[doc = " @NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET: an operation which requires a secret"]
#[doc = "   was attempted on a non-secret property"]
#[doc = " @NM_CONNECTION_ERROR_MISSING_SETTING: the #NMConnection object is missing an"]
#[doc = "   #NMSetting which is required for its configuration. The error message will"]
#[doc = "   always be prefixed with \"&lt;setting-name>: \", where \"&lt;setting-name>\" is the"]
#[doc = "   name of the setting that is missing."]
#[doc = " @NM_CONNECTION_ERROR_INVALID_SETTING: the #NMConnection object contains an"]
#[doc = "   invalid or inappropriate #NMSetting. The error message will always be"]
#[doc = "   prefixed with \"&lt;setting-name>: \", where \"&lt;setting-name>\" is the name of the"]
#[doc = "   setting that is invalid."]
#[doc = " @NM_CONNECTION_ERROR_MISSING_PROPERTY: the #NMConnection object is invalid"]
#[doc = "   because it is missing a required property. The error message will always be"]
#[doc = "   prefixed with \"&lt;setting-name>.&lt;property-name>: \", where \"&lt;setting-name>\" is"]
#[doc = "   the name of the setting with the missing property, and \"&lt;property-name>\" is"]
#[doc = "   the property that is missing."]
#[doc = " @NM_CONNECTION_ERROR_INVALID_PROPERTY: the #NMConnection object is invalid"]
#[doc = "   because a property has an invalid value. The error message will always be"]
#[doc = "   prefixed with \"&lt;setting-name>.&lt;property-name>: \", where \"&lt;setting-name>\" is"]
#[doc = "   the name of the setting with the invalid property, and \"&lt;property-name>\" is"]
#[doc = "   the property that is invalid."]
#[doc = ""]
#[doc = " Describes errors that may result from operations involving a #NMConnection"]
#[doc = " or its #NMSettings."]
#[doc = ""]
#[doc = " These errors may be returned directly from #NMConnection and #NMSetting"]
#[doc = " methods, or may be returned from D-Bus operations (eg on #NMClient or"]
#[doc = " #NMDevice), where they correspond to errors in the"]
#[doc = " \"org.freedesktop.NetworkManager.Settings.Connection\" namespace."]
pub type NMConnectionError = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_connection_error_quark() -> GQuark;
}
pub const NMCryptoError_NM_CRYPTO_ERROR_FAILED: NMCryptoError = 0;
pub const NMCryptoError_NM_CRYPTO_ERROR_INVALID_DATA: NMCryptoError = 1;
pub const NMCryptoError_NM_CRYPTO_ERROR_INVALID_PASSWORD: NMCryptoError = 2;
pub const NMCryptoError_NM_CRYPTO_ERROR_UNKNOWN_CIPHER: NMCryptoError = 3;
pub const NMCryptoError_NM_CRYPTO_ERROR_DECRYPTION_FAILED: NMCryptoError = 4;
pub const NMCryptoError_NM_CRYPTO_ERROR_ENCRYPTION_FAILED: NMCryptoError = 5;
#[doc = " NMCryptoError:"]
#[doc = " @NM_CRYPTO_ERROR_FAILED: generic failure"]
#[doc = " @NM_CRYPTO_ERROR_INVALID_DATA: the certificate or key data provided"]
#[doc = "   was invalid"]
#[doc = " @NM_CRYPTO_ERROR_INVALID_PASSWORD: the password was invalid"]
#[doc = " @NM_CRYPTO_ERROR_UNKNOWN_CIPHER: the data uses an unknown cipher"]
#[doc = " @NM_CRYPTO_ERROR_DECRYPTION_FAILED: decryption failed"]
#[doc = " @NM_CRYPTO_ERROR_ENCRYPTION_FAILED: encryption failed"]
#[doc = ""]
#[doc = " Cryptography-related errors that can be returned from some nm-utils methods,"]
#[doc = " and some #NMSetting8021x operations."]
pub type NMCryptoError = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_crypto_error_quark() -> GQuark;
}
pub const NMDeviceError_NM_DEVICE_ERROR_FAILED: NMDeviceError = 0;
pub const NMDeviceError_NM_DEVICE_ERROR_CREATION_FAILED: NMDeviceError = 1;
pub const NMDeviceError_NM_DEVICE_ERROR_INVALID_CONNECTION: NMDeviceError = 2;
pub const NMDeviceError_NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION: NMDeviceError = 3;
pub const NMDeviceError_NM_DEVICE_ERROR_NOT_ACTIVE: NMDeviceError = 4;
pub const NMDeviceError_NM_DEVICE_ERROR_NOT_SOFTWARE: NMDeviceError = 5;
pub const NMDeviceError_NM_DEVICE_ERROR_NOT_ALLOWED: NMDeviceError = 6;
pub const NMDeviceError_NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND: NMDeviceError = 7;
pub const NMDeviceError_NM_DEVICE_ERROR_VERSION_ID_MISMATCH: NMDeviceError = 8;
pub const NMDeviceError_NM_DEVICE_ERROR_MISSING_DEPENDENCIES: NMDeviceError = 9;
pub const NMDeviceError_NM_DEVICE_ERROR_INVALID_ARGUMENT: NMDeviceError = 10;
#[doc = " NMDeviceError:"]
#[doc = " @NM_DEVICE_ERROR_FAILED: unknown or unclassified error"]
#[doc = " @NM_DEVICE_ERROR_CREATION_FAILED: NetworkManager failed to create the device"]
#[doc = " @NM_DEVICE_ERROR_INVALID_CONNECTION: the specified connection is not valid"]
#[doc = " @NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION: the specified connection is not"]
#[doc = "   compatible with this device."]
#[doc = " @NM_DEVICE_ERROR_NOT_ACTIVE: the device does not have an active connection"]
#[doc = " @NM_DEVICE_ERROR_NOT_SOFTWARE: the requested operation is only valid on"]
#[doc = "   software devices."]
#[doc = " @NM_DEVICE_ERROR_NOT_ALLOWED: the requested operation is not allowed at"]
#[doc = "   this time."]
#[doc = " @NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND: the \"specific object\" in the"]
#[doc = "   activation request (eg, the #NMAccessPoint or #NMWimaxNsp) was not"]
#[doc = "   found."]
#[doc = " @NM_DEVICE_ERROR_VERSION_ID_MISMATCH: the version id did not match."]
#[doc = " @NM_DEVICE_ERROR_MISSING_DEPENDENCIES: the requested operation could not"]
#[doc = "   be completed due to missing dependencies."]
#[doc = " @NM_DEVICE_ERROR_INVALID_ARGUMENT: invalid argument. Since: 1.16"]
#[doc = ""]
#[doc = " Device-related errors."]
#[doc = ""]
#[doc = " These errors may be returned directly from #NMDevice methods, or may be"]
#[doc = " returned from D-Bus operations (where they correspond to errors in the"]
#[doc = " \"org.freedesktop.NetworkManager.Device\" namespace)."]
pub type NMDeviceError = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_device_error_quark() -> GQuark;
}
pub const NMManagerError_NM_MANAGER_ERROR_FAILED: NMManagerError = 0;
pub const NMManagerError_NM_MANAGER_ERROR_PERMISSION_DENIED: NMManagerError = 1;
pub const NMManagerError_NM_MANAGER_ERROR_UNKNOWN_CONNECTION: NMManagerError = 2;
pub const NMManagerError_NM_MANAGER_ERROR_UNKNOWN_DEVICE: NMManagerError = 3;
pub const NMManagerError_NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE: NMManagerError = 4;
pub const NMManagerError_NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE: NMManagerError = 5;
pub const NMManagerError_NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE: NMManagerError = 6;
pub const NMManagerError_NM_MANAGER_ERROR_DEPENDENCY_FAILED: NMManagerError = 7;
pub const NMManagerError_NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE: NMManagerError = 8;
pub const NMManagerError_NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED: NMManagerError = 9;
pub const NMManagerError_NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL: NMManagerError = 10;
pub const NMManagerError_NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN: NMManagerError = 11;
pub const NMManagerError_NM_MANAGER_ERROR_INVALID_ARGUMENTS: NMManagerError = 12;
pub const NMManagerError_NM_MANAGER_ERROR_MISSING_PLUGIN: NMManagerError = 13;
#[doc = " NMManagerError:"]
#[doc = " @NM_MANAGER_ERROR_FAILED: unknown or unclassified error"]
#[doc = " @NM_MANAGER_ERROR_PERMISSION_DENIED: Permission denied."]
#[doc = " @NM_MANAGER_ERROR_UNKNOWN_CONNECTION: The requested connection is not known."]
#[doc = " @NM_MANAGER_ERROR_UNKNOWN_DEVICE: The requested device is not known."]
#[doc = " @NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE: The requested connection cannot be"]
#[doc = "   activated at this time."]
#[doc = " @NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE: The request could not be completed"]
#[doc = "   because a required connection is not active."]
#[doc = " @NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE: The connection to be activated was"]
#[doc = "   already active on another device."]
#[doc = " @NM_MANAGER_ERROR_DEPENDENCY_FAILED: An activation request failed due to a"]
#[doc = "   dependency being unavailable."]
#[doc = " @NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE: The manager is already in the requested"]
#[doc = "   sleep/wake state."]
#[doc = " @NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED: The network is already"]
#[doc = "   enabled/disabled."]
#[doc = " @NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL: Unknown log level in SetLogging"]
#[doc = " @NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN: Unknown log domain in SetLogging"]
#[doc = " @NM_MANAGER_ERROR_INVALID_ARGUMENTS: Invalid arguments for D-Bus request"]
#[doc = " @NM_MANAGER_ERROR_MISSING_PLUGIN: A plug-in was needed to complete the"]
#[doc = "   activation but is not available."]
#[doc = ""]
#[doc = " Errors related to the main \"network management\" interface of NetworkManager."]
#[doc = " These may be returned from #NMClient methods that invoke D-Bus operations on"]
#[doc = " the \"org.freedesktop.NetworkManager\" interface, and correspond to D-Bus"]
#[doc = " errors in that namespace."]
pub type NMManagerError = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_manager_error_quark() -> GQuark;
}
pub const NMSecretAgentError_NM_SECRET_AGENT_ERROR_FAILED: NMSecretAgentError = 0;
pub const NMSecretAgentError_NM_SECRET_AGENT_ERROR_PERMISSION_DENIED: NMSecretAgentError = 1;
pub const NMSecretAgentError_NM_SECRET_AGENT_ERROR_INVALID_CONNECTION: NMSecretAgentError = 2;
pub const NMSecretAgentError_NM_SECRET_AGENT_ERROR_USER_CANCELED: NMSecretAgentError = 3;
pub const NMSecretAgentError_NM_SECRET_AGENT_ERROR_AGENT_CANCELED: NMSecretAgentError = 4;
pub const NMSecretAgentError_NM_SECRET_AGENT_ERROR_NO_SECRETS: NMSecretAgentError = 5;
#[doc = " NMSecretAgentError:"]
#[doc = " @NM_SECRET_AGENT_ERROR_FAILED: unknown or unclassified error"]
#[doc = " @NM_SECRET_AGENT_ERROR_PERMISSION_DENIED: the caller (ie, NetworkManager) is"]
#[doc = "   not authorized to make this request"]
#[doc = " @NM_SECRET_AGENT_ERROR_INVALID_CONNECTION: the connection for which secrets"]
#[doc = "   were requested is invalid"]
#[doc = " @NM_SECRET_AGENT_ERROR_USER_CANCELED: the request was canceled by the user"]
#[doc = " @NM_SECRET_AGENT_ERROR_AGENT_CANCELED: the agent canceled the request"]
#[doc = "   because it was requested to do so by NetworkManager"]
#[doc = " @NM_SECRET_AGENT_ERROR_NO_SECRETS: the agent cannot find any secrets for this"]
#[doc = "   connection"]
#[doc = ""]
#[doc = " #NMSecretAgentError values are passed by secret agents back to NetworkManager"]
#[doc = " when they encounter problems retrieving secrets on behalf of NM. They"]
#[doc = " correspond to errors in the \"org.freedesktop.NetworkManager.SecretManager\""]
#[doc = " namespace."]
#[doc = ""]
#[doc = " Client APIs such as nm_client_activate_connection() will not see these error"]
#[doc = " codes; instead, the secret agent manager will translate them to the"]
#[doc = " corresponding #NMAgentManagerError codes."]
pub type NMSecretAgentError = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_secret_agent_error_quark() -> GQuark;
}
pub const NMSettingsError_NM_SETTINGS_ERROR_FAILED: NMSettingsError = 0;
pub const NMSettingsError_NM_SETTINGS_ERROR_PERMISSION_DENIED: NMSettingsError = 1;
pub const NMSettingsError_NM_SETTINGS_ERROR_NOT_SUPPORTED: NMSettingsError = 2;
pub const NMSettingsError_NM_SETTINGS_ERROR_INVALID_CONNECTION: NMSettingsError = 3;
pub const NMSettingsError_NM_SETTINGS_ERROR_READ_ONLY_CONNECTION: NMSettingsError = 4;
pub const NMSettingsError_NM_SETTINGS_ERROR_UUID_EXISTS: NMSettingsError = 5;
pub const NMSettingsError_NM_SETTINGS_ERROR_INVALID_HOSTNAME: NMSettingsError = 6;
pub const NMSettingsError_NM_SETTINGS_ERROR_INVALID_ARGUMENTS: NMSettingsError = 7;
#[doc = " NMSettingsError:"]
#[doc = " @NM_SETTINGS_ERROR_FAILED: unknown or unclassified error"]
#[doc = " @NM_SETTINGS_ERROR_PERMISSION_DENIED: permission denied"]
#[doc = " @NM_SETTINGS_ERROR_NOT_SUPPORTED: the requested operation is not supported by any"]
#[doc = "   active settings backend"]
#[doc = " @NM_SETTINGS_ERROR_INVALID_CONNECTION: the connection was invalid"]
#[doc = " @NM_SETTINGS_ERROR_READ_ONLY_CONNECTION: attempted to modify a read-only connection"]
#[doc = " @NM_SETTINGS_ERROR_UUID_EXISTS: a connection with that UUID already exists"]
#[doc = " @NM_SETTINGS_ERROR_INVALID_HOSTNAME: attempted to set an invalid hostname"]
#[doc = " @NM_SETTINGS_ERROR_INVALID_ARGUMENTS: invalid arguments"]
#[doc = ""]
#[doc = " Errors related to the settings/persistent configuration interface of"]
#[doc = " NetworkManager."]
#[doc = ""]
#[doc = " These may be returned from #NMClient methods that invoke D-Bus operations on"]
#[doc = " the \"org.freedesktop.NetworkManager.Settings\" interface, and correspond to"]
#[doc = " D-Bus errors in that namespace."]
pub type NMSettingsError = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_settings_error_quark() -> GQuark;
}
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_FAILED: NMVpnPluginError = 0;
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS: NMVpnPluginError = 1;
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_ALREADY_STARTED: NMVpnPluginError = 2;
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS: NMVpnPluginError = 3;
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED: NMVpnPluginError = 4;
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_WRONG_STATE: NMVpnPluginError = 5;
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS: NMVpnPluginError = 6;
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED: NMVpnPluginError = 7;
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION: NMVpnPluginError = 8;
pub const NMVpnPluginError_NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED: NMVpnPluginError = 9;
#[doc = " NMVpnPluginError:"]
#[doc = " @NM_VPN_PLUGIN_ERROR_FAILED: unknown or unclassified error"]
#[doc = " @NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS: the plugin is already starting,"]
#[doc = "   and another connect request was received"]
#[doc = " @NM_VPN_PLUGIN_ERROR_ALREADY_STARTED: the plugin is already connected, and"]
#[doc = "   another connect request was received"]
#[doc = " @NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS: the plugin is already stopping,"]
#[doc = "   and another stop request was received"]
#[doc = " @NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED: the plugin is already stopped, and"]
#[doc = "   another disconnect request was received"]
#[doc = " @NM_VPN_PLUGIN_ERROR_WRONG_STATE: the operation could not be performed in"]
#[doc = "   this state"]
#[doc = " @NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS: the operation could not be performed as"]
#[doc = "   the request contained malformed arguments, or arguments of unexpected type."]
#[doc = "   Usually means that one of the VPN setting data items or secrets was not of"]
#[doc = "   the expected type (ie int, string, bool, etc)."]
#[doc = " @NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED: a child process failed to launch"]
#[doc = " @NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION: the operation could not be performed"]
#[doc = "   because the connection was invalid.  Usually means that the connection's"]
#[doc = "   VPN setting was missing some required data item or secret."]
#[doc = " @NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED: the operation could not be"]
#[doc = "   performed as the plugin does not support interactive operations, such as"]
#[doc = "   ConnectInteractive() or NewSecrets()"]
#[doc = ""]
#[doc = " Returned by the VPN service plugin to indicate errors. These codes correspond"]
#[doc = " to errors in the \"org.freedesktop.NetworkManager.VPN.Error\" namespace."]
pub type NMVpnPluginError = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_vpn_plugin_error_quark() -> GQuark;
}
#[doc = " NMConnectionInterface:"]
#[doc = " @parent: the parent interface struct"]
#[doc = " @secrets_updated: emitted when the connection's secrets are updated"]
#[doc = " @secrets_cleared: emitted when the connection's secrets are cleared"]
#[doc = " @changed: emitted when any change to the connection's settings occurs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMConnectionInterface {
    pub parent: GTypeInterface,
    pub secrets_updated: ::std::option::Option<
        unsafe extern "C" fn(connection: *mut NMConnection, setting: *const ::std::os::raw::c_char),
    >,
    pub secrets_cleared: ::std::option::Option<unsafe extern "C" fn(connection: *mut NMConnection)>,
    pub changed: ::std::option::Option<unsafe extern "C" fn(connection: *mut NMConnection)>,
}
#[test]
fn bindgen_test_layout_NMConnectionInterface() {
    assert_eq!(
        ::std::mem::size_of::<NMConnectionInterface>(),
        40usize,
        concat!("Size of: ", stringify!(NMConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<NMConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(NMConnectionInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMConnectionInterface>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMConnectionInterface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMConnectionInterface>())).secrets_updated as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NMConnectionInterface),
            "::",
            stringify!(secrets_updated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMConnectionInterface>())).secrets_cleared as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NMConnectionInterface),
            "::",
            stringify!(secrets_cleared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMConnectionInterface>())).changed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NMConnectionInterface),
            "::",
            stringify!(changed)
        )
    );
}
extern "C" {
    pub fn nm_connection_get_type() -> GType;
}
extern "C" {
    pub fn nm_connection_add_setting(connection: *mut NMConnection, setting: *mut NMSetting);
}
extern "C" {
    pub fn nm_connection_remove_setting(connection: *mut NMConnection, setting_type: GType);
}
extern "C" {
    pub fn nm_connection_get_setting(
        connection: *mut NMConnection,
        setting_type: GType,
    ) -> *mut NMSetting;
}
extern "C" {
    pub fn nm_connection_get_setting_by_name(
        connection: *mut NMConnection,
        name: *const ::std::os::raw::c_char,
    ) -> *mut NMSetting;
}
pub const NMConnectionSerializationFlags_NM_CONNECTION_SERIALIZE_ALL:
    NMConnectionSerializationFlags = 0;
pub const NMConnectionSerializationFlags_NM_CONNECTION_SERIALIZE_NO_SECRETS:
    NMConnectionSerializationFlags = 1;
pub const NMConnectionSerializationFlags_NM_CONNECTION_SERIALIZE_ONLY_SECRETS:
    NMConnectionSerializationFlags = 2;
pub const NMConnectionSerializationFlags_NM_CONNECTION_SERIALIZE_WITH_SECRETS_AGENT_OWNED:
    NMConnectionSerializationFlags = 4;
#[doc = " NMConnectionSerializationFlags:"]
#[doc = " @NM_CONNECTION_SERIALIZE_ALL: serialize all properties (including secrets)"]
#[doc = " @NM_CONNECTION_SERIALIZE_NO_SECRETS: do not include secrets"]
#[doc = " @NM_CONNECTION_SERIALIZE_ONLY_SECRETS: only serialize secrets"]
#[doc = " @NM_CONNECTION_SERIALIZE_WITH_SECRETS_AGENT_OWNED: if set, only secrets that"]
#[doc = "   are agent owned will be serialized. Since: 1.20"]
#[doc = ""]
#[doc = " These flags determine which properties are serialized when calling when"]
#[doc = " calling nm_connection_to_dbus()."]
pub type NMConnectionSerializationFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_connection_to_dbus(
        connection: *mut NMConnection,
        flags: NMConnectionSerializationFlags,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_connection_replace_settings(
        connection: *mut NMConnection,
        new_settings: *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_connection_replace_settings_from_connection(
        connection: *mut NMConnection,
        new_connection: *mut NMConnection,
    );
}
extern "C" {
    pub fn nm_connection_clear_settings(connection: *mut NMConnection);
}
extern "C" {
    pub fn nm_connection_compare(
        a: *mut NMConnection,
        b: *mut NMConnection,
        flags: NMSettingCompareFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_connection_diff(
        a: *mut NMConnection,
        b: *mut NMConnection,
        flags: NMSettingCompareFlags,
        out_settings: *mut *mut GHashTable,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_connection_verify(connection: *mut NMConnection, error: *mut *mut GError)
        -> gboolean;
}
extern "C" {
    pub fn nm_connection_verify_secrets(
        connection: *mut NMConnection,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_connection_normalize(
        connection: *mut NMConnection,
        parameters: *mut GHashTable,
        modified: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_connection_need_secrets(
        connection: *mut NMConnection,
        hints: *mut *mut GPtrArray,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_connection_clear_secrets(connection: *mut NMConnection);
}
extern "C" {
    pub fn nm_connection_clear_secrets_with_flags(
        connection: *mut NMConnection,
        func: NMSettingClearSecretsWithFlagsFn,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_connection_update_secrets(
        connection: *mut NMConnection,
        setting_name: *const ::std::os::raw::c_char,
        secrets: *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_connection_set_path(
        connection: *mut NMConnection,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_connection_get_path(connection: *mut NMConnection) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_connection_get_interface_name(
        connection: *mut NMConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_connection_is_type(
        connection: *mut NMConnection,
        type_: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_connection_for_each_setting_value(
        connection: *mut NMConnection,
        func: NMSettingValueIterFn,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_connection_get_settings(
        connection: *mut NMConnection,
        out_length: *mut guint,
    ) -> *mut *mut NMSetting;
}
extern "C" {
    pub fn nm_connection_dump(connection: *mut NMConnection);
}
extern "C" {
    pub fn nm_connection_get_uuid(connection: *mut NMConnection) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_connection_get_id(connection: *mut NMConnection) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_connection_get_connection_type(
        connection: *mut NMConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_connection_is_virtual(connection: *mut NMConnection) -> gboolean;
}
extern "C" {
    pub fn nm_connection_get_virtual_device_description(
        connection: *mut NMConnection,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_connection_get_setting_802_1x(connection: *mut NMConnection) -> *mut NMSetting8021x;
}
extern "C" {
    pub fn nm_connection_get_setting_bluetooth(
        connection: *mut NMConnection,
    ) -> *mut NMSettingBluetooth;
}
extern "C" {
    pub fn nm_connection_get_setting_bond(connection: *mut NMConnection) -> *mut NMSettingBond;
}
extern "C" {
    pub fn nm_connection_get_setting_team(connection: *mut NMConnection) -> *mut NMSettingTeam;
}
extern "C" {
    pub fn nm_connection_get_setting_team_port(
        connection: *mut NMConnection,
    ) -> *mut NMSettingTeamPort;
}
extern "C" {
    pub fn nm_connection_get_setting_bridge(connection: *mut NMConnection) -> *mut NMSettingBridge;
}
extern "C" {
    pub fn nm_connection_get_setting_bridge_port(
        connection: *mut NMConnection,
    ) -> *mut NMSettingBridgePort;
}
extern "C" {
    pub fn nm_connection_get_setting_cdma(connection: *mut NMConnection) -> *mut NMSettingCdma;
}
extern "C" {
    pub fn nm_connection_get_setting_connection(
        connection: *mut NMConnection,
    ) -> *mut NMSettingConnection;
}
extern "C" {
    pub fn nm_connection_get_setting_dcb(connection: *mut NMConnection) -> *mut NMSettingDcb;
}
extern "C" {
    pub fn nm_connection_get_setting_dummy(connection: *mut NMConnection) -> *mut NMSettingDummy;
}
extern "C" {
    pub fn nm_connection_get_setting_generic(
        connection: *mut NMConnection,
    ) -> *mut NMSettingGeneric;
}
extern "C" {
    pub fn nm_connection_get_setting_gsm(connection: *mut NMConnection) -> *mut NMSettingGsm;
}
extern "C" {
    pub fn nm_connection_get_setting_infiniband(
        connection: *mut NMConnection,
    ) -> *mut NMSettingInfiniband;
}
extern "C" {
    pub fn nm_connection_get_setting_ip_tunnel(
        connection: *mut NMConnection,
    ) -> *mut NMSettingIPTunnel;
}
extern "C" {
    pub fn nm_connection_get_setting_ip4_config(
        connection: *mut NMConnection,
    ) -> *mut NMSettingIPConfig;
}
extern "C" {
    pub fn nm_connection_get_setting_ip6_config(
        connection: *mut NMConnection,
    ) -> *mut NMSettingIPConfig;
}
extern "C" {
    pub fn nm_connection_get_setting_macsec(connection: *mut NMConnection) -> *mut NMSettingMacsec;
}
extern "C" {
    pub fn nm_connection_get_setting_macvlan(
        connection: *mut NMConnection,
    ) -> *mut NMSettingMacvlan;
}
extern "C" {
    pub fn nm_connection_get_setting_olpc_mesh(
        connection: *mut NMConnection,
    ) -> *mut NMSettingOlpcMesh;
}
extern "C" {
    pub fn nm_connection_get_setting_ovs_bridge(
        connection: *mut NMConnection,
    ) -> *mut NMSettingOvsBridge;
}
extern "C" {
    pub fn nm_connection_get_setting_ovs_interface(
        connection: *mut NMConnection,
    ) -> *mut NMSettingOvsInterface;
}
extern "C" {
    pub fn nm_connection_get_setting_ovs_patch(
        connection: *mut NMConnection,
    ) -> *mut NMSettingOvsPatch;
}
extern "C" {
    pub fn nm_connection_get_setting_ovs_port(
        connection: *mut NMConnection,
    ) -> *mut NMSettingOvsPort;
}
extern "C" {
    pub fn nm_connection_get_setting_ppp(connection: *mut NMConnection) -> *mut NMSettingPpp;
}
extern "C" {
    pub fn nm_connection_get_setting_pppoe(connection: *mut NMConnection) -> *mut NMSettingPppoe;
}
extern "C" {
    pub fn nm_connection_get_setting_proxy(connection: *mut NMConnection) -> *mut NMSettingProxy;
}
extern "C" {
    pub fn nm_connection_get_setting_serial(connection: *mut NMConnection) -> *mut NMSettingSerial;
}
extern "C" {
    pub fn nm_connection_get_setting_tc_config(
        connection: *mut NMConnection,
    ) -> *mut NMSettingTCConfig;
}
extern "C" {
    pub fn nm_connection_get_setting_tun(connection: *mut NMConnection) -> *mut NMSettingTun;
}
extern "C" {
    pub fn nm_connection_get_setting_vpn(connection: *mut NMConnection) -> *mut NMSettingVpn;
}
extern "C" {
    pub fn nm_connection_get_setting_wimax(connection: *mut NMConnection) -> *mut NMSettingWimax;
}
extern "C" {
    pub fn nm_connection_get_setting_adsl(connection: *mut NMConnection) -> *mut NMSettingAdsl;
}
extern "C" {
    pub fn nm_connection_get_setting_wired(connection: *mut NMConnection) -> *mut NMSettingWired;
}
extern "C" {
    pub fn nm_connection_get_setting_wireless(
        connection: *mut NMConnection,
    ) -> *mut NMSettingWireless;
}
extern "C" {
    pub fn nm_connection_get_setting_wireless_security(
        connection: *mut NMConnection,
    ) -> *mut NMSettingWirelessSecurity;
}
extern "C" {
    pub fn nm_connection_get_setting_vlan(connection: *mut NMConnection) -> *mut NMSettingVlan;
}
extern "C" {
    pub fn nm_connection_get_setting_vxlan(connection: *mut NMConnection) -> *mut NMSettingVxlan;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMAccessPoint {
    _unused: [u8; 0],
}
pub type NMAccessPoint = _NMAccessPoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMActiveConnection {
    _unused: [u8; 0],
}
pub type NMActiveConnection = _NMActiveConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMCheckpoint {
    _unused: [u8; 0],
}
pub type NMCheckpoint = _NMCheckpoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMClient {
    _unused: [u8; 0],
}
pub type NMClient = _NMClient;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDevice {
    _unused: [u8; 0],
}
pub type NMDevice = _NMDevice;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDevice6Lowpan {
    _unused: [u8; 0],
}
pub type NMDevice6Lowpan = _NMDevice6Lowpan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceAdsl {
    _unused: [u8; 0],
}
pub type NMDeviceAdsl = _NMDeviceAdsl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceBond {
    _unused: [u8; 0],
}
pub type NMDeviceBond = _NMDeviceBond;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceBridge {
    _unused: [u8; 0],
}
pub type NMDeviceBridge = _NMDeviceBridge;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceBt {
    _unused: [u8; 0],
}
pub type NMDeviceBt = _NMDeviceBt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceDummy {
    _unused: [u8; 0],
}
pub type NMDeviceDummy = _NMDeviceDummy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceEthernet {
    _unused: [u8; 0],
}
pub type NMDeviceEthernet = _NMDeviceEthernet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceGeneric {
    _unused: [u8; 0],
}
pub type NMDeviceGeneric = _NMDeviceGeneric;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceIPTunnel {
    _unused: [u8; 0],
}
pub type NMDeviceIPTunnel = _NMDeviceIPTunnel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceInfiniband {
    _unused: [u8; 0],
}
pub type NMDeviceInfiniband = _NMDeviceInfiniband;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceMacsec {
    _unused: [u8; 0],
}
pub type NMDeviceMacsec = _NMDeviceMacsec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceMacvlan {
    _unused: [u8; 0],
}
pub type NMDeviceMacvlan = _NMDeviceMacvlan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceModem {
    _unused: [u8; 0],
}
pub type NMDeviceModem = _NMDeviceModem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceOlpcMesh {
    _unused: [u8; 0],
}
pub type NMDeviceOlpcMesh = _NMDeviceOlpcMesh;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceOvsBridge {
    _unused: [u8; 0],
}
pub type NMDeviceOvsBridge = _NMDeviceOvsBridge;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceOvsInterface {
    _unused: [u8; 0],
}
pub type NMDeviceOvsInterface = _NMDeviceOvsInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceOvsPort {
    _unused: [u8; 0],
}
pub type NMDeviceOvsPort = _NMDeviceOvsPort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDevicePpp {
    _unused: [u8; 0],
}
pub type NMDevicePpp = _NMDevicePpp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceTeam {
    _unused: [u8; 0],
}
pub type NMDeviceTeam = _NMDeviceTeam;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceTun {
    _unused: [u8; 0],
}
pub type NMDeviceTun = _NMDeviceTun;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceVlan {
    _unused: [u8; 0],
}
pub type NMDeviceVlan = _NMDeviceVlan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceVrf {
    _unused: [u8; 0],
}
pub type NMDeviceVrf = _NMDeviceVrf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceVxlan {
    _unused: [u8; 0],
}
pub type NMDeviceVxlan = _NMDeviceVxlan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWifi {
    _unused: [u8; 0],
}
pub type NMDeviceWifi = _NMDeviceWifi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWifiP2P {
    _unused: [u8; 0],
}
pub type NMDeviceWifiP2P = _NMDeviceWifiP2P;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWimax {
    _unused: [u8; 0],
}
pub type NMDeviceWimax = _NMDeviceWimax;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWireGuard {
    _unused: [u8; 0],
}
pub type NMDeviceWireGuard = _NMDeviceWireGuard;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWpan {
    _unused: [u8; 0],
}
pub type NMDeviceWpan = _NMDeviceWpan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDhcpConfig {
    _unused: [u8; 0],
}
pub type NMDhcpConfig = _NMDhcpConfig;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMIPConfig {
    _unused: [u8; 0],
}
pub type NMIPConfig = _NMIPConfig;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMObject {
    _unused: [u8; 0],
}
pub type NMObject = _NMObject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMRemoteConnection {
    _unused: [u8; 0],
}
pub type NMRemoteConnection = _NMRemoteConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVpnConnection {
    _unused: [u8; 0],
}
pub type NMVpnConnection = _NMVpnConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMWifiP2PPeer {
    _unused: [u8; 0],
}
pub type NMWifiP2PPeer = _NMWifiP2PPeer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMWimaxNsp {
    _unused: [u8; 0],
}
pub type NMWimaxNsp = _NMWimaxNsp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMObjectClass {
    _unused: [u8; 0],
}
#[doc = " NMObject:"]
pub type NMObjectClass = _NMObjectClass;
extern "C" {
    pub fn nm_object_get_type() -> GType;
}
extern "C" {
    pub fn nm_object_get_path(object: *mut NMObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_object_get_client(object: *mut NMObject) -> *mut NMClient;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMAccessPointClass {
    _unused: [u8; 0],
}
#[doc = " NMAccessPoint:"]
pub type NMAccessPointClass = _NMAccessPointClass;
extern "C" {
    pub fn nm_access_point_get_type() -> GType;
}
extern "C" {
    pub fn nm_access_point_get_flags(ap: *mut NMAccessPoint) -> NM80211ApFlags;
}
extern "C" {
    pub fn nm_access_point_get_wpa_flags(ap: *mut NMAccessPoint) -> NM80211ApSecurityFlags;
}
extern "C" {
    pub fn nm_access_point_get_rsn_flags(ap: *mut NMAccessPoint) -> NM80211ApSecurityFlags;
}
extern "C" {
    pub fn nm_access_point_get_ssid(ap: *mut NMAccessPoint) -> *mut GBytes;
}
extern "C" {
    pub fn nm_access_point_get_bssid(ap: *mut NMAccessPoint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_access_point_get_frequency(ap: *mut NMAccessPoint) -> guint32;
}
extern "C" {
    pub fn nm_access_point_get_mode(ap: *mut NMAccessPoint) -> NM80211Mode;
}
extern "C" {
    pub fn nm_access_point_get_max_bitrate(ap: *mut NMAccessPoint) -> guint32;
}
extern "C" {
    pub fn nm_access_point_get_strength(ap: *mut NMAccessPoint) -> guint8;
}
extern "C" {
    pub fn nm_access_point_get_last_seen(ap: *mut NMAccessPoint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_access_point_filter_connections(
        ap: *mut NMAccessPoint,
        connections: *const GPtrArray,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_access_point_connection_valid(
        ap: *mut NMAccessPoint,
        connection: *mut NMConnection,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMActiveConnectionClass {
    _unused: [u8; 0],
}
#[doc = " NMActiveConnection:"]
pub type NMActiveConnectionClass = _NMActiveConnectionClass;
extern "C" {
    pub fn nm_active_connection_get_type() -> GType;
}
extern "C" {
    pub fn nm_active_connection_get_connection(
        connection: *mut NMActiveConnection,
    ) -> *mut NMRemoteConnection;
}
extern "C" {
    pub fn nm_active_connection_get_id(
        connection: *mut NMActiveConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_active_connection_get_uuid(
        connection: *mut NMActiveConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_active_connection_get_connection_type(
        connection: *mut NMActiveConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_active_connection_get_specific_object_path(
        connection: *mut NMActiveConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_active_connection_get_devices(
        connection: *mut NMActiveConnection,
    ) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_active_connection_get_state(
        connection: *mut NMActiveConnection,
    ) -> NMActiveConnectionState;
}
extern "C" {
    pub fn nm_active_connection_get_state_flags(
        connection: *mut NMActiveConnection,
    ) -> NMActivationStateFlags;
}
extern "C" {
    pub fn nm_active_connection_get_state_reason(
        connection: *mut NMActiveConnection,
    ) -> NMActiveConnectionStateReason;
}
extern "C" {
    pub fn nm_active_connection_get_master(connection: *mut NMActiveConnection) -> *mut NMDevice;
}
extern "C" {
    pub fn nm_active_connection_get_default(connection: *mut NMActiveConnection) -> gboolean;
}
extern "C" {
    pub fn nm_active_connection_get_ip4_config(
        connection: *mut NMActiveConnection,
    ) -> *mut NMIPConfig;
}
extern "C" {
    pub fn nm_active_connection_get_dhcp4_config(
        connection: *mut NMActiveConnection,
    ) -> *mut NMDhcpConfig;
}
extern "C" {
    pub fn nm_active_connection_get_default6(connection: *mut NMActiveConnection) -> gboolean;
}
extern "C" {
    pub fn nm_active_connection_get_ip6_config(
        connection: *mut NMActiveConnection,
    ) -> *mut NMIPConfig;
}
extern "C" {
    pub fn nm_active_connection_get_dhcp6_config(
        connection: *mut NMActiveConnection,
    ) -> *mut NMDhcpConfig;
}
extern "C" {
    pub fn nm_active_connection_get_vpn(connection: *mut NMActiveConnection) -> gboolean;
}
pub const NMClientInstanceFlags_NM_CLIENT_INSTANCE_FLAGS_NONE: NMClientInstanceFlags = 0;
pub const NMClientInstanceFlags_NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS:
    NMClientInstanceFlags = 1;
#[doc = " NMClientInstanceFlags:"]
#[doc = " @NM_CLIENT_INSTANCE_FLAGS_NONE: special value to indicate no flags."]
#[doc = " @NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS: by default, NMClient"]
#[doc = "   will fetch the permissions via \"GetPermissions\" and refetch them when"]
#[doc = "   \"CheckPermissions\" signal gets received. By setting this flag, this behavior"]
#[doc = "   can be disabled. You can toggle this flag to enable and disable automatic"]
#[doc = "   fetching of the permissions. Watch also nm_client_get_permissions_state()"]
#[doc = "   to know whether the permissions are up to date."]
#[doc = ""]
#[doc = " Since: 1.24"]
pub type NMClientInstanceFlags = ::std::os::raw::c_uint;
pub const NMClientError_NM_CLIENT_ERROR_FAILED: NMClientError = 0;
pub const NMClientError_NM_CLIENT_ERROR_MANAGER_NOT_RUNNING: NMClientError = 1;
pub const NMClientError_NM_CLIENT_ERROR_OBJECT_CREATION_FAILED: NMClientError = 2;
#[doc = " NMClientError:"]
#[doc = " @NM_CLIENT_ERROR_FAILED: unknown or unclassified error"]
#[doc = " @NM_CLIENT_ERROR_MANAGER_NOT_RUNNING: an operation that requires NetworkManager"]
#[doc = "   failed because NetworkManager is not running"]
#[doc = " @NM_CLIENT_ERROR_OBJECT_CREATION_FAILED: NetworkManager claimed that an"]
#[doc = "   operation succeeded, but the object that was allegedly created (eg,"]
#[doc = "   #NMRemoteConnection, #NMActiveConnection) was apparently destroyed before"]
#[doc = "   #NMClient could create a representation of it."]
#[doc = ""]
#[doc = " Describes errors that may result from operations involving a #NMClient."]
#[doc = ""]
#[doc = " D-Bus operations may also return errors from other domains, including"]
#[doc = " #NMManagerError, #NMSettingsError, #NMAgentManagerError, and #NMConnectionError."]
pub type NMClientError = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_client_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMDnsEntry {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nm_dns_entry_get_type() -> GType;
}
extern "C" {
    pub fn nm_dns_entry_unref(entry: *mut NMDnsEntry);
}
extern "C" {
    pub fn nm_dns_entry_get_interface(entry: *mut NMDnsEntry) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_dns_entry_get_nameservers(
        entry: *mut NMDnsEntry,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_dns_entry_get_domains(entry: *mut NMDnsEntry)
        -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_dns_entry_get_priority(entry: *mut NMDnsEntry) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_dns_entry_get_vpn(entry: *mut NMDnsEntry) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMClientClass {
    _unused: [u8; 0],
}
#[doc = " NMClient:"]
pub type NMClientClass = _NMClientClass;
extern "C" {
    pub fn nm_client_get_type() -> GType;
}
extern "C" {
    pub fn nm_client_new(cancellable: *mut GCancellable, error: *mut *mut GError) -> *mut NMClient;
}
extern "C" {
    pub fn nm_client_new_async(
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_new_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut NMClient;
}
extern "C" {
    pub fn nm_client_get_instance_flags(self_: *mut NMClient) -> NMClientInstanceFlags;
}
extern "C" {
    pub fn nm_client_get_dbus_connection(client: *mut NMClient) -> *mut GDBusConnection;
}
extern "C" {
    pub fn nm_client_get_main_context(self_: *mut NMClient) -> *mut GMainContext;
}
extern "C" {
    pub fn nm_client_get_context_busy_watcher(self_: *mut NMClient) -> *mut GObject;
}
extern "C" {
    pub fn nm_client_get_dbus_name_owner(client: *mut NMClient) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_client_get_version(client: *mut NMClient) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_client_get_state(client: *mut NMClient) -> NMState;
}
extern "C" {
    pub fn nm_client_get_startup(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_get_nm_running(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_get_object_by_path(
        client: *mut NMClient,
        dbus_path: *const ::std::os::raw::c_char,
    ) -> *mut NMObject;
}
extern "C" {
    pub fn nm_client_get_metered(client: *mut NMClient) -> NMMetered;
}
extern "C" {
    pub fn nm_client_networking_get_enabled(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_get_capabilities(client: *mut NMClient, length: *mut gsize) -> *const guint32;
}
extern "C" {
    pub fn nm_client_networking_set_enabled(
        client: *mut NMClient,
        enabled: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_wireless_get_enabled(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_wireless_set_enabled(client: *mut NMClient, enabled: gboolean);
}
extern "C" {
    pub fn nm_client_wireless_hardware_get_enabled(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_wwan_get_enabled(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_wwan_set_enabled(client: *mut NMClient, enabled: gboolean);
}
extern "C" {
    pub fn nm_client_wwan_hardware_get_enabled(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_wimax_get_enabled(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_wimax_set_enabled(client: *mut NMClient, enabled: gboolean);
}
extern "C" {
    pub fn nm_client_wimax_hardware_get_enabled(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_connectivity_check_get_available(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_connectivity_check_get_enabled(client: *mut NMClient) -> gboolean;
}
extern "C" {
    pub fn nm_client_connectivity_check_set_enabled(client: *mut NMClient, enabled: gboolean);
}
extern "C" {
    pub fn nm_client_connectivity_check_get_uri(
        client: *mut NMClient,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_client_get_logging(
        client: *mut NMClient,
        level: *mut *mut ::std::os::raw::c_char,
        domains: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_set_logging(
        client: *mut NMClient,
        level: *const ::std::os::raw::c_char,
        domains: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_get_permission_result(
        client: *mut NMClient,
        permission: NMClientPermission,
    ) -> NMClientPermissionResult;
}
extern "C" {
    pub fn nm_client_get_permissions_state(self_: *mut NMClient) -> NMTernary;
}
extern "C" {
    pub fn nm_client_get_connectivity(client: *mut NMClient) -> NMConnectivityState;
}
extern "C" {
    pub fn nm_client_check_connectivity(
        client: *mut NMClient,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> NMConnectivityState;
}
extern "C" {
    pub fn nm_client_check_connectivity_async(
        client: *mut NMClient,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_check_connectivity_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> NMConnectivityState;
}
extern "C" {
    pub fn nm_client_save_hostname(
        client: *mut NMClient,
        hostname: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_save_hostname_async(
        client: *mut NMClient,
        hostname: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_save_hostname_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_get_devices(client: *mut NMClient) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_client_get_all_devices(client: *mut NMClient) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_client_get_device_by_path(
        client: *mut NMClient,
        object_path: *const ::std::os::raw::c_char,
    ) -> *mut NMDevice;
}
extern "C" {
    pub fn nm_client_get_device_by_iface(
        client: *mut NMClient,
        iface: *const ::std::os::raw::c_char,
    ) -> *mut NMDevice;
}
extern "C" {
    pub fn nm_client_get_active_connections(client: *mut NMClient) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_client_get_primary_connection(client: *mut NMClient) -> *mut NMActiveConnection;
}
extern "C" {
    pub fn nm_client_get_activating_connection(client: *mut NMClient) -> *mut NMActiveConnection;
}
extern "C" {
    pub fn nm_client_activate_connection_async(
        client: *mut NMClient,
        connection: *mut NMConnection,
        device: *mut NMDevice,
        specific_object: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_activate_connection_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut NMActiveConnection;
}
extern "C" {
    pub fn nm_client_add_and_activate_connection_async(
        client: *mut NMClient,
        partial: *mut NMConnection,
        device: *mut NMDevice,
        specific_object: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_add_and_activate_connection_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut NMActiveConnection;
}
extern "C" {
    pub fn nm_client_add_and_activate_connection2(
        client: *mut NMClient,
        partial: *mut NMConnection,
        device: *mut NMDevice,
        specific_object: *const ::std::os::raw::c_char,
        options: *mut GVariant,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_add_and_activate_connection2_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        out_result: *mut *mut GVariant,
        error: *mut *mut GError,
    ) -> *mut NMActiveConnection;
}
extern "C" {
    pub fn nm_client_deactivate_connection(
        client: *mut NMClient,
        active: *mut NMActiveConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_deactivate_connection_async(
        client: *mut NMClient,
        active: *mut NMActiveConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_deactivate_connection_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_get_connections(client: *mut NMClient) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_client_get_connection_by_id(
        client: *mut NMClient,
        id: *const ::std::os::raw::c_char,
    ) -> *mut NMRemoteConnection;
}
extern "C" {
    pub fn nm_client_get_connection_by_path(
        client: *mut NMClient,
        path: *const ::std::os::raw::c_char,
    ) -> *mut NMRemoteConnection;
}
extern "C" {
    pub fn nm_client_get_connection_by_uuid(
        client: *mut NMClient,
        uuid: *const ::std::os::raw::c_char,
    ) -> *mut NMRemoteConnection;
}
extern "C" {
    pub fn nm_client_add_connection_async(
        client: *mut NMClient,
        connection: *mut NMConnection,
        save_to_disk: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_add_connection_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut NMRemoteConnection;
}
extern "C" {
    pub fn nm_client_add_connection2(
        client: *mut NMClient,
        settings: *mut GVariant,
        flags: NMSettingsAddConnection2Flags,
        args: *mut GVariant,
        ignore_out_result: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_add_connection2_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        out_result: *mut *mut GVariant,
        error: *mut *mut GError,
    ) -> *mut NMRemoteConnection;
}
extern "C" {
    pub fn nm_client_load_connections(
        client: *mut NMClient,
        filenames: *mut *mut ::std::os::raw::c_char,
        failures: *mut *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_load_connections_async(
        client: *mut NMClient,
        filenames: *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_load_connections_finish(
        client: *mut NMClient,
        failures: *mut *mut *mut ::std::os::raw::c_char,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_reload_connections(
        client: *mut NMClient,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_reload_connections_async(
        client: *mut NMClient,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_reload_connections_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_get_dns_mode(client: *mut NMClient) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_client_get_dns_rc_manager(client: *mut NMClient) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_client_get_dns_configuration(client: *mut NMClient) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_client_get_checkpoints(client: *mut NMClient) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_client_checkpoint_create(
        client: *mut NMClient,
        devices: *const GPtrArray,
        rollback_timeout: guint32,
        flags: NMCheckpointCreateFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_checkpoint_create_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut NMCheckpoint;
}
extern "C" {
    pub fn nm_client_checkpoint_destroy(
        client: *mut NMClient,
        checkpoint_path: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_checkpoint_destroy_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_checkpoint_rollback(
        client: *mut NMClient,
        checkpoint_path: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_checkpoint_rollback_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
}
extern "C" {
    pub fn nm_client_checkpoint_adjust_rollback_timeout(
        client: *mut NMClient,
        checkpoint_path: *const ::std::os::raw::c_char,
        add_timeout: guint32,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_checkpoint_adjust_rollback_timeout_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_reload(
        client: *mut NMClient,
        flags: NMManagerReloadFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_reload_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_client_dbus_call(
        client: *mut NMClient,
        object_path: *const ::std::os::raw::c_char,
        interface_name: *const ::std::os::raw::c_char,
        method_name: *const ::std::os::raw::c_char,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        timeout_msec: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_dbus_call_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_client_dbus_set_property(
        client: *mut NMClient,
        object_path: *const ::std::os::raw::c_char,
        interface_name: *const ::std::os::raw::c_char,
        property_name: *const ::std::os::raw::c_char,
        value: *mut GVariant,
        timeout_msec: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_client_dbus_set_property_finish(
        client: *mut NMClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceClass {
    _unused: [u8; 0],
}
#[doc = " NMDevice:"]
pub type NMDeviceClass = _NMDeviceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMLldpNeighbor {
    _unused: [u8; 0],
}
pub type NMLldpNeighbor = _NMLldpNeighbor;
extern "C" {
    pub fn nm_device_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_get_iface(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_ip_iface(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_device_type(device: *mut NMDevice) -> NMDeviceType;
}
extern "C" {
    pub fn nm_device_get_udi(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_path(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_driver(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_driver_version(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_firmware_version(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_type_description(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_hw_address(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_capabilities(device: *mut NMDevice) -> NMDeviceCapabilities;
}
extern "C" {
    pub fn nm_device_get_managed(device: *mut NMDevice) -> gboolean;
}
extern "C" {
    pub fn nm_device_set_managed(device: *mut NMDevice, managed: gboolean);
}
extern "C" {
    pub fn nm_device_get_autoconnect(device: *mut NMDevice) -> gboolean;
}
extern "C" {
    pub fn nm_device_set_autoconnect(device: *mut NMDevice, autoconnect: gboolean);
}
extern "C" {
    pub fn nm_device_get_firmware_missing(device: *mut NMDevice) -> gboolean;
}
extern "C" {
    pub fn nm_device_get_nm_plugin_missing(device: *mut NMDevice) -> gboolean;
}
extern "C" {
    pub fn nm_device_get_ip4_config(device: *mut NMDevice) -> *mut NMIPConfig;
}
extern "C" {
    pub fn nm_device_get_dhcp4_config(device: *mut NMDevice) -> *mut NMDhcpConfig;
}
extern "C" {
    pub fn nm_device_get_ip6_config(device: *mut NMDevice) -> *mut NMIPConfig;
}
extern "C" {
    pub fn nm_device_get_dhcp6_config(device: *mut NMDevice) -> *mut NMDhcpConfig;
}
extern "C" {
    pub fn nm_device_get_connectivity(
        device: *mut NMDevice,
        addr_family: ::std::os::raw::c_int,
    ) -> NMConnectivityState;
}
extern "C" {
    pub fn nm_device_get_state(device: *mut NMDevice) -> NMDeviceState;
}
extern "C" {
    pub fn nm_device_get_state_reason(device: *mut NMDevice) -> NMDeviceStateReason;
}
extern "C" {
    pub fn nm_device_get_active_connection(device: *mut NMDevice) -> *mut NMActiveConnection;
}
extern "C" {
    pub fn nm_device_get_available_connections(device: *mut NMDevice) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_device_get_physical_port_id(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_mtu(device: *mut NMDevice) -> guint32;
}
extern "C" {
    pub fn nm_device_is_real(device: *mut NMDevice) -> gboolean;
}
extern "C" {
    pub fn nm_device_is_software(device: *mut NMDevice) -> gboolean;
}
extern "C" {
    pub fn nm_device_get_product(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_vendor(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_description(device: *mut NMDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_get_metered(device: *mut NMDevice) -> NMMetered;
}
extern "C" {
    pub fn nm_device_get_lldp_neighbors(device: *mut NMDevice) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_device_get_interface_flags(device: *mut NMDevice) -> NMDeviceInterfaceFlags;
}
extern "C" {
    pub fn nm_device_disambiguate_names(
        devices: *mut *mut NMDevice,
        num_devices: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_reapply(
        device: *mut NMDevice,
        connection: *mut NMConnection,
        version_id: guint64,
        flags: guint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_reapply_async(
        device: *mut NMDevice,
        connection: *mut NMConnection,
        version_id: guint64,
        flags: guint32,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_device_reapply_finish(
        device: *mut NMDevice,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_get_applied_connection(
        device: *mut NMDevice,
        flags: guint32,
        version_id: *mut guint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut NMConnection;
}
extern "C" {
    pub fn nm_device_get_applied_connection_async(
        device: *mut NMDevice,
        flags: guint32,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_device_get_applied_connection_finish(
        device: *mut NMDevice,
        result: *mut GAsyncResult,
        version_id: *mut guint64,
        error: *mut *mut GError,
    ) -> *mut NMConnection;
}
extern "C" {
    pub fn nm_device_disconnect(
        device: *mut NMDevice,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_disconnect_async(
        device: *mut NMDevice,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_device_disconnect_finish(
        device: *mut NMDevice,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_delete(
        device: *mut NMDevice,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_delete_async(
        device: *mut NMDevice,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_device_delete_finish(
        device: *mut NMDevice,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_filter_connections(
        device: *mut NMDevice,
        connections: *const GPtrArray,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_device_connection_valid(
        device: *mut NMDevice,
        connection: *mut NMConnection,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_connection_compatible(
        device: *mut NMDevice,
        connection: *mut NMConnection,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_get_setting_type(device: *mut NMDevice) -> GType;
}
extern "C" {
    pub fn nm_lldp_neighbor_get_type() -> GType;
}
extern "C" {
    pub fn nm_lldp_neighbor_new() -> *mut NMLldpNeighbor;
}
extern "C" {
    pub fn nm_lldp_neighbor_ref(neighbor: *mut NMLldpNeighbor);
}
extern "C" {
    pub fn nm_lldp_neighbor_unref(neighbor: *mut NMLldpNeighbor);
}
extern "C" {
    pub fn nm_lldp_neighbor_get_attr_names(
        neighbor: *mut NMLldpNeighbor,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_lldp_neighbor_get_attr_string_value(
        neighbor: *mut NMLldpNeighbor,
        name: *const ::std::os::raw::c_char,
        out_value: *mut *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_lldp_neighbor_get_attr_uint_value(
        neighbor: *mut NMLldpNeighbor,
        name: *const ::std::os::raw::c_char,
        out_value: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_lldp_neighbor_get_attr_type(
        neighbor: *mut NMLldpNeighbor,
        name: *const ::std::os::raw::c_char,
    ) -> *const GVariantType;
}
extern "C" {
    pub fn nm_lldp_neighbor_get_attr_value(
        neighbor: *mut NMLldpNeighbor,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GVariant;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDevice6LowpanClass {
    _unused: [u8; 0],
}
#[doc = " NMDevice6Lowpan:"]
pub type NMDevice6LowpanClass = _NMDevice6LowpanClass;
extern "C" {
    pub fn nm_device_6lowpan_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_6lowpan_get_parent(device: *mut NMDevice6Lowpan) -> *mut NMDevice;
}
extern "C" {
    pub fn nm_device_6lowpan_get_hw_address(
        device: *mut NMDevice6Lowpan,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceAdslClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceAdsl:"]
pub type NMDeviceAdslClass = _NMDeviceAdslClass;
extern "C" {
    pub fn nm_device_adsl_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_adsl_get_carrier(device: *mut NMDeviceAdsl) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceBondClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceBond:"]
pub type NMDeviceBondClass = _NMDeviceBondClass;
extern "C" {
    pub fn nm_device_bond_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_bond_get_hw_address(
        device: *mut NMDeviceBond,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_bond_get_carrier(device: *mut NMDeviceBond) -> gboolean;
}
extern "C" {
    pub fn nm_device_bond_get_slaves(device: *mut NMDeviceBond) -> *const GPtrArray;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceBridgeClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceBridge:"]
pub type NMDeviceBridgeClass = _NMDeviceBridgeClass;
extern "C" {
    pub fn nm_device_bridge_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_bridge_get_hw_address(
        device: *mut NMDeviceBridge,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_bridge_get_carrier(device: *mut NMDeviceBridge) -> gboolean;
}
extern "C" {
    pub fn nm_device_bridge_get_slaves(device: *mut NMDeviceBridge) -> *const GPtrArray;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceBtClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceBt:"]
pub type NMDeviceBtClass = _NMDeviceBtClass;
extern "C" {
    pub fn nm_device_bt_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_bt_get_hw_address(device: *mut NMDeviceBt) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_bt_get_name(device: *mut NMDeviceBt) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_bt_get_capabilities(device: *mut NMDeviceBt) -> NMBluetoothCapabilities;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceDummyClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceDummy:"]
pub type NMDeviceDummyClass = _NMDeviceDummyClass;
extern "C" {
    pub fn nm_device_dummy_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_dummy_get_hw_address(
        device: *mut NMDeviceDummy,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceEthernetClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceEthernet:"]
pub type NMDeviceEthernetClass = _NMDeviceEthernetClass;
extern "C" {
    pub fn nm_device_ethernet_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_ethernet_get_hw_address(
        device: *mut NMDeviceEthernet,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_ethernet_get_permanent_hw_address(
        device: *mut NMDeviceEthernet,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_ethernet_get_speed(device: *mut NMDeviceEthernet) -> guint32;
}
extern "C" {
    pub fn nm_device_ethernet_get_carrier(device: *mut NMDeviceEthernet) -> gboolean;
}
extern "C" {
    pub fn nm_device_ethernet_get_s390_subchannels(
        device: *mut NMDeviceEthernet,
    ) -> *const *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceGenericClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceGeneric:"]
pub type NMDeviceGenericClass = _NMDeviceGenericClass;
extern "C" {
    pub fn nm_device_generic_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_generic_get_hw_address(
        device: *mut NMDeviceGeneric,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceInfinibandClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceInfiniband:"]
pub type NMDeviceInfinibandClass = _NMDeviceInfinibandClass;
extern "C" {
    pub fn nm_device_infiniband_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_infiniband_get_hw_address(
        device: *mut NMDeviceInfiniband,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_infiniband_get_carrier(device: *mut NMDeviceInfiniband) -> gboolean;
}
#[doc = " NMSettingIPTunnel:"]
#[doc = ""]
#[doc = " IP Tunneling Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingIPTunnel {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingIPTunnel() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingIPTunnel>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingIPTunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingIPTunnel>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingIPTunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingIPTunnel>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingIPTunnel),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingIPTunnelClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingIPTunnelClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingIPTunnelClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingIPTunnelClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingIPTunnelClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingIPTunnelClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingIPTunnelClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingIPTunnelClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingIPTunnelClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingIPTunnelClass),
            "::",
            stringify!(padding)
        )
    );
}
pub const NMIPTunnelFlags_NM_IP_TUNNEL_FLAG_NONE: NMIPTunnelFlags = 0;
pub const NMIPTunnelFlags_NM_IP_TUNNEL_FLAG_IP6_IGN_ENCAP_LIMIT: NMIPTunnelFlags = 1;
pub const NMIPTunnelFlags_NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_TCLASS: NMIPTunnelFlags = 2;
pub const NMIPTunnelFlags_NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FLOWLABEL: NMIPTunnelFlags = 4;
pub const NMIPTunnelFlags_NM_IP_TUNNEL_FLAG_IP6_MIP6_DEV: NMIPTunnelFlags = 8;
pub const NMIPTunnelFlags_NM_IP_TUNNEL_FLAG_IP6_RCV_DSCP_COPY: NMIPTunnelFlags = 16;
pub const NMIPTunnelFlags_NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FWMARK: NMIPTunnelFlags = 32;
pub type NMIPTunnelFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_setting_ip_tunnel_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_parent(
        setting: *mut NMSettingIPTunnel,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_mode(setting: *mut NMSettingIPTunnel) -> NMIPTunnelMode;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_local(
        setting: *mut NMSettingIPTunnel,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_remote(
        setting: *mut NMSettingIPTunnel,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_ttl(setting: *mut NMSettingIPTunnel) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_tos(setting: *mut NMSettingIPTunnel) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_path_mtu_discovery(setting: *mut NMSettingIPTunnel)
        -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_input_key(
        setting: *mut NMSettingIPTunnel,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_output_key(
        setting: *mut NMSettingIPTunnel,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_encapsulation_limit(setting: *mut NMSettingIPTunnel) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_flow_label(setting: *mut NMSettingIPTunnel) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_mtu(setting: *mut NMSettingIPTunnel) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_tunnel_get_flags(setting: *mut NMSettingIPTunnel) -> NMIPTunnelFlags;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceIPTunnelClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceIPTunnel:"]
pub type NMDeviceIPTunnelClass = _NMDeviceIPTunnelClass;
extern "C" {
    pub fn nm_device_ip_tunnel_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_parent(device: *mut NMDeviceIPTunnel) -> *mut NMDevice;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_mode(device: *mut NMDeviceIPTunnel) -> NMIPTunnelMode;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_local(
        device: *mut NMDeviceIPTunnel,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_remote(
        device: *mut NMDeviceIPTunnel,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_ttl(device: *mut NMDeviceIPTunnel) -> guint8;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_tos(device: *mut NMDeviceIPTunnel) -> guint8;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_path_mtu_discovery(device: *mut NMDeviceIPTunnel) -> gboolean;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_input_key(
        device: *mut NMDeviceIPTunnel,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_output_key(
        device: *mut NMDeviceIPTunnel,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_encapsulation_limit(device: *mut NMDeviceIPTunnel) -> guint8;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_flow_label(device: *mut NMDeviceIPTunnel) -> guint;
}
extern "C" {
    pub fn nm_device_ip_tunnel_get_flags(device: *mut NMDeviceIPTunnel) -> NMIPTunnelFlags;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceMacsecClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceMacsec:"]
pub type NMDeviceMacsecClass = _NMDeviceMacsecClass;
extern "C" {
    pub fn nm_device_macsec_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_macsec_get_parent(device: *mut NMDeviceMacsec) -> *mut NMDevice;
}
extern "C" {
    pub fn nm_device_macsec_get_hw_address(
        device: *mut NMDeviceMacsec,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_macsec_get_sci(device: *mut NMDeviceMacsec) -> guint64;
}
extern "C" {
    pub fn nm_device_macsec_get_icv_length(device: *mut NMDeviceMacsec) -> guint8;
}
extern "C" {
    pub fn nm_device_macsec_get_cipher_suite(device: *mut NMDeviceMacsec) -> guint64;
}
extern "C" {
    pub fn nm_device_macsec_get_window(device: *mut NMDeviceMacsec) -> guint;
}
extern "C" {
    pub fn nm_device_macsec_get_encoding_sa(device: *mut NMDeviceMacsec) -> guint8;
}
extern "C" {
    pub fn nm_device_macsec_get_validation(
        device: *mut NMDeviceMacsec,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_macsec_get_encrypt(device: *mut NMDeviceMacsec) -> gboolean;
}
extern "C" {
    pub fn nm_device_macsec_get_protect(device: *mut NMDeviceMacsec) -> gboolean;
}
extern "C" {
    pub fn nm_device_macsec_get_include_sci(device: *mut NMDeviceMacsec) -> gboolean;
}
extern "C" {
    pub fn nm_device_macsec_get_es(device: *mut NMDeviceMacsec) -> gboolean;
}
extern "C" {
    pub fn nm_device_macsec_get_scb(device: *mut NMDeviceMacsec) -> gboolean;
}
extern "C" {
    pub fn nm_device_macsec_get_replay_protect(device: *mut NMDeviceMacsec) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceMacvlanClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceMacvlan:"]
pub type NMDeviceMacvlanClass = _NMDeviceMacvlanClass;
extern "C" {
    pub fn nm_device_macvlan_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_macvlan_get_parent(device: *mut NMDeviceMacvlan) -> *mut NMDevice;
}
extern "C" {
    pub fn nm_device_macvlan_get_mode(
        device: *mut NMDeviceMacvlan,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_macvlan_get_no_promisc(device: *mut NMDeviceMacvlan) -> gboolean;
}
extern "C" {
    pub fn nm_device_macvlan_get_tap(device: *mut NMDeviceMacvlan) -> gboolean;
}
extern "C" {
    pub fn nm_device_macvlan_get_hw_address(
        device: *mut NMDeviceMacvlan,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceModemClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceModem:"]
pub type NMDeviceModemClass = _NMDeviceModemClass;
extern "C" {
    pub fn nm_device_modem_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_modem_get_modem_capabilities(
        self_: *mut NMDeviceModem,
    ) -> NMDeviceModemCapabilities;
}
extern "C" {
    pub fn nm_device_modem_get_current_capabilities(
        self_: *mut NMDeviceModem,
    ) -> NMDeviceModemCapabilities;
}
extern "C" {
    pub fn nm_device_modem_get_device_id(
        self_: *mut NMDeviceModem,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_modem_get_operator_code(
        self_: *mut NMDeviceModem,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_modem_get_apn(self_: *mut NMDeviceModem) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceOlpcMeshClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceOlpcMesh:"]
pub type NMDeviceOlpcMeshClass = _NMDeviceOlpcMeshClass;
extern "C" {
    pub fn nm_device_olpc_mesh_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_olpc_mesh_get_hw_address(
        device: *mut NMDeviceOlpcMesh,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_olpc_mesh_get_companion(device: *mut NMDeviceOlpcMesh) -> *mut NMDeviceWifi;
}
extern "C" {
    pub fn nm_device_olpc_mesh_get_active_channel(device: *mut NMDeviceOlpcMesh) -> guint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceOvsBridgeClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceOvsBridge:"]
pub type NMDeviceOvsBridgeClass = _NMDeviceOvsBridgeClass;
extern "C" {
    pub fn nm_device_ovs_bridge_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_ovs_bridge_get_slaves(device: *mut NMDeviceOvsBridge) -> *const GPtrArray;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceOvsInterfaceClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceOvsInterface:"]
pub type NMDeviceOvsInterfaceClass = _NMDeviceOvsInterfaceClass;
extern "C" {
    pub fn nm_device_ovs_interface_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceOvsPortClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceOvsPort:"]
pub type NMDeviceOvsPortClass = _NMDeviceOvsPortClass;
extern "C" {
    pub fn nm_device_ovs_port_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_ovs_port_get_slaves(device: *mut NMDeviceOvsPort) -> *const GPtrArray;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDevicePppClass {
    _unused: [u8; 0],
}
#[doc = " NMDevicePpp:"]
pub type NMDevicePppClass = _NMDevicePppClass;
extern "C" {
    pub fn nm_device_ppp_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceTeamClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceTeam:"]
pub type NMDeviceTeamClass = _NMDeviceTeamClass;
extern "C" {
    pub fn nm_device_team_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_team_get_hw_address(
        device: *mut NMDeviceTeam,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_team_get_carrier(device: *mut NMDeviceTeam) -> gboolean;
}
extern "C" {
    pub fn nm_device_team_get_slaves(device: *mut NMDeviceTeam) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_device_team_get_config(device: *mut NMDeviceTeam) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceTunClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceTun:"]
pub type NMDeviceTunClass = _NMDeviceTunClass;
extern "C" {
    pub fn nm_device_tun_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_tun_get_hw_address(device: *mut NMDeviceTun) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_tun_get_mode(device: *mut NMDeviceTun) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_tun_get_owner(device: *mut NMDeviceTun) -> gint64;
}
extern "C" {
    pub fn nm_device_tun_get_group(device: *mut NMDeviceTun) -> gint64;
}
extern "C" {
    pub fn nm_device_tun_get_no_pi(device: *mut NMDeviceTun) -> gboolean;
}
extern "C" {
    pub fn nm_device_tun_get_vnet_hdr(device: *mut NMDeviceTun) -> gboolean;
}
extern "C" {
    pub fn nm_device_tun_get_multi_queue(device: *mut NMDeviceTun) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceVlanClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceVlan:"]
pub type NMDeviceVlanClass = _NMDeviceVlanClass;
extern "C" {
    pub fn nm_device_vlan_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_vlan_get_hw_address(
        device: *mut NMDeviceVlan,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_vlan_get_carrier(device: *mut NMDeviceVlan) -> gboolean;
}
extern "C" {
    pub fn nm_device_vlan_get_parent(device: *mut NMDeviceVlan) -> *mut NMDevice;
}
extern "C" {
    pub fn nm_device_vlan_get_vlan_id(device: *mut NMDeviceVlan) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceVxlanClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceVxlan:"]
pub type NMDeviceVxlanClass = _NMDeviceVxlanClass;
extern "C" {
    pub fn nm_device_vxlan_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_vxlan_get_hw_address(
        device: *mut NMDeviceVxlan,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_vxlan_get_carrier(device: *mut NMDeviceVxlan) -> gboolean;
}
extern "C" {
    pub fn nm_device_vxlan_get_parent(device: *mut NMDeviceVxlan) -> *mut NMDevice;
}
extern "C" {
    pub fn nm_device_vxlan_get_id(device: *mut NMDeviceVxlan) -> guint;
}
extern "C" {
    pub fn nm_device_vxlan_get_group(device: *mut NMDeviceVxlan) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_vxlan_get_local(device: *mut NMDeviceVxlan) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_vxlan_get_src_port_min(device: *mut NMDeviceVxlan) -> guint;
}
extern "C" {
    pub fn nm_device_vxlan_get_src_port_max(device: *mut NMDeviceVxlan) -> guint;
}
extern "C" {
    pub fn nm_device_vxlan_get_dst_port(device: *mut NMDeviceVxlan) -> guint;
}
extern "C" {
    pub fn nm_device_vxlan_get_learning(device: *mut NMDeviceVxlan) -> gboolean;
}
extern "C" {
    pub fn nm_device_vxlan_get_ageing(device: *mut NMDeviceVxlan) -> guint;
}
extern "C" {
    pub fn nm_device_vxlan_get_tos(device: *mut NMDeviceVxlan) -> guint;
}
extern "C" {
    pub fn nm_device_vxlan_get_ttl(device: *mut NMDeviceVxlan) -> guint;
}
extern "C" {
    pub fn nm_device_vxlan_get_limit(device: *mut NMDeviceVxlan) -> guint;
}
extern "C" {
    pub fn nm_device_vxlan_get_proxy(device: *mut NMDeviceVxlan) -> gboolean;
}
extern "C" {
    pub fn nm_device_vxlan_get_rsc(device: *mut NMDeviceVxlan) -> gboolean;
}
extern "C" {
    pub fn nm_device_vxlan_get_l2miss(device: *mut NMDeviceVxlan) -> gboolean;
}
extern "C" {
    pub fn nm_device_vxlan_get_l3miss(device: *mut NMDeviceVxlan) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWifiP2PClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceWifiP2P:"]
#[doc = ""]
#[doc = " Since: 1.16"]
pub type NMDeviceWifiP2PClass = _NMDeviceWifiP2PClass;
extern "C" {
    pub fn nm_device_wifi_p2p_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_wifi_p2p_get_hw_address(
        device: *mut NMDeviceWifiP2P,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_wifi_p2p_get_peer_by_path(
        device: *mut NMDeviceWifiP2P,
        path: *const ::std::os::raw::c_char,
    ) -> *mut NMWifiP2PPeer;
}
extern "C" {
    pub fn nm_device_wifi_p2p_get_peers(device: *mut NMDeviceWifiP2P) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_device_wifi_p2p_start_find(
        device: *mut NMDeviceWifiP2P,
        options: *mut GVariant,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_device_wifi_p2p_start_find_finish(
        device: *mut NMDeviceWifiP2P,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_wifi_p2p_stop_find(
        device: *mut NMDeviceWifiP2P,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_device_wifi_p2p_stop_find_finish(
        device: *mut NMDeviceWifiP2P,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWifiClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceWifi:"]
pub type NMDeviceWifiClass = _NMDeviceWifiClass;
extern "C" {
    pub fn nm_device_wifi_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_wifi_get_hw_address(
        device: *mut NMDeviceWifi,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_wifi_get_permanent_hw_address(
        device: *mut NMDeviceWifi,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_wifi_get_mode(device: *mut NMDeviceWifi) -> NM80211Mode;
}
extern "C" {
    pub fn nm_device_wifi_get_bitrate(device: *mut NMDeviceWifi) -> guint32;
}
extern "C" {
    pub fn nm_device_wifi_get_capabilities(device: *mut NMDeviceWifi) -> NMDeviceWifiCapabilities;
}
extern "C" {
    pub fn nm_device_wifi_get_active_access_point(device: *mut NMDeviceWifi) -> *mut NMAccessPoint;
}
extern "C" {
    pub fn nm_device_wifi_get_access_point_by_path(
        device: *mut NMDeviceWifi,
        path: *const ::std::os::raw::c_char,
    ) -> *mut NMAccessPoint;
}
extern "C" {
    pub fn nm_device_wifi_get_access_points(device: *mut NMDeviceWifi) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_device_wifi_get_last_scan(device: *mut NMDeviceWifi) -> gint64;
}
extern "C" {
    pub fn nm_device_wifi_request_scan(
        device: *mut NMDeviceWifi,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_wifi_request_scan_options(
        device: *mut NMDeviceWifi,
        options: *mut GVariant,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_device_wifi_request_scan_async(
        device: *mut NMDeviceWifi,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_device_wifi_request_scan_options_async(
        device: *mut NMDeviceWifi,
        options: *mut GVariant,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_device_wifi_request_scan_finish(
        device: *mut NMDeviceWifi,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWimaxClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceWimax:"]
#[doc = ""]
#[doc = " Deprecated: 1.22: WiMAX is no longer supported by NetworkManager since 1.2.0."]
pub type NMDeviceWimaxClass = _NMDeviceWimaxClass;
extern "C" {
    pub fn nm_device_wimax_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_wimax_get_hw_address(
        wimax: *mut NMDeviceWimax,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_device_wimax_get_active_nsp(wimax: *mut NMDeviceWimax) -> *mut NMWimaxNsp;
}
extern "C" {
    pub fn nm_device_wimax_get_nsp_by_path(
        wimax: *mut NMDeviceWimax,
        path: *const ::std::os::raw::c_char,
    ) -> *mut NMWimaxNsp;
}
extern "C" {
    pub fn nm_device_wimax_get_nsps(wimax: *mut NMDeviceWimax) -> *const GPtrArray;
}
extern "C" {
    pub fn nm_device_wimax_get_center_frequency(self_: *mut NMDeviceWimax) -> guint;
}
extern "C" {
    pub fn nm_device_wimax_get_rssi(self_: *mut NMDeviceWimax) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_device_wimax_get_cinr(self_: *mut NMDeviceWimax) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_device_wimax_get_tx_power(self_: *mut NMDeviceWimax) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_device_wimax_get_bsid(self_: *mut NMDeviceWimax) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWireGuardClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceWireGuard:"]
pub type NMDeviceWireGuardClass = _NMDeviceWireGuardClass;
extern "C" {
    pub fn nm_device_wireguard_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_wireguard_get_public_key(device: *mut NMDeviceWireGuard) -> *mut GBytes;
}
extern "C" {
    pub fn nm_device_wireguard_get_listen_port(device: *mut NMDeviceWireGuard) -> guint16;
}
extern "C" {
    pub fn nm_device_wireguard_get_fwmark(device: *mut NMDeviceWireGuard) -> guint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceWpanClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceWpan:"]
pub type NMDeviceWpanClass = _NMDeviceWpanClass;
extern "C" {
    pub fn nm_device_wpan_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_wpan_get_hw_address(
        device: *mut NMDeviceWpan,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDhcpConfigClass {
    _unused: [u8; 0],
}
#[doc = " NMDhcpConfig:"]
pub type NMDhcpConfigClass = _NMDhcpConfigClass;
extern "C" {
    pub fn nm_dhcp_config_get_type() -> GType;
}
extern "C" {
    pub fn nm_dhcp_config_get_family(config: *mut NMDhcpConfig) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_dhcp_config_get_options(config: *mut NMDhcpConfig) -> *mut GHashTable;
}
extern "C" {
    pub fn nm_dhcp_config_get_one_option(
        config: *mut NMDhcpConfig,
        option: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_client_instance_flags_get_type() -> GType;
}
extern "C" {
    pub fn nm_client_error_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMIPConfigClass {
    _unused: [u8; 0],
}
#[doc = " NMIPConfig:"]
pub type NMIPConfigClass = _NMIPConfigClass;
extern "C" {
    pub fn nm_ip_config_get_type() -> GType;
}
extern "C" {
    pub fn nm_ip_config_get_family(config: *mut NMIPConfig) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_ip_config_get_gateway(config: *mut NMIPConfig) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_config_get_addresses(config: *mut NMIPConfig) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_ip_config_get_routes(config: *mut NMIPConfig) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_ip_config_get_nameservers(
        config: *mut NMIPConfig,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_config_get_domains(
        config: *mut NMIPConfig,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_config_get_searches(
        config: *mut NMIPConfig,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_config_get_wins_servers(
        config: *mut NMIPConfig,
    ) -> *const *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMRemoteConnectionClass {
    _unused: [u8; 0],
}
#[doc = " NMRemoteConnection:"]
pub type NMRemoteConnectionClass = _NMRemoteConnectionClass;
extern "C" {
    pub fn nm_remote_connection_get_type() -> GType;
}
extern "C" {
    pub fn nm_remote_connection_update2(
        connection: *mut NMRemoteConnection,
        settings: *mut GVariant,
        flags: NMSettingsUpdate2Flags,
        args: *mut GVariant,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_remote_connection_update2_finish(
        connection: *mut NMRemoteConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_remote_connection_commit_changes(
        connection: *mut NMRemoteConnection,
        save_to_disk: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_remote_connection_commit_changes_async(
        connection: *mut NMRemoteConnection,
        save_to_disk: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_remote_connection_commit_changes_finish(
        connection: *mut NMRemoteConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_remote_connection_save(
        connection: *mut NMRemoteConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_remote_connection_save_async(
        connection: *mut NMRemoteConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_remote_connection_save_finish(
        connection: *mut NMRemoteConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_remote_connection_delete(
        connection: *mut NMRemoteConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_remote_connection_delete_async(
        connection: *mut NMRemoteConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_remote_connection_delete_finish(
        connection: *mut NMRemoteConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_remote_connection_get_secrets(
        connection: *mut NMRemoteConnection,
        setting_name: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_remote_connection_get_secrets_async(
        connection: *mut NMRemoteConnection,
        setting_name: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_remote_connection_get_secrets_finish(
        connection: *mut NMRemoteConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_remote_connection_get_unsaved(connection: *mut NMRemoteConnection) -> gboolean;
}
extern "C" {
    pub fn nm_remote_connection_get_flags(
        connection: *mut NMRemoteConnection,
    ) -> NMSettingsConnectionFlags;
}
extern "C" {
    pub fn nm_remote_connection_get_filename(
        connection: *mut NMRemoteConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_remote_connection_get_visible(connection: *mut NMRemoteConnection) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSetting6LowpanClass {
    _unused: [u8; 0],
}
pub type NMSetting6LowpanClass = _NMSetting6LowpanClass;
extern "C" {
    pub fn nm_setting_6lowpan_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_6lowpan_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_6lowpan_get_parent(
        setting: *mut NMSetting6Lowpan,
    ) -> *const ::std::os::raw::c_char;
}
pub const NMSetting8021xCKFormat_NM_SETTING_802_1X_CK_FORMAT_UNKNOWN: NMSetting8021xCKFormat = 0;
pub const NMSetting8021xCKFormat_NM_SETTING_802_1X_CK_FORMAT_X509: NMSetting8021xCKFormat = 1;
pub const NMSetting8021xCKFormat_NM_SETTING_802_1X_CK_FORMAT_RAW_KEY: NMSetting8021xCKFormat = 2;
pub const NMSetting8021xCKFormat_NM_SETTING_802_1X_CK_FORMAT_PKCS12: NMSetting8021xCKFormat = 3;
#[doc = " NMSetting8021xCKFormat:"]
#[doc = " @NM_SETTING_802_1X_CK_FORMAT_UNKNOWN: unknown file format"]
#[doc = " @NM_SETTING_802_1X_CK_FORMAT_X509: file contains an X.509 format certificate"]
#[doc = " @NM_SETTING_802_1X_CK_FORMAT_RAW_KEY: file contains an old-style OpenSSL PEM"]
#[doc = " or DER private key"]
#[doc = " @NM_SETTING_802_1X_CK_FORMAT_PKCS12: file contains a PKCS#<!-- -->12 certificate"]
#[doc = " and private key"]
#[doc = ""]
#[doc = " #NMSetting8021xCKFormat values indicate the general type of a certificate"]
#[doc = " or private key"]
pub type NMSetting8021xCKFormat = ::std::os::raw::c_uint;
pub const NMSetting8021xCKScheme_NM_SETTING_802_1X_CK_SCHEME_UNKNOWN: NMSetting8021xCKScheme = 0;
pub const NMSetting8021xCKScheme_NM_SETTING_802_1X_CK_SCHEME_BLOB: NMSetting8021xCKScheme = 1;
pub const NMSetting8021xCKScheme_NM_SETTING_802_1X_CK_SCHEME_PATH: NMSetting8021xCKScheme = 2;
pub const NMSetting8021xCKScheme_NM_SETTING_802_1X_CK_SCHEME_PKCS11: NMSetting8021xCKScheme = 3;
#[doc = " NMSetting8021xCKScheme:"]
#[doc = " @NM_SETTING_802_1X_CK_SCHEME_UNKNOWN: unknown certificate or private key"]
#[doc = " scheme"]
#[doc = " @NM_SETTING_802_1X_CK_SCHEME_BLOB: certificate or key is stored as the raw"]
#[doc = " item data"]
#[doc = " @NM_SETTING_802_1X_CK_SCHEME_PATH: certificate or key is stored as a path"]
#[doc = " to a file containing the certificate or key data"]
#[doc = " @NM_SETTING_802_1X_CK_SCHEME_PKCS11: certificate or key is stored as a"]
#[doc = " URI of an object on a PKCS#11 token"]
#[doc = ""]
#[doc = " #NMSetting8021xCKScheme values indicate how a certificate or private key is"]
#[doc = " stored in the setting properties, either as a blob of the item's data, or as"]
#[doc = " a path to a certificate or private key file on the filesystem"]
pub type NMSetting8021xCKScheme = ::std::os::raw::c_uint;
pub const NMSetting8021xAuthFlags_NM_SETTING_802_1X_AUTH_FLAGS_NONE: NMSetting8021xAuthFlags = 0;
pub const NMSetting8021xAuthFlags_NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE:
    NMSetting8021xAuthFlags = 1;
pub const NMSetting8021xAuthFlags_NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE:
    NMSetting8021xAuthFlags = 2;
pub const NMSetting8021xAuthFlags_NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE:
    NMSetting8021xAuthFlags = 4;
pub const NMSetting8021xAuthFlags_NM_SETTING_802_1X_AUTH_FLAGS_ALL: NMSetting8021xAuthFlags = 7;
#[doc = " NMSetting8021xAuthFlags:"]
#[doc = " @NM_SETTING_802_1X_AUTH_FLAGS_NONE: No flags"]
#[doc = " @NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE: Disable TLSv1.0"]
#[doc = " @NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE: Disable TLSv1.1"]
#[doc = " @NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE: Disable TLSv1.2"]
#[doc = " @NM_SETTING_802_1X_AUTH_FLAGS_ALL: All supported flags"]
#[doc = ""]
#[doc = " #NMSetting8021xAuthFlags values indicate which authentication settings"]
#[doc = " should be used."]
#[doc = ""]
#[doc = " Before 1.22, this was wrongly marked as a enum and not as a flags"]
#[doc = " type."]
#[doc = ""]
#[doc = " Since: 1.8"]
pub type NMSetting8021xAuthFlags = ::std::os::raw::c_uint;
#[doc = " NMSetting8021x:"]
#[doc = ""]
#[doc = " IEEE 802.1x Authentication Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSetting8021x {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSetting8021x() {
    assert_eq!(
        ::std::mem::size_of::<_NMSetting8021x>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSetting8021x))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSetting8021x>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSetting8021x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSetting8021x>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSetting8021x),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSetting8021xClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSetting8021xClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSetting8021xClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSetting8021xClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSetting8021xClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSetting8021xClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSetting8021xClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSetting8021xClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSetting8021xClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSetting8021xClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_802_1x_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_802_1x_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_802_1x_check_cert_scheme(
        pdata: gconstpointer,
        length: gsize,
        error: *mut *mut GError,
    ) -> NMSetting8021xCKScheme;
}
extern "C" {
    pub fn nm_setting_802_1x_get_num_eap_methods(setting: *mut NMSetting8021x) -> guint32;
}
extern "C" {
    pub fn nm_setting_802_1x_get_eap_method(
        setting: *mut NMSetting8021x,
        i: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_add_eap_method(
        setting: *mut NMSetting8021x,
        eap: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_remove_eap_method(setting: *mut NMSetting8021x, i: guint32);
}
extern "C" {
    pub fn nm_setting_802_1x_remove_eap_method_by_value(
        setting: *mut NMSetting8021x,
        eap: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_clear_eap_methods(setting: *mut NMSetting8021x);
}
extern "C" {
    pub fn nm_setting_802_1x_get_identity(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_anonymous_identity(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_pac_file(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_system_ca_certs(setting: *mut NMSetting8021x) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_get_ca_path(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_ca_path(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_ca_cert_scheme(
        setting: *mut NMSetting8021x,
    ) -> NMSetting8021xCKScheme;
}
extern "C" {
    pub fn nm_setting_802_1x_get_ca_cert_blob(setting: *mut NMSetting8021x) -> *mut GBytes;
}
extern "C" {
    pub fn nm_setting_802_1x_get_ca_cert_path(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_ca_cert_uri(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_set_ca_cert(
        setting: *mut NMSetting8021x,
        value: *const ::std::os::raw::c_char,
        scheme: NMSetting8021xCKScheme,
        out_format: *mut NMSetting8021xCKFormat,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_get_ca_cert_password(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_ca_cert_password_flags(
        setting: *mut NMSetting8021x,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_subject_match(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_num_altsubject_matches(setting: *mut NMSetting8021x) -> guint32;
}
extern "C" {
    pub fn nm_setting_802_1x_get_altsubject_match(
        setting: *mut NMSetting8021x,
        i: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_add_altsubject_match(
        setting: *mut NMSetting8021x,
        altsubject_match: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_remove_altsubject_match(setting: *mut NMSetting8021x, i: guint32);
}
extern "C" {
    pub fn nm_setting_802_1x_remove_altsubject_match_by_value(
        setting: *mut NMSetting8021x,
        altsubject_match: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_clear_altsubject_matches(setting: *mut NMSetting8021x);
}
extern "C" {
    pub fn nm_setting_802_1x_get_domain_suffix_match(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_domain_match(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_client_cert_scheme(
        setting: *mut NMSetting8021x,
    ) -> NMSetting8021xCKScheme;
}
extern "C" {
    pub fn nm_setting_802_1x_get_client_cert_blob(setting: *mut NMSetting8021x) -> *mut GBytes;
}
extern "C" {
    pub fn nm_setting_802_1x_get_client_cert_path(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_client_cert_uri(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_set_client_cert(
        setting: *mut NMSetting8021x,
        value: *const ::std::os::raw::c_char,
        scheme: NMSetting8021xCKScheme,
        out_format: *mut NMSetting8021xCKFormat,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_get_client_cert_password(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_client_cert_password_flags(
        setting: *mut NMSetting8021x,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase1_peapver(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase1_peaplabel(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase1_fast_provisioning(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_auth(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_autheap(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_ca_cert_scheme(
        setting: *mut NMSetting8021x,
    ) -> NMSetting8021xCKScheme;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_ca_cert_blob(setting: *mut NMSetting8021x) -> *mut GBytes;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_ca_cert_path(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_ca_cert_uri(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_set_phase2_ca_cert(
        setting: *mut NMSetting8021x,
        value: *const ::std::os::raw::c_char,
        scheme: NMSetting8021xCKScheme,
        out_format: *mut NMSetting8021xCKFormat,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_ca_cert_password(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_ca_cert_password_flags(
        setting: *mut NMSetting8021x,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_subject_match(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_num_phase2_altsubject_matches(
        setting: *mut NMSetting8021x,
    ) -> guint32;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_altsubject_match(
        setting: *mut NMSetting8021x,
        i: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_add_phase2_altsubject_match(
        setting: *mut NMSetting8021x,
        phase2_altsubject_match: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_remove_phase2_altsubject_match(
        setting: *mut NMSetting8021x,
        i: guint32,
    );
}
extern "C" {
    pub fn nm_setting_802_1x_remove_phase2_altsubject_match_by_value(
        setting: *mut NMSetting8021x,
        phase2_altsubject_match: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_clear_phase2_altsubject_matches(setting: *mut NMSetting8021x);
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_domain_suffix_match(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_domain_match(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_client_cert_scheme(
        setting: *mut NMSetting8021x,
    ) -> NMSetting8021xCKScheme;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_client_cert_blob(
        setting: *mut NMSetting8021x,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_client_cert_path(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_client_cert_uri(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_set_phase2_client_cert(
        setting: *mut NMSetting8021x,
        value: *const ::std::os::raw::c_char,
        scheme: NMSetting8021xCKScheme,
        out_format: *mut NMSetting8021xCKFormat,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_client_cert_password(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_client_cert_password_flags(
        setting: *mut NMSetting8021x,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_password(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_password_flags(
        setting: *mut NMSetting8021x,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_password_raw(setting: *mut NMSetting8021x) -> *mut GBytes;
}
extern "C" {
    pub fn nm_setting_802_1x_get_password_raw_flags(
        setting: *mut NMSetting8021x,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_pin(setting: *mut NMSetting8021x)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_pin_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_private_key_scheme(
        setting: *mut NMSetting8021x,
    ) -> NMSetting8021xCKScheme;
}
extern "C" {
    pub fn nm_setting_802_1x_get_private_key_blob(setting: *mut NMSetting8021x) -> *mut GBytes;
}
extern "C" {
    pub fn nm_setting_802_1x_get_private_key_path(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_private_key_uri(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_set_private_key(
        setting: *mut NMSetting8021x,
        value: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
        scheme: NMSetting8021xCKScheme,
        out_format: *mut NMSetting8021xCKFormat,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_get_private_key_password(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_private_key_password_flags(
        setting: *mut NMSetting8021x,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_private_key_format(
        setting: *mut NMSetting8021x,
    ) -> NMSetting8021xCKFormat;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_private_key_scheme(
        setting: *mut NMSetting8021x,
    ) -> NMSetting8021xCKScheme;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_private_key_blob(
        setting: *mut NMSetting8021x,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_private_key_path(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_private_key_uri(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_set_phase2_private_key(
        setting: *mut NMSetting8021x,
        value: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
        scheme: NMSetting8021xCKScheme,
        out_format: *mut NMSetting8021xCKFormat,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_private_key_password(
        setting: *mut NMSetting8021x,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_private_key_password_flags(
        setting: *mut NMSetting8021x,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase2_private_key_format(
        setting: *mut NMSetting8021x,
    ) -> NMSetting8021xCKFormat;
}
extern "C" {
    pub fn nm_setting_802_1x_get_phase1_auth_flags(
        setting: *mut NMSetting8021x,
    ) -> NMSetting8021xAuthFlags;
}
extern "C" {
    pub fn nm_setting_802_1x_get_auth_timeout(
        setting: *mut NMSetting8021x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_802_1x_get_optional(setting: *mut NMSetting8021x) -> gboolean;
}
#[doc = " NMSettingAdsl:"]
#[doc = ""]
#[doc = " ADSL Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingAdsl {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingAdsl() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingAdsl>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingAdsl))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingAdsl>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingAdsl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingAdsl>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingAdsl),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingAdslClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingAdslClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingAdslClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingAdslClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingAdslClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingAdslClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingAdslClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingAdslClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingAdslClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingAdslClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_adsl_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_adsl_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_adsl_get_username(
        setting: *mut NMSettingAdsl,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_adsl_get_password(
        setting: *mut NMSettingAdsl,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_adsl_get_protocol(
        setting: *mut NMSettingAdsl,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_adsl_get_encapsulation(
        setting: *mut NMSettingAdsl,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_adsl_get_vpi(setting: *mut NMSettingAdsl) -> guint32;
}
extern "C" {
    pub fn nm_setting_adsl_get_vci(setting: *mut NMSettingAdsl) -> guint32;
}
extern "C" {
    pub fn nm_setting_adsl_get_password_flags(setting: *mut NMSettingAdsl) -> NMSettingSecretFlags;
}
#[doc = " NMSettingBluetooth:"]
#[doc = ""]
#[doc = " Bluetooth Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingBluetooth {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingBluetooth() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingBluetooth>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingBluetooth))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingBluetooth>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingBluetooth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingBluetooth>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingBluetooth),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingBluetoothClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingBluetoothClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingBluetoothClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingBluetoothClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingBluetoothClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingBluetoothClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingBluetoothClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingBluetoothClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingBluetoothClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingBluetoothClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_bluetooth_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_bluetooth_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_bluetooth_get_bdaddr(
        setting: *mut NMSettingBluetooth,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_bluetooth_get_connection_type(
        setting: *mut NMSettingBluetooth,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " NMSettingBond:"]
#[doc = ""]
#[doc = " Bonding Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingBond {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingBond() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingBond>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingBond))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingBond>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingBond))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingBond>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingBond),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingBondClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingBondClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingBondClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingBondClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingBondClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingBondClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingBondClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingBondClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingBondClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingBondClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_bond_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_bond_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_bond_get_num_options(setting: *mut NMSettingBond) -> guint32;
}
extern "C" {
    pub fn nm_setting_bond_get_option(
        setting: *mut NMSettingBond,
        idx: guint32,
        out_name: *mut *const ::std::os::raw::c_char,
        out_value: *mut *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bond_get_option_by_name(
        setting: *mut NMSettingBond,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_bond_add_option(
        setting: *mut NMSettingBond,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bond_remove_option(
        setting: *mut NMSettingBond,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bond_validate_option(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bond_get_valid_options(
        setting: *mut NMSettingBond,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_bond_get_option_default(
        setting: *mut NMSettingBond,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_bond_get_option_normalized(
        setting: *mut NMSettingBond,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingBridgeClass {
    _unused: [u8; 0],
}
pub type NMSettingBridgeClass = _NMSettingBridgeClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMBridgeVlan {
    _unused: [u8; 0],
}
pub type NMBridgeVlan = _NMBridgeVlan;
extern "C" {
    pub fn nm_setting_bridge_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_bridge_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_bridge_get_mac_address(
        setting: *mut NMSettingBridge,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_bridge_get_stp(setting: *mut NMSettingBridge) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bridge_get_priority(setting: *mut NMSettingBridge) -> guint16;
}
extern "C" {
    pub fn nm_setting_bridge_get_forward_delay(setting: *mut NMSettingBridge) -> guint16;
}
extern "C" {
    pub fn nm_setting_bridge_get_hello_time(setting: *mut NMSettingBridge) -> guint16;
}
extern "C" {
    pub fn nm_setting_bridge_get_max_age(setting: *mut NMSettingBridge) -> guint16;
}
extern "C" {
    pub fn nm_setting_bridge_get_ageing_time(setting: *mut NMSettingBridge) -> guint32;
}
extern "C" {
    pub fn nm_setting_bridge_get_group_forward_mask(setting: *mut NMSettingBridge) -> guint16;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_snooping(setting: *mut NMSettingBridge) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bridge_get_vlan_filtering(setting: *mut NMSettingBridge) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bridge_get_vlan_default_pvid(setting: *mut NMSettingBridge) -> guint16;
}
extern "C" {
    pub fn nm_setting_bridge_add_vlan(setting: *mut NMSettingBridge, vlan: *mut NMBridgeVlan);
}
extern "C" {
    pub fn nm_setting_bridge_get_num_vlans(setting: *mut NMSettingBridge) -> guint;
}
extern "C" {
    pub fn nm_setting_bridge_get_vlan(
        setting: *mut NMSettingBridge,
        idx: guint,
    ) -> *mut NMBridgeVlan;
}
extern "C" {
    pub fn nm_setting_bridge_remove_vlan(setting: *mut NMSettingBridge, idx: guint);
}
extern "C" {
    pub fn nm_setting_bridge_remove_vlan_by_vid(
        setting: *mut NMSettingBridge,
        vid_start: guint16,
        vid_end: guint16,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bridge_clear_vlans(setting: *mut NMSettingBridge);
}
extern "C" {
    pub fn nm_bridge_vlan_get_type() -> GType;
}
extern "C" {
    pub fn nm_bridge_vlan_new(vid_start: guint16, vid_end: guint16) -> *mut NMBridgeVlan;
}
extern "C" {
    pub fn nm_bridge_vlan_ref(vlan: *mut NMBridgeVlan) -> *mut NMBridgeVlan;
}
extern "C" {
    pub fn nm_bridge_vlan_unref(vlan: *mut NMBridgeVlan);
}
extern "C" {
    pub fn nm_bridge_vlan_new_clone(vlan: *const NMBridgeVlan) -> *mut NMBridgeVlan;
}
extern "C" {
    pub fn nm_bridge_vlan_cmp(
        a: *const NMBridgeVlan,
        b: *const NMBridgeVlan,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_bridge_vlan_seal(vlan: *mut NMBridgeVlan);
}
extern "C" {
    pub fn nm_bridge_vlan_is_sealed(vlan: *const NMBridgeVlan) -> gboolean;
}
extern "C" {
    pub fn nm_bridge_vlan_set_untagged(vlan: *mut NMBridgeVlan, value: gboolean);
}
extern "C" {
    pub fn nm_bridge_vlan_set_pvid(vlan: *mut NMBridgeVlan, value: gboolean);
}
extern "C" {
    pub fn nm_bridge_vlan_get_vid_range(
        vlan: *const NMBridgeVlan,
        vid_start: *mut guint16,
        vid_end: *mut guint16,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_bridge_vlan_is_untagged(vlan: *const NMBridgeVlan) -> gboolean;
}
extern "C" {
    pub fn nm_bridge_vlan_is_pvid(vlan: *const NMBridgeVlan) -> gboolean;
}
extern "C" {
    pub fn nm_bridge_vlan_to_str(
        vlan: *const NMBridgeVlan,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_bridge_vlan_from_str(
        str_: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMBridgeVlan;
}
extern "C" {
    pub fn nm_setting_bridge_get_group_address(
        setting: *const NMSettingBridge,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_bridge_get_vlan_protocol(
        setting: *const NMSettingBridge,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_bridge_get_vlan_stats_enabled(setting: *const NMSettingBridge) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_router(
        setting: *const NMSettingBridge,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_query_use_ifaddr(
        setting: *const NMSettingBridge,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_querier(setting: *const NMSettingBridge) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_hash_max(setting: *const NMSettingBridge) -> guint32;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_last_member_count(
        setting: *const NMSettingBridge,
    ) -> guint32;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_last_member_interval(
        setting: *const NMSettingBridge,
    ) -> guint64;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_membership_interval(
        setting: *const NMSettingBridge,
    ) -> guint64;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_querier_interval(
        setting: *const NMSettingBridge,
    ) -> guint64;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_query_interval(
        setting: *const NMSettingBridge,
    ) -> guint64;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_query_response_interval(
        setting: *const NMSettingBridge,
    ) -> guint64;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_startup_query_count(
        setting: *const NMSettingBridge,
    ) -> guint32;
}
extern "C" {
    pub fn nm_setting_bridge_get_multicast_startup_query_interval(
        setting: *const NMSettingBridge,
    ) -> guint64;
}
#[doc = " NMSettingBridgePort:"]
#[doc = ""]
#[doc = " Bridge Port Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingBridgePort {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingBridgePort() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingBridgePort>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingBridgePort))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingBridgePort>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingBridgePort))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingBridgePort>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingBridgePort),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingBridgePortClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingBridgePortClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingBridgePortClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingBridgePortClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingBridgePortClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingBridgePortClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingBridgePortClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingBridgePortClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMSettingBridgePortClass>())).padding as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingBridgePortClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_bridge_port_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_bridge_port_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_bridge_port_get_priority(setting: *mut NMSettingBridgePort) -> guint16;
}
extern "C" {
    pub fn nm_setting_bridge_port_get_path_cost(setting: *mut NMSettingBridgePort) -> guint16;
}
extern "C" {
    pub fn nm_setting_bridge_port_get_hairpin_mode(setting: *mut NMSettingBridgePort) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bridge_port_add_vlan(
        setting: *mut NMSettingBridgePort,
        vlan: *mut NMBridgeVlan,
    );
}
extern "C" {
    pub fn nm_setting_bridge_port_get_num_vlans(setting: *mut NMSettingBridgePort) -> guint;
}
extern "C" {
    pub fn nm_setting_bridge_port_get_vlan(
        setting: *mut NMSettingBridgePort,
        idx: guint,
    ) -> *mut NMBridgeVlan;
}
extern "C" {
    pub fn nm_setting_bridge_port_remove_vlan(setting: *mut NMSettingBridgePort, idx: guint);
}
extern "C" {
    pub fn nm_setting_bridge_port_remove_vlan_by_vid(
        setting: *mut NMSettingBridgePort,
        vid_start: guint16,
        vid_end: guint16,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_bridge_port_clear_vlans(setting: *mut NMSettingBridgePort);
}
#[doc = " NMSettingCdma:"]
#[doc = ""]
#[doc = " CDMA-based Mobile Broadband Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingCdma {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingCdma() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingCdma>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingCdma))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingCdma>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingCdma))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingCdma>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingCdma),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingCdmaClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingCdmaClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingCdmaClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingCdmaClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingCdmaClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingCdmaClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingCdmaClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingCdmaClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingCdmaClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingCdmaClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_cdma_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_cdma_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_cdma_get_number(setting: *mut NMSettingCdma)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_cdma_get_username(
        setting: *mut NMSettingCdma,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_cdma_get_password(
        setting: *mut NMSettingCdma,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_cdma_get_password_flags(setting: *mut NMSettingCdma) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_cdma_get_mtu(setting: *mut NMSettingCdma) -> guint32;
}
pub const NMSettingConnectionAutoconnectSlaves_NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT:
    NMSettingConnectionAutoconnectSlaves = -1;
pub const NMSettingConnectionAutoconnectSlaves_NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO:
    NMSettingConnectionAutoconnectSlaves = 0;
pub const NMSettingConnectionAutoconnectSlaves_NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES:
    NMSettingConnectionAutoconnectSlaves = 1;
#[doc = " NMSettingConnectionAutoconnectSlaves:"]
#[doc = " @NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT: default value"]
#[doc = " @NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO: slaves are not brought up when"]
#[doc = "   master is activated"]
#[doc = " @NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES: slaves are brought up when"]
#[doc = "   master is activated"]
#[doc = ""]
#[doc = " #NMSettingConnectionAutoconnectSlaves values indicate whether slave connections"]
#[doc = " should be activated when master is activated."]
pub type NMSettingConnectionAutoconnectSlaves = ::std::os::raw::c_int;
pub const NMSettingConnectionLldp_NM_SETTING_CONNECTION_LLDP_DEFAULT: NMSettingConnectionLldp = -1;
pub const NMSettingConnectionLldp_NM_SETTING_CONNECTION_LLDP_DISABLE: NMSettingConnectionLldp = 0;
pub const NMSettingConnectionLldp_NM_SETTING_CONNECTION_LLDP_ENABLE_RX: NMSettingConnectionLldp = 1;
#[doc = " NMSettingConnectionLldp:"]
#[doc = " @NM_SETTING_CONNECTION_LLDP_DEFAULT: default value"]
#[doc = " @NM_SETTING_CONNECTION_LLDP_DISABLE: disable LLDP"]
#[doc = " @NM_SETTING_CONNECTION_LLDP_ENABLE_RX: enable reception of LLDP frames"]
#[doc = ""]
#[doc = " #NMSettingConnectionLldp values indicate whether LLDP should be enabled."]
pub type NMSettingConnectionLldp = ::std::os::raw::c_int;
pub const NMSettingConnectionMdns_NM_SETTING_CONNECTION_MDNS_DEFAULT: NMSettingConnectionMdns = -1;
pub const NMSettingConnectionMdns_NM_SETTING_CONNECTION_MDNS_NO: NMSettingConnectionMdns = 0;
pub const NMSettingConnectionMdns_NM_SETTING_CONNECTION_MDNS_RESOLVE: NMSettingConnectionMdns = 1;
pub const NMSettingConnectionMdns_NM_SETTING_CONNECTION_MDNS_YES: NMSettingConnectionMdns = 2;
#[doc = " NMSettingConnectionMdns:"]
#[doc = " @NM_SETTING_CONNECTION_MDNS_DEFAULT: default value"]
#[doc = " @NM_SETTING_CONNECTION_MDNS_NO: disable mDNS"]
#[doc = " @NM_SETTING_CONNECTION_MDNS_RESOLVE: support only resolving, do not register hostname"]
#[doc = " @NM_SETTING_CONNECTION_MDNS_YES: enable mDNS"]
#[doc = ""]
#[doc = " #NMSettingConnectionMdns values indicate whether mDNS should be enabled."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type NMSettingConnectionMdns = ::std::os::raw::c_int;
pub const NMSettingConnectionLlmnr_NM_SETTING_CONNECTION_LLMNR_DEFAULT: NMSettingConnectionLlmnr =
    -1;
pub const NMSettingConnectionLlmnr_NM_SETTING_CONNECTION_LLMNR_NO: NMSettingConnectionLlmnr = 0;
pub const NMSettingConnectionLlmnr_NM_SETTING_CONNECTION_LLMNR_RESOLVE: NMSettingConnectionLlmnr =
    1;
pub const NMSettingConnectionLlmnr_NM_SETTING_CONNECTION_LLMNR_YES: NMSettingConnectionLlmnr = 2;
#[doc = " NMSettingConnectionLlmnr:"]
#[doc = " @NM_SETTING_CONNECTION_LLMNR_DEFAULT: default value"]
#[doc = " @NM_SETTING_CONNECTION_LLMNR_NO: disable LLMNR"]
#[doc = " @NM_SETTING_CONNECTION_LLMNR_RESOLVE: support only resolving, do not register hostname"]
#[doc = " @NM_SETTING_CONNECTION_LLMNR_YES: enable LLMNR"]
#[doc = ""]
#[doc = " #NMSettingConnectionLlmnr values indicate whether LLMNR should be enabled."]
#[doc = ""]
#[doc = " Since: 1.14"]
pub type NMSettingConnectionLlmnr = ::std::os::raw::c_int;
#[doc = " NMSettingConnection:"]
#[doc = ""]
#[doc = " General Connection Profile Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingConnection {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingConnection() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingConnection>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingConnection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingConnection>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingConnection),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingConnectionClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingConnectionClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingConnectionClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingConnectionClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingConnectionClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingConnectionClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMSettingConnectionClass>())).padding as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingConnectionClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_connection_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_connection_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_connection_get_id(
        setting: *mut NMSettingConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_connection_get_uuid(
        setting: *mut NMSettingConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_connection_get_stable_id(
        setting: *mut NMSettingConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_connection_get_interface_name(
        setting: *mut NMSettingConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_connection_get_connection_type(
        setting: *mut NMSettingConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_connection_get_autoconnect(setting: *mut NMSettingConnection) -> gboolean;
}
extern "C" {
    pub fn nm_setting_connection_get_autoconnect_priority(
        setting: *mut NMSettingConnection,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_connection_get_autoconnect_retries(
        setting: *mut NMSettingConnection,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_connection_get_multi_connect(
        setting: *mut NMSettingConnection,
    ) -> NMConnectionMultiConnect;
}
extern "C" {
    pub fn nm_setting_connection_get_timestamp(setting: *mut NMSettingConnection) -> guint64;
}
extern "C" {
    pub fn nm_setting_connection_get_read_only(setting: *mut NMSettingConnection) -> gboolean;
}
extern "C" {
    pub fn nm_setting_connection_get_num_permissions(setting: *mut NMSettingConnection) -> guint32;
}
extern "C" {
    pub fn nm_setting_connection_get_permission(
        setting: *mut NMSettingConnection,
        idx: guint32,
        out_ptype: *mut *const ::std::os::raw::c_char,
        out_pitem: *mut *const ::std::os::raw::c_char,
        out_detail: *mut *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_connection_get_zone(
        setting: *mut NMSettingConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_connection_permissions_user_allowed(
        setting: *mut NMSettingConnection,
        uname: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_connection_add_permission(
        setting: *mut NMSettingConnection,
        ptype: *const ::std::os::raw::c_char,
        pitem: *const ::std::os::raw::c_char,
        detail: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_connection_remove_permission(setting: *mut NMSettingConnection, idx: guint32);
}
extern "C" {
    pub fn nm_setting_connection_remove_permission_by_value(
        setting: *mut NMSettingConnection,
        ptype: *const ::std::os::raw::c_char,
        pitem: *const ::std::os::raw::c_char,
        detail: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_connection_get_master(
        setting: *mut NMSettingConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_connection_is_slave_type(
        setting: *mut NMSettingConnection,
        type_: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_connection_get_slave_type(
        setting: *mut NMSettingConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_connection_get_autoconnect_slaves(
        setting: *mut NMSettingConnection,
    ) -> NMSettingConnectionAutoconnectSlaves;
}
extern "C" {
    pub fn nm_setting_connection_get_num_secondaries(setting: *mut NMSettingConnection) -> guint32;
}
extern "C" {
    pub fn nm_setting_connection_get_secondary(
        setting: *mut NMSettingConnection,
        idx: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_connection_add_secondary(
        setting: *mut NMSettingConnection,
        sec_uuid: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_connection_remove_secondary(setting: *mut NMSettingConnection, idx: guint32);
}
extern "C" {
    pub fn nm_setting_connection_remove_secondary_by_value(
        setting: *mut NMSettingConnection,
        sec_uuid: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_connection_get_gateway_ping_timeout(
        setting: *mut NMSettingConnection,
    ) -> guint32;
}
extern "C" {
    pub fn nm_setting_connection_get_metered(setting: *mut NMSettingConnection) -> NMMetered;
}
extern "C" {
    pub fn nm_setting_connection_get_lldp(
        setting: *mut NMSettingConnection,
    ) -> NMSettingConnectionLldp;
}
extern "C" {
    pub fn nm_setting_connection_get_auth_retries(
        setting: *mut NMSettingConnection,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_connection_get_mdns(
        setting: *mut NMSettingConnection,
    ) -> NMSettingConnectionMdns;
}
extern "C" {
    pub fn nm_setting_connection_get_llmnr(
        setting: *mut NMSettingConnection,
    ) -> NMSettingConnectionLlmnr;
}
extern "C" {
    pub fn nm_setting_connection_get_wait_device_timeout(
        setting: *mut NMSettingConnection,
    ) -> gint32;
}
extern "C" {
    pub fn nm_setting_connection_get_mud_url(
        setting: *mut NMSettingConnection,
    ) -> *const ::std::os::raw::c_char;
}
pub const NMSettingDcbFlags_NM_SETTING_DCB_FLAG_NONE: NMSettingDcbFlags = 0;
pub const NMSettingDcbFlags_NM_SETTING_DCB_FLAG_ENABLE: NMSettingDcbFlags = 1;
pub const NMSettingDcbFlags_NM_SETTING_DCB_FLAG_ADVERTISE: NMSettingDcbFlags = 2;
pub const NMSettingDcbFlags_NM_SETTING_DCB_FLAG_WILLING: NMSettingDcbFlags = 4;
#[doc = " NMSettingDcbFlags:"]
#[doc = " @NM_SETTING_DCB_FLAG_NONE: no flag"]
#[doc = " @NM_SETTING_DCB_FLAG_ENABLE: the feature is enabled"]
#[doc = " @NM_SETTING_DCB_FLAG_ADVERTISE: the feature is advertised"]
#[doc = " @NM_SETTING_DCB_FLAG_WILLING: the feature is willing to change based on"]
#[doc = " peer configuration advertisements"]
#[doc = ""]
#[doc = " DCB feature flags."]
pub type NMSettingDcbFlags = ::std::os::raw::c_uint;
#[doc = " NMSettingDcb:"]
#[doc = ""]
#[doc = " Data Center Bridging Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingDcb {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingDcb() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingDcb>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingDcb))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingDcb>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingDcb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingDcb>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingDcb),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingDcbClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingDcbClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingDcbClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingDcbClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingDcbClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingDcbClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingDcbClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingDcbClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingDcbClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingDcbClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_dcb_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_dcb_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_dcb_get_app_fcoe_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
}
extern "C" {
    pub fn nm_setting_dcb_get_app_fcoe_priority(
        setting: *mut NMSettingDcb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_dcb_get_app_fcoe_mode(
        setting: *mut NMSettingDcb,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_dcb_get_app_iscsi_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
}
extern "C" {
    pub fn nm_setting_dcb_get_app_iscsi_priority(
        setting: *mut NMSettingDcb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_dcb_get_app_fip_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
}
extern "C" {
    pub fn nm_setting_dcb_get_app_fip_priority(setting: *mut NMSettingDcb)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_dcb_get_priority_flow_control_flags(
        setting: *mut NMSettingDcb,
    ) -> NMSettingDcbFlags;
}
extern "C" {
    pub fn nm_setting_dcb_get_priority_flow_control(
        setting: *mut NMSettingDcb,
        user_priority: guint,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_dcb_set_priority_flow_control(
        setting: *mut NMSettingDcb,
        user_priority: guint,
        enabled: gboolean,
    );
}
extern "C" {
    pub fn nm_setting_dcb_get_priority_group_flags(setting: *mut NMSettingDcb)
        -> NMSettingDcbFlags;
}
extern "C" {
    pub fn nm_setting_dcb_get_priority_group_id(
        setting: *mut NMSettingDcb,
        user_priority: guint,
    ) -> guint;
}
extern "C" {
    pub fn nm_setting_dcb_set_priority_group_id(
        setting: *mut NMSettingDcb,
        user_priority: guint,
        group_id: guint,
    );
}
extern "C" {
    pub fn nm_setting_dcb_get_priority_group_bandwidth(
        setting: *mut NMSettingDcb,
        group_id: guint,
    ) -> guint;
}
extern "C" {
    pub fn nm_setting_dcb_set_priority_group_bandwidth(
        setting: *mut NMSettingDcb,
        group_id: guint,
        bandwidth_percent: guint,
    );
}
extern "C" {
    pub fn nm_setting_dcb_get_priority_bandwidth(
        setting: *mut NMSettingDcb,
        user_priority: guint,
    ) -> guint;
}
extern "C" {
    pub fn nm_setting_dcb_set_priority_bandwidth(
        setting: *mut NMSettingDcb,
        user_priority: guint,
        bandwidth_percent: guint,
    );
}
extern "C" {
    pub fn nm_setting_dcb_get_priority_strict_bandwidth(
        setting: *mut NMSettingDcb,
        user_priority: guint,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_dcb_set_priority_strict_bandwidth(
        setting: *mut NMSettingDcb,
        user_priority: guint,
        strict: gboolean,
    );
}
extern "C" {
    pub fn nm_setting_dcb_get_priority_traffic_class(
        setting: *mut NMSettingDcb,
        user_priority: guint,
    ) -> guint;
}
extern "C" {
    pub fn nm_setting_dcb_set_priority_traffic_class(
        setting: *mut NMSettingDcb,
        user_priority: guint,
        traffic_class: guint,
    );
}
#[doc = " NMSettingDummy:"]
#[doc = ""]
#[doc = " Dummy Link Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingDummy {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingDummy() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingDummy>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingDummy))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingDummy>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingDummy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingDummy>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingDummy),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingDummyClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingDummyClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingDummyClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingDummyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingDummyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingDummyClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingDummyClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingDummyClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingDummyClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingDummyClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_dummy_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_dummy_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_ethtool_optname_is_feature(optname: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn nm_ethtool_optname_is_coalesce(optname: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn nm_ethtool_optname_is_ring(optname: *const ::std::os::raw::c_char) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingEthtoolClass {
    _unused: [u8; 0],
}
pub type NMSettingEthtoolClass = _NMSettingEthtoolClass;
extern "C" {
    pub fn nm_setting_ethtool_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ethtool_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ethtool_get_optnames(
        setting: *mut NMSettingEthtool,
        out_length: *mut guint,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ethtool_get_feature(
        setting: *mut NMSettingEthtool,
        optname: *const ::std::os::raw::c_char,
    ) -> NMTernary;
}
extern "C" {
    pub fn nm_setting_ethtool_set_feature(
        setting: *mut NMSettingEthtool,
        optname: *const ::std::os::raw::c_char,
        value: NMTernary,
    );
}
extern "C" {
    pub fn nm_setting_ethtool_clear_features(setting: *mut NMSettingEthtool);
}
#[doc = " NMSettingGeneric:"]
#[doc = ""]
#[doc = " Generic Link Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingGeneric {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingGeneric() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingGeneric>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingGeneric))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingGeneric>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingGeneric))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingGeneric>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingGeneric),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingGenericClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingGenericClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingGenericClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingGenericClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingGenericClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingGenericClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingGenericClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingGenericClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingGenericClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingGenericClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_generic_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_generic_new() -> *mut NMSetting;
}
#[doc = " NMSettingGsm:"]
#[doc = ""]
#[doc = " GSM-based Mobile Broadband Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingGsm {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingGsm() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingGsm>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingGsm))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingGsm>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingGsm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingGsm>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingGsm),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingGsmClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingGsmClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingGsmClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingGsmClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingGsmClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingGsmClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingGsmClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingGsmClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingGsmClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingGsmClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_gsm_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_gsm_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_gsm_get_auto_config(setting: *mut NMSettingGsm) -> gboolean;
}
extern "C" {
    pub fn nm_setting_gsm_get_username(setting: *mut NMSettingGsm)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_gsm_get_password(setting: *mut NMSettingGsm)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_gsm_get_apn(setting: *mut NMSettingGsm) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_gsm_get_network_id(
        setting: *mut NMSettingGsm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_gsm_get_pin(setting: *mut NMSettingGsm) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_gsm_get_home_only(setting: *mut NMSettingGsm) -> gboolean;
}
extern "C" {
    pub fn nm_setting_gsm_get_device_id(
        setting: *mut NMSettingGsm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_gsm_get_sim_id(setting: *mut NMSettingGsm) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_gsm_get_sim_operator_id(
        setting: *mut NMSettingGsm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_gsm_get_mtu(setting: *mut NMSettingGsm) -> guint32;
}
extern "C" {
    pub fn nm_setting_gsm_get_number(setting: *mut NMSettingGsm) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_gsm_get_pin_flags(setting: *mut NMSettingGsm) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_gsm_get_password_flags(setting: *mut NMSettingGsm) -> NMSettingSecretFlags;
}
#[doc = " NMSettingInfiniband:"]
#[doc = ""]
#[doc = " Infiniband Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingInfiniband {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingInfiniband() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingInfiniband>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingInfiniband))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingInfiniband>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingInfiniband))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingInfiniband>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingInfiniband),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingInfinibandClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingInfinibandClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingInfinibandClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingInfinibandClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingInfinibandClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingInfinibandClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingInfinibandClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingInfinibandClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMSettingInfinibandClass>())).padding as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingInfinibandClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_infiniband_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_infiniband_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_infiniband_get_mac_address(
        setting: *mut NMSettingInfiniband,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_infiniband_get_mtu(setting: *mut NMSettingInfiniband) -> guint32;
}
extern "C" {
    pub fn nm_setting_infiniband_get_transport_mode(
        setting: *mut NMSettingInfiniband,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_infiniband_get_p_key(
        setting: *mut NMSettingInfiniband,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_infiniband_get_parent(
        setting: *mut NMSettingInfiniband,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_infiniband_get_virtual_interface_name(
        setting: *mut NMSettingInfiniband,
    ) -> *const ::std::os::raw::c_char;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingSriovClass {
    _unused: [u8; 0],
}
pub type NMSettingSriovClass = _NMSettingSriovClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSriovVF {
    _unused: [u8; 0],
}
pub type NMSriovVF = _NMSriovVF;
pub const NMSriovVFVlanProtocol_NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q: NMSriovVFVlanProtocol = 0;
pub const NMSriovVFVlanProtocol_NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD: NMSriovVFVlanProtocol = 1;
#[doc = " NMSriovVFVlanProtocol:"]
#[doc = " @NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q:  use 802.1Q"]
#[doc = " @NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD: use 802.1ad"]
#[doc = ""]
#[doc = " #NMSriovVFVlanProtocol indicates the VLAN protocol to use."]
#[doc = ""]
#[doc = " Since: 1.14"]
pub type NMSriovVFVlanProtocol = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_setting_sriov_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_sriov_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_sriov_get_total_vfs(setting: *mut NMSettingSriov) -> guint;
}
extern "C" {
    pub fn nm_setting_sriov_get_num_vfs(setting: *mut NMSettingSriov) -> guint;
}
extern "C" {
    pub fn nm_setting_sriov_get_vf(setting: *mut NMSettingSriov, idx: guint) -> *mut NMSriovVF;
}
extern "C" {
    pub fn nm_setting_sriov_add_vf(setting: *mut NMSettingSriov, vf: *mut NMSriovVF);
}
extern "C" {
    pub fn nm_setting_sriov_remove_vf(setting: *mut NMSettingSriov, idx: guint);
}
extern "C" {
    pub fn nm_setting_sriov_remove_vf_by_index(
        setting: *mut NMSettingSriov,
        index: guint,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_sriov_clear_vfs(setting: *mut NMSettingSriov);
}
extern "C" {
    pub fn nm_setting_sriov_get_autoprobe_drivers(setting: *mut NMSettingSriov) -> NMTernary;
}
extern "C" {
    pub fn nm_sriov_vf_add_vlan(vf: *mut NMSriovVF, vlan_id: guint) -> gboolean;
}
extern "C" {
    pub fn nm_sriov_vf_remove_vlan(vf: *mut NMSriovVF, vlan_id: guint) -> gboolean;
}
extern "C" {
    pub fn nm_sriov_vf_get_vlan_ids(vf: *const NMSriovVF, length: *mut guint) -> *const guint;
}
extern "C" {
    pub fn nm_sriov_vf_set_vlan_qos(vf: *mut NMSriovVF, vlan_id: guint, qos: guint32);
}
extern "C" {
    pub fn nm_sriov_vf_set_vlan_protocol(
        vf: *mut NMSriovVF,
        vlan_id: guint,
        protocol: NMSriovVFVlanProtocol,
    );
}
extern "C" {
    pub fn nm_sriov_vf_get_vlan_qos(vf: *const NMSriovVF, vlan_id: guint) -> guint32;
}
extern "C" {
    pub fn nm_sriov_vf_get_vlan_protocol(
        vf: *const NMSriovVF,
        vlan_id: guint,
    ) -> NMSriovVFVlanProtocol;
}
extern "C" {
    pub fn nm_sriov_vf_get_type() -> GType;
}
extern "C" {
    pub fn nm_sriov_vf_new(index: guint) -> *mut NMSriovVF;
}
extern "C" {
    pub fn nm_sriov_vf_ref(vf: *mut NMSriovVF);
}
extern "C" {
    pub fn nm_sriov_vf_unref(vf: *mut NMSriovVF);
}
extern "C" {
    pub fn nm_sriov_vf_equal(vf: *const NMSriovVF, other: *const NMSriovVF) -> gboolean;
}
extern "C" {
    pub fn nm_sriov_vf_dup(vf: *const NMSriovVF) -> *mut NMSriovVF;
}
extern "C" {
    pub fn nm_sriov_vf_get_index(vf: *const NMSriovVF) -> guint;
}
extern "C" {
    pub fn nm_sriov_vf_set_attribute(
        vf: *mut NMSriovVF,
        name: *const ::std::os::raw::c_char,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn nm_sriov_vf_get_attribute_names(
        vf: *const NMSriovVF,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_sriov_vf_get_attribute(
        vf: *const NMSriovVF,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_sriov_vf_attribute_validate(
        name: *const ::std::os::raw::c_char,
        value: *mut GVariant,
        known: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMTCQdisc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nm_tc_qdisc_get_type() -> GType;
}
extern "C" {
    pub fn nm_tc_qdisc_new(
        kind: *const ::std::os::raw::c_char,
        parent: guint32,
        error: *mut *mut GError,
    ) -> *mut NMTCQdisc;
}
extern "C" {
    pub fn nm_tc_qdisc_ref(qdisc: *mut NMTCQdisc);
}
extern "C" {
    pub fn nm_tc_qdisc_unref(qdisc: *mut NMTCQdisc);
}
extern "C" {
    pub fn nm_tc_qdisc_equal(qdisc: *mut NMTCQdisc, other: *mut NMTCQdisc) -> gboolean;
}
extern "C" {
    pub fn nm_tc_qdisc_dup(qdisc: *mut NMTCQdisc) -> *mut NMTCQdisc;
}
extern "C" {
    pub fn nm_tc_qdisc_get_kind(qdisc: *mut NMTCQdisc) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_tc_qdisc_get_handle(qdisc: *mut NMTCQdisc) -> guint32;
}
extern "C" {
    pub fn nm_tc_qdisc_set_handle(qdisc: *mut NMTCQdisc, handle: guint32);
}
extern "C" {
    pub fn nm_tc_qdisc_get_parent(qdisc: *mut NMTCQdisc) -> guint32;
}
extern "C" {
    pub fn nm_tc_qdisc_get_attribute_names(
        qdisc: *mut NMTCQdisc,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_tc_qdisc_get_attribute(
        qdisc: *mut NMTCQdisc,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_tc_qdisc_set_attribute(
        qdisc: *mut NMTCQdisc,
        name: *const ::std::os::raw::c_char,
        value: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMTCAction {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nm_tc_action_get_type() -> GType;
}
extern "C" {
    pub fn nm_tc_action_new(
        kind: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMTCAction;
}
extern "C" {
    pub fn nm_tc_action_ref(action: *mut NMTCAction);
}
extern "C" {
    pub fn nm_tc_action_unref(action: *mut NMTCAction);
}
extern "C" {
    pub fn nm_tc_action_equal(action: *mut NMTCAction, other: *mut NMTCAction) -> gboolean;
}
extern "C" {
    pub fn nm_tc_action_dup(action: *mut NMTCAction) -> *mut NMTCAction;
}
extern "C" {
    pub fn nm_tc_action_get_kind(action: *mut NMTCAction) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_tc_action_get_attribute_names(
        action: *mut NMTCAction,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_tc_action_get_attribute(
        action: *mut NMTCAction,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_tc_action_set_attribute(
        action: *mut NMTCAction,
        name: *const ::std::os::raw::c_char,
        value: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMTCTfilter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nm_tc_tfilter_get_type() -> GType;
}
extern "C" {
    pub fn nm_tc_tfilter_new(
        kind: *const ::std::os::raw::c_char,
        parent: guint32,
        error: *mut *mut GError,
    ) -> *mut NMTCTfilter;
}
extern "C" {
    pub fn nm_tc_tfilter_ref(tfilter: *mut NMTCTfilter);
}
extern "C" {
    pub fn nm_tc_tfilter_unref(tfilter: *mut NMTCTfilter);
}
extern "C" {
    pub fn nm_tc_tfilter_equal(tfilter: *mut NMTCTfilter, other: *mut NMTCTfilter) -> gboolean;
}
extern "C" {
    pub fn nm_tc_tfilter_dup(tfilter: *mut NMTCTfilter) -> *mut NMTCTfilter;
}
extern "C" {
    pub fn nm_tc_tfilter_get_kind(tfilter: *mut NMTCTfilter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_tc_tfilter_get_handle(tfilter: *mut NMTCTfilter) -> guint32;
}
extern "C" {
    pub fn nm_tc_tfilter_set_handle(tfilter: *mut NMTCTfilter, handle: guint32);
}
extern "C" {
    pub fn nm_tc_tfilter_get_parent(tfilter: *mut NMTCTfilter) -> guint32;
}
extern "C" {
    pub fn nm_tc_tfilter_get_action(tfilter: *mut NMTCTfilter) -> *mut NMTCAction;
}
extern "C" {
    pub fn nm_tc_tfilter_set_action(tfilter: *mut NMTCTfilter, action: *mut NMTCAction);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingTCConfigClass {
    _unused: [u8; 0],
}
pub type NMSettingTCConfigClass = _NMSettingTCConfigClass;
extern "C" {
    pub fn nm_setting_tc_config_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_tc_config_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_tc_config_get_num_qdiscs(setting: *mut NMSettingTCConfig) -> guint;
}
extern "C" {
    pub fn nm_setting_tc_config_get_qdisc(
        setting: *mut NMSettingTCConfig,
        idx: guint,
    ) -> *mut NMTCQdisc;
}
extern "C" {
    pub fn nm_setting_tc_config_add_qdisc(
        setting: *mut NMSettingTCConfig,
        qdisc: *mut NMTCQdisc,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_tc_config_remove_qdisc(setting: *mut NMSettingTCConfig, idx: guint);
}
extern "C" {
    pub fn nm_setting_tc_config_remove_qdisc_by_value(
        setting: *mut NMSettingTCConfig,
        qdisc: *mut NMTCQdisc,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_tc_config_clear_qdiscs(setting: *mut NMSettingTCConfig);
}
extern "C" {
    pub fn nm_setting_tc_config_get_num_tfilters(setting: *mut NMSettingTCConfig) -> guint;
}
extern "C" {
    pub fn nm_setting_tc_config_get_tfilter(
        setting: *mut NMSettingTCConfig,
        idx: guint,
    ) -> *mut NMTCTfilter;
}
extern "C" {
    pub fn nm_setting_tc_config_add_tfilter(
        setting: *mut NMSettingTCConfig,
        tfilter: *mut NMTCTfilter,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_tc_config_remove_tfilter(setting: *mut NMSettingTCConfig, idx: guint);
}
extern "C" {
    pub fn nm_setting_tc_config_remove_tfilter_by_value(
        setting: *mut NMSettingTCConfig,
        tfilter: *mut NMTCTfilter,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_tc_config_clear_tfilters(setting: *mut NMSettingTCConfig);
}
pub const NMWepKeyType_NM_WEP_KEY_TYPE_UNKNOWN: NMWepKeyType = 0;
pub const NMWepKeyType_NM_WEP_KEY_TYPE_KEY: NMWepKeyType = 1;
pub const NMWepKeyType_NM_WEP_KEY_TYPE_PASSPHRASE: NMWepKeyType = 2;
pub const NMWepKeyType_NM_WEP_KEY_TYPE_LAST: NMWepKeyType = 2;
#[doc = " NMWepKeyType:"]
#[doc = " @NM_WEP_KEY_TYPE_UNKNOWN: unknown WEP key type"]
#[doc = " @NM_WEP_KEY_TYPE_KEY: indicates a hexadecimal or ASCII formatted WEP key."]
#[doc = " Hex keys are either 10 or 26 hexadecimal characters (ie \"5f782f2f5f\" or"]
#[doc = " \"732f2d712e4a394a375d366931\"), while ASCII keys are either 5 or 13 ASCII"]
#[doc = " characters (ie \"abcde\" or \"blahblah99$*1\")."]
#[doc = " @NM_WEP_KEY_TYPE_PASSPHRASE: indicates a WEP passphrase (ex \"I bought a duck"]
#[doc = " on my way back from the market 235Q&^%^*%\") instead of a hexadecimal or ASCII"]
#[doc = " key.  Passphrases are between 8 and 64 characters inclusive and are hashed"]
#[doc = " the actual WEP key using the MD5 hash algorithm."]
#[doc = " @NM_WEP_KEY_TYPE_LAST: placeholder value for bounds-checking"]
#[doc = ""]
#[doc = " The #NMWepKeyType values specify how any WEP keys present in the setting"]
#[doc = " are interpreted.  There are no standards governing how to hash the various WEP"]
#[doc = " key/passphrase formats into the actual WEP key.  Unfortunately some WEP keys"]
#[doc = " can be interpreted in multiple ways, requiring the setting to specify how to"]
#[doc = " interpret the any WEP keys.  For example, the key \"732f2d712e4a394a375d366931\""]
#[doc = " is both a valid Hexadecimal WEP key and a WEP passphrase.  Further, many"]
#[doc = " ASCII keys are also valid WEP passphrases, but since passphrases and ASCII"]
#[doc = " keys are hashed differently to determine the actual WEP key the type must be"]
#[doc = " specified."]
pub type NMWepKeyType = ::std::os::raw::c_uint;
pub const NMSettingWirelessSecurityPmf_NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT:
    NMSettingWirelessSecurityPmf = 0;
pub const NMSettingWirelessSecurityPmf_NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE:
    NMSettingWirelessSecurityPmf = 1;
pub const NMSettingWirelessSecurityPmf_NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL:
    NMSettingWirelessSecurityPmf = 2;
pub const NMSettingWirelessSecurityPmf_NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED:
    NMSettingWirelessSecurityPmf = 3;
pub const NMSettingWirelessSecurityPmf__NM_SETTING_WIRELESS_SECURITY_PMF_NUM:
    NMSettingWirelessSecurityPmf = 4;
pub const NMSettingWirelessSecurityPmf_NM_SETTING_WIRELESS_SECURITY_PMF_LAST:
    NMSettingWirelessSecurityPmf = 3;
#[doc = " NMSettingWirelessSecurityPmf:"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT: use the default value"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE: disable PMF"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL: enable PMF if the supplicant and the AP support it"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED: require PMF and fail if not available"]
#[doc = ""]
#[doc = " These flags indicate whether PMF must be enabled."]
pub type NMSettingWirelessSecurityPmf = ::std::os::raw::c_uint;
pub const NMSettingWirelessSecurityWpsMethod_NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT:
    NMSettingWirelessSecurityWpsMethod = 0;
pub const NMSettingWirelessSecurityWpsMethod_NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DISABLED:
    NMSettingWirelessSecurityWpsMethod = 1;
pub const NMSettingWirelessSecurityWpsMethod_NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_AUTO:
    NMSettingWirelessSecurityWpsMethod = 2;
pub const NMSettingWirelessSecurityWpsMethod_NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PBC:
    NMSettingWirelessSecurityWpsMethod = 4;
pub const NMSettingWirelessSecurityWpsMethod_NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PIN:
    NMSettingWirelessSecurityWpsMethod = 8;
#[doc = " NMSettingWirelessSecurityWpsMethod:"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT: Attempt whichever method AP supports"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DISABLED: WPS can not be used."]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_AUTO: Use WPS, any method"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PBC: use WPS push-buthon method"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PIN: use PIN method"]
#[doc = ""]
#[doc = " Configure the use of WPS by a connection while it activates."]
#[doc = ""]
#[doc = " Note: prior to 1.16, this was a GEnum type instead of a GFlags type"]
#[doc = " although, with the same numeric values."]
#[doc = ""]
#[doc = " Since: 1.10"]
pub type NMSettingWirelessSecurityWpsMethod = ::std::os::raw::c_uint;
pub const NMSettingWirelessSecurityFils_NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT:
    NMSettingWirelessSecurityFils = 0;
pub const NMSettingWirelessSecurityFils_NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE:
    NMSettingWirelessSecurityFils = 1;
pub const NMSettingWirelessSecurityFils_NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL:
    NMSettingWirelessSecurityFils = 2;
pub const NMSettingWirelessSecurityFils_NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED:
    NMSettingWirelessSecurityFils = 3;
pub const NMSettingWirelessSecurityFils__NM_SETTING_WIRELESS_SECURITY_FILS_NUM:
    NMSettingWirelessSecurityFils = 4;
pub const NMSettingWirelessSecurityFils_NM_SETTING_WIRELESS_SECURITY_FILS_LAST:
    NMSettingWirelessSecurityFils = 3;
#[doc = " NMSettingWirelessSecurityFils:"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT: use the default value"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE: disable FILS"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL: enable FILS if the supplicant and the AP support it"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED: require FILS and fail if not available"]
#[doc = " @_NM_SETTING_WIRELESS_SECURITY_FILS_NUM: placeholder value for bounds-checking"]
#[doc = " @NM_SETTING_WIRELESS_SECURITY_FILS_LAST: placeholder value for bounds-checking"]
#[doc = ""]
#[doc = " These flags indicate whether FILS must be enabled."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type NMSettingWirelessSecurityFils = ::std::os::raw::c_uint;
#[doc = " NMSettingWirelessSecurity:"]
#[doc = ""]
#[doc = " Wi-Fi Security Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWirelessSecurity {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingWirelessSecurity() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingWirelessSecurity>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingWirelessSecurity))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingWirelessSecurity>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingWirelessSecurity))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NMSettingWirelessSecurity>())).parent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingWirelessSecurity),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingWirelessSecurityClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingWirelessSecurityClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingWirelessSecurityClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingWirelessSecurityClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingWirelessSecurityClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingWirelessSecurityClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMSettingWirelessSecurityClass>())).parent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingWirelessSecurityClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMSettingWirelessSecurityClass>())).padding as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingWirelessSecurityClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_wireless_security_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wireless_security_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_key_mgmt(
        setting: *mut NMSettingWirelessSecurity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_num_protos(
        setting: *mut NMSettingWirelessSecurity,
    ) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_proto(
        setting: *mut NMSettingWirelessSecurity,
        i: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_security_add_proto(
        setting: *mut NMSettingWirelessSecurity,
        proto: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_security_remove_proto(
        setting: *mut NMSettingWirelessSecurity,
        i: guint32,
    );
}
extern "C" {
    pub fn nm_setting_wireless_security_remove_proto_by_value(
        setting: *mut NMSettingWirelessSecurity,
        proto: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_security_clear_protos(setting: *mut NMSettingWirelessSecurity);
}
extern "C" {
    pub fn nm_setting_wireless_security_get_num_pairwise(
        setting: *mut NMSettingWirelessSecurity,
    ) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_pairwise(
        setting: *mut NMSettingWirelessSecurity,
        i: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_security_add_pairwise(
        setting: *mut NMSettingWirelessSecurity,
        pairwise: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_security_remove_pairwise(
        setting: *mut NMSettingWirelessSecurity,
        i: guint32,
    );
}
extern "C" {
    pub fn nm_setting_wireless_security_remove_pairwise_by_value(
        setting: *mut NMSettingWirelessSecurity,
        pairwise: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_security_clear_pairwise(setting: *mut NMSettingWirelessSecurity);
}
extern "C" {
    pub fn nm_setting_wireless_security_get_num_groups(
        setting: *mut NMSettingWirelessSecurity,
    ) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_group(
        setting: *mut NMSettingWirelessSecurity,
        i: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_security_add_group(
        setting: *mut NMSettingWirelessSecurity,
        group: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_security_remove_group(
        setting: *mut NMSettingWirelessSecurity,
        i: guint32,
    );
}
extern "C" {
    pub fn nm_setting_wireless_security_remove_group_by_value(
        setting: *mut NMSettingWirelessSecurity,
        group: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_security_clear_groups(setting: *mut NMSettingWirelessSecurity);
}
extern "C" {
    pub fn nm_setting_wireless_security_get_pmf(
        setting: *mut NMSettingWirelessSecurity,
    ) -> NMSettingWirelessSecurityPmf;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_psk(
        setting: *mut NMSettingWirelessSecurity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_psk_flags(
        setting: *mut NMSettingWirelessSecurity,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_leap_username(
        setting: *mut NMSettingWirelessSecurity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_leap_password(
        setting: *mut NMSettingWirelessSecurity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_leap_password_flags(
        setting: *mut NMSettingWirelessSecurity,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_wep_key(
        setting: *mut NMSettingWirelessSecurity,
        idx: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_security_set_wep_key(
        setting: *mut NMSettingWirelessSecurity,
        idx: guint32,
        key: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_setting_wireless_security_get_wep_tx_keyidx(
        setting: *mut NMSettingWirelessSecurity,
    ) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_auth_alg(
        setting: *mut NMSettingWirelessSecurity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_wep_key_flags(
        setting: *mut NMSettingWirelessSecurity,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_wep_key_type(
        setting: *mut NMSettingWirelessSecurity,
    ) -> NMWepKeyType;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_wps_method(
        setting: *mut NMSettingWirelessSecurity,
    ) -> NMSettingWirelessSecurityWpsMethod;
}
extern "C" {
    pub fn nm_setting_wireless_security_get_fils(
        setting: *mut NMSettingWirelessSecurity,
    ) -> NMSettingWirelessSecurityFils;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVariantAttributeSpec {
    _unused: [u8; 0],
}
pub type NMVariantAttributeSpec = _NMVariantAttributeSpec;
extern "C" {
    pub fn nm_utils_is_empty_ssid(ssid: *const guint8, len: gsize) -> gboolean;
}
extern "C" {
    pub fn nm_utils_escape_ssid(ssid: *const guint8, len: gsize) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_same_ssid(
        ssid1: *const guint8,
        len1: gsize,
        ssid2: *const guint8,
        len2: gsize,
        ignore_trailing_null: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_ssid_to_utf8(ssid: *const guint8, len: gsize) -> *mut ::std::os::raw::c_char;
}
pub const NMUtilsSecurityType_NMU_SEC_INVALID: NMUtilsSecurityType = 0;
pub const NMUtilsSecurityType_NMU_SEC_NONE: NMUtilsSecurityType = 1;
pub const NMUtilsSecurityType_NMU_SEC_STATIC_WEP: NMUtilsSecurityType = 2;
pub const NMUtilsSecurityType_NMU_SEC_LEAP: NMUtilsSecurityType = 3;
pub const NMUtilsSecurityType_NMU_SEC_DYNAMIC_WEP: NMUtilsSecurityType = 4;
pub const NMUtilsSecurityType_NMU_SEC_WPA_PSK: NMUtilsSecurityType = 5;
pub const NMUtilsSecurityType_NMU_SEC_WPA_ENTERPRISE: NMUtilsSecurityType = 6;
pub const NMUtilsSecurityType_NMU_SEC_WPA2_PSK: NMUtilsSecurityType = 7;
pub const NMUtilsSecurityType_NMU_SEC_WPA2_ENTERPRISE: NMUtilsSecurityType = 8;
pub const NMUtilsSecurityType_NMU_SEC_SAE: NMUtilsSecurityType = 9;
pub const NMUtilsSecurityType_NMU_SEC_OWE: NMUtilsSecurityType = 10;
#[doc = " NMUtilsSecurityType:"]
#[doc = " @NMU_SEC_INVALID: unknown or invalid security, placeholder and not used"]
#[doc = " @NMU_SEC_NONE: unencrypted and open"]
#[doc = " @NMU_SEC_STATIC_WEP: static WEP keys are used for encryption"]
#[doc = " @NMU_SEC_LEAP: Cisco LEAP is used for authentication and for generating the"]
#[doc = " dynamic WEP keys automatically"]
#[doc = " @NMU_SEC_DYNAMIC_WEP: standard 802.1x is used for authentication and"]
#[doc = " generating the dynamic WEP keys automatically"]
#[doc = " @NMU_SEC_WPA_PSK: WPA1 is used with Pre-Shared Keys (PSK)"]
#[doc = " @NMU_SEC_WPA_ENTERPRISE: WPA1 is used with 802.1x authentication"]
#[doc = " @NMU_SEC_WPA2_PSK: WPA2/RSN is used with Pre-Shared Keys (PSK)"]
#[doc = " @NMU_SEC_WPA2_ENTERPRISE: WPA2 is used with 802.1x authentication"]
#[doc = " @NMU_SEC_SAE: is used with WPA3 Enterprise"]
#[doc = " @NMU_SEC_OWE: is used with Enhanced Open"]
#[doc = ""]
#[doc = " Describes generic security mechanisms that 802.11 access points may offer."]
#[doc = " Used with nm_utils_security_valid() for checking whether a given access"]
#[doc = " point is compatible with a network device."]
pub type NMUtilsSecurityType = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_utils_security_valid(
        type_: NMUtilsSecurityType,
        wifi_caps: NMDeviceWifiCapabilities,
        have_ap: gboolean,
        adhoc: gboolean,
        ap_flags: NM80211ApFlags,
        ap_wpa: NM80211ApSecurityFlags,
        ap_rsn: NM80211ApSecurityFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_ap_mode_security_valid(
        type_: NMUtilsSecurityType,
        wifi_caps: NMDeviceWifiCapabilities,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_wep_key_valid(
        key: *const ::std::os::raw::c_char,
        wep_type: NMWepKeyType,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_wpa_psk_valid(psk: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn nm_utils_is_json_object(
        str_: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_ip4_dns_to_variant(dns: *mut *mut ::std::os::raw::c_char) -> *mut GVariant;
}
extern "C" {
    pub fn nm_utils_ip4_dns_from_variant(value: *mut GVariant) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_ip4_addresses_to_variant(
        addresses: *mut GPtrArray,
        gateway: *const ::std::os::raw::c_char,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_utils_ip4_addresses_from_variant(
        value: *mut GVariant,
        out_gateway: *mut *mut ::std::os::raw::c_char,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_utils_ip4_routes_to_variant(routes: *mut GPtrArray) -> *mut GVariant;
}
extern "C" {
    pub fn nm_utils_ip4_routes_from_variant(value: *mut GVariant) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_utils_ip4_netmask_to_prefix(netmask: guint32) -> guint32;
}
extern "C" {
    pub fn nm_utils_ip4_prefix_to_netmask(prefix: guint32) -> guint32;
}
extern "C" {
    pub fn nm_utils_ip4_get_default_prefix(ip: guint32) -> guint32;
}
extern "C" {
    pub fn nm_utils_ip6_dns_to_variant(dns: *mut *mut ::std::os::raw::c_char) -> *mut GVariant;
}
extern "C" {
    pub fn nm_utils_ip6_dns_from_variant(value: *mut GVariant) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_ip6_addresses_to_variant(
        addresses: *mut GPtrArray,
        gateway: *const ::std::os::raw::c_char,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_utils_ip6_addresses_from_variant(
        value: *mut GVariant,
        out_gateway: *mut *mut ::std::os::raw::c_char,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_utils_ip6_routes_to_variant(routes: *mut GPtrArray) -> *mut GVariant;
}
extern "C" {
    pub fn nm_utils_ip6_routes_from_variant(value: *mut GVariant) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_utils_ip_addresses_to_variant(addresses: *mut GPtrArray) -> *mut GVariant;
}
extern "C" {
    pub fn nm_utils_ip_addresses_from_variant(
        value: *mut GVariant,
        family: ::std::os::raw::c_int,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_utils_ip_routes_to_variant(routes: *mut GPtrArray) -> *mut GVariant;
}
extern "C" {
    pub fn nm_utils_ip_routes_from_variant(
        value: *mut GVariant,
        family: ::std::os::raw::c_int,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_utils_uuid_generate() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_file_is_certificate(filename: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn nm_utils_file_is_private_key(
        filename: *const ::std::os::raw::c_char,
        out_encrypted: *mut gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_file_is_pkcs12(filename: *const ::std::os::raw::c_char) -> gboolean;
}
pub type NMUtilsFileSearchInPathsPredicate = ::std::option::Option<
    unsafe extern "C" fn(filename: *const ::std::os::raw::c_char, user_data: gpointer) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    _unused: [u8; 0],
}
pub type NMUtilsCheckFilePredicate = ::std::option::Option<
    unsafe extern "C" fn(
        filename: *const ::std::os::raw::c_char,
        stat: *const stat,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
extern "C" {
    pub fn nm_utils_file_search_in_paths(
        progname: *const ::std::os::raw::c_char,
        try_first: *const ::std::os::raw::c_char,
        paths: *const *const ::std::os::raw::c_char,
        file_test_flags: GFileTest,
        predicate: NMUtilsFileSearchInPathsPredicate,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_wifi_freq_to_channel(freq: guint32) -> guint32;
}
extern "C" {
    pub fn nm_utils_wifi_channel_to_freq(
        channel: guint32,
        band: *const ::std::os::raw::c_char,
    ) -> guint32;
}
extern "C" {
    pub fn nm_utils_wifi_find_next_channel(
        channel: guint32,
        direction: ::std::os::raw::c_int,
        band: *mut ::std::os::raw::c_char,
    ) -> guint32;
}
extern "C" {
    pub fn nm_utils_wifi_is_channel_valid(
        channel: guint32,
        band: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_wifi_2ghz_freqs() -> *const guint;
}
extern "C" {
    pub fn nm_utils_wifi_5ghz_freqs() -> *const guint;
}
extern "C" {
    pub fn nm_utils_wifi_strength_bars(strength: guint8) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_hwaddr_len(type_: ::std::os::raw::c_int) -> gsize;
}
extern "C" {
    pub fn nm_utils_hwaddr_ntoa(addr: gconstpointer, length: gsize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_hwaddr_atoba(
        asc: *const ::std::os::raw::c_char,
        length: gsize,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn nm_utils_hwaddr_aton(
        asc: *const ::std::os::raw::c_char,
        buffer: gpointer,
        length: gsize,
    ) -> *mut guint8;
}
extern "C" {
    pub fn nm_utils_hwaddr_valid(asc: *const ::std::os::raw::c_char, length: gssize) -> gboolean;
}
extern "C" {
    pub fn nm_utils_hwaddr_canonical(
        asc: *const ::std::os::raw::c_char,
        length: gssize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_hwaddr_matches(
        hwaddr1: gconstpointer,
        hwaddr1_len: gssize,
        hwaddr2: gconstpointer,
        hwaddr2_len: gssize,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_bin2hexstr(
        src: gconstpointer,
        len: gsize,
        final_len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_hexstr2bin(hex: *const ::std::os::raw::c_char) -> *mut GBytes;
}
extern "C" {
    pub fn nm_utils_iface_valid_name(name: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn nm_utils_is_valid_iface_name(
        name: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_is_uuid(str_: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn nm_utils_inet4_ntop(
        inaddr: in_addr_t,
        dst: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_inet6_ntop(
        in6addr: *const in6_addr,
        dst: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_ipaddr_valid(
        family: ::std::os::raw::c_int,
        ip: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_check_virtual_device_compatibility(
        virtual_type: GType,
        other_type: GType,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_bond_mode_string_to_int(
        mode: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_utils_bond_mode_int_to_string(
        mode: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_enum_to_str(
        type_: GType,
        value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_enum_from_str(
        type_: GType,
        str_: *const ::std::os::raw::c_char,
        out_value: *mut ::std::os::raw::c_int,
        err_token: *mut *mut ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_utils_enum_get_values(
        type_: GType,
        from: ::std::os::raw::c_int,
        to: ::std::os::raw::c_int,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_version() -> guint;
}
extern "C" {
    pub fn nm_utils_parse_variant_attributes(
        string: *const ::std::os::raw::c_char,
        attr_separator: ::std::os::raw::c_char,
        key_value_separator: ::std::os::raw::c_char,
        ignore_unknown: gboolean,
        spec: *const *const NMVariantAttributeSpec,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
}
extern "C" {
    pub fn nm_utils_format_variant_attributes(
        attributes: *mut GHashTable,
        attr_separator: ::std::os::raw::c_char,
        key_value_separator: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_tc_qdisc_from_str(
        str_: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMTCQdisc;
}
extern "C" {
    pub fn nm_utils_tc_qdisc_to_str(
        qdisc: *mut NMTCQdisc,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_tc_action_from_str(
        str_: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMTCAction;
}
extern "C" {
    pub fn nm_utils_tc_action_to_str(
        action: *mut NMTCAction,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_tc_tfilter_from_str(
        str_: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMTCTfilter;
}
extern "C" {
    pub fn nm_utils_tc_tfilter_to_str(
        tfilter: *mut NMTCTfilter,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_sriov_vf_to_str(
        vf: *const NMSriovVF,
        omit_index: gboolean,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_utils_sriov_vf_from_str(
        str_: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMSriovVF;
}
extern "C" {
    pub fn nm_utils_get_timestamp_msec() -> gint64;
}
extern "C" {
    pub fn nm_utils_base64secret_decode(
        base64_key: *const ::std::os::raw::c_char,
        required_key_len: gsize,
        out_key: *mut guint8,
    ) -> gboolean;
}
pub const NMIPAddressCmpFlags_NM_IP_ADDRESS_CMP_FLAGS_NONE: NMIPAddressCmpFlags = 0;
pub const NMIPAddressCmpFlags_NM_IP_ADDRESS_CMP_FLAGS_WITH_ATTRS: NMIPAddressCmpFlags = 1;
#[doc = " NMIPAddressCmpFlags:"]
#[doc = " @NM_IP_ADDRESS_CMP_FLAGS_NONE: no flags."]
#[doc = " @NM_IP_ADDRESS_CMP_FLAGS_WITH_ATTRS: when comparing two addresses,"]
#[doc = "   also consider their attributes. Warning: note that attributes are GVariants"]
#[doc = "   and they don't have a total order. In other words, if the address differs only"]
#[doc = "   by their attributes, the returned compare order is not total. In that case,"]
#[doc = "   the return value merely indicates equality (zero) or inequality."]
#[doc = ""]
#[doc = " Compare flags for nm_ip_address_cmp_full()."]
#[doc = ""]
#[doc = " Since: 1.22"]
pub type NMIPAddressCmpFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMIPAddress {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nm_ip_address_get_type() -> GType;
}
extern "C" {
    pub fn nm_ip_address_new(
        family: ::std::os::raw::c_int,
        addr: *const ::std::os::raw::c_char,
        prefix: guint,
        error: *mut *mut GError,
    ) -> *mut NMIPAddress;
}
extern "C" {
    pub fn nm_ip_address_new_binary(
        family: ::std::os::raw::c_int,
        addr: gconstpointer,
        prefix: guint,
        error: *mut *mut GError,
    ) -> *mut NMIPAddress;
}
extern "C" {
    pub fn nm_ip_address_ref(address: *mut NMIPAddress);
}
extern "C" {
    pub fn nm_ip_address_unref(address: *mut NMIPAddress);
}
extern "C" {
    pub fn nm_ip_address_equal(address: *mut NMIPAddress, other: *mut NMIPAddress) -> gboolean;
}
extern "C" {
    pub fn nm_ip_address_cmp_full(
        a: *const NMIPAddress,
        b: *const NMIPAddress,
        cmp_flags: NMIPAddressCmpFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_ip_address_dup(address: *mut NMIPAddress) -> *mut NMIPAddress;
}
extern "C" {
    pub fn nm_ip_address_get_family(address: *mut NMIPAddress) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_ip_address_get_address(address: *mut NMIPAddress) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_address_set_address(
        address: *mut NMIPAddress,
        addr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_ip_address_get_address_binary(address: *mut NMIPAddress, addr: gpointer);
}
extern "C" {
    pub fn nm_ip_address_set_address_binary(address: *mut NMIPAddress, addr: gconstpointer);
}
extern "C" {
    pub fn nm_ip_address_get_prefix(address: *mut NMIPAddress) -> guint;
}
extern "C" {
    pub fn nm_ip_address_set_prefix(address: *mut NMIPAddress, prefix: guint);
}
extern "C" {
    pub fn nm_ip_address_get_attribute_names(
        address: *mut NMIPAddress,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_address_get_attribute(
        address: *mut NMIPAddress,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_ip_address_set_attribute(
        address: *mut NMIPAddress,
        name: *const ::std::os::raw::c_char,
        value: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMIPRoute {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nm_ip_route_get_type() -> GType;
}
extern "C" {
    pub fn nm_ip_route_new(
        family: ::std::os::raw::c_int,
        dest: *const ::std::os::raw::c_char,
        prefix: guint,
        next_hop: *const ::std::os::raw::c_char,
        metric: gint64,
        error: *mut *mut GError,
    ) -> *mut NMIPRoute;
}
extern "C" {
    pub fn nm_ip_route_new_binary(
        family: ::std::os::raw::c_int,
        dest: gconstpointer,
        prefix: guint,
        next_hop: gconstpointer,
        metric: gint64,
        error: *mut *mut GError,
    ) -> *mut NMIPRoute;
}
extern "C" {
    pub fn nm_ip_route_ref(route: *mut NMIPRoute);
}
extern "C" {
    pub fn nm_ip_route_unref(route: *mut NMIPRoute);
}
extern "C" {
    pub fn nm_ip_route_equal(route: *mut NMIPRoute, other: *mut NMIPRoute) -> gboolean;
}
pub const NM_IP_ROUTE_EQUAL_CMP_FLAGS_NONE: ::std::os::raw::c_uint = 0;
pub const NM_IP_ROUTE_EQUAL_CMP_FLAGS_WITH_ATTRS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_ip_route_equal_full(
        route: *mut NMIPRoute,
        other: *mut NMIPRoute,
        cmp_flags: guint,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_ip_route_dup(route: *mut NMIPRoute) -> *mut NMIPRoute;
}
extern "C" {
    pub fn nm_ip_route_get_family(route: *mut NMIPRoute) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_ip_route_get_dest(route: *mut NMIPRoute) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_route_set_dest(route: *mut NMIPRoute, dest: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nm_ip_route_get_dest_binary(route: *mut NMIPRoute, dest: gpointer);
}
extern "C" {
    pub fn nm_ip_route_set_dest_binary(route: *mut NMIPRoute, dest: gconstpointer);
}
extern "C" {
    pub fn nm_ip_route_get_prefix(route: *mut NMIPRoute) -> guint;
}
extern "C" {
    pub fn nm_ip_route_set_prefix(route: *mut NMIPRoute, prefix: guint);
}
extern "C" {
    pub fn nm_ip_route_get_next_hop(route: *mut NMIPRoute) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_route_set_next_hop(route: *mut NMIPRoute, next_hop: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nm_ip_route_get_next_hop_binary(route: *mut NMIPRoute, next_hop: gpointer) -> gboolean;
}
extern "C" {
    pub fn nm_ip_route_set_next_hop_binary(route: *mut NMIPRoute, next_hop: gconstpointer);
}
extern "C" {
    pub fn nm_ip_route_get_metric(route: *mut NMIPRoute) -> gint64;
}
extern "C" {
    pub fn nm_ip_route_set_metric(route: *mut NMIPRoute, metric: gint64);
}
extern "C" {
    pub fn nm_ip_route_get_attribute_names(
        route: *mut NMIPRoute,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_route_get_attribute(
        route: *mut NMIPRoute,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn nm_ip_route_set_attribute(
        route: *mut NMIPRoute,
        name: *const ::std::os::raw::c_char,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn nm_ip_route_get_variant_attribute_spec() -> *const *const NMVariantAttributeSpec;
}
extern "C" {
    pub fn nm_ip_route_attribute_validate(
        name: *const ::std::os::raw::c_char,
        value: *mut GVariant,
        family: ::std::os::raw::c_int,
        known: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMIPRoutingRule {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nm_ip_routing_rule_get_type() -> GType;
}
extern "C" {
    pub fn nm_ip_routing_rule_new(addr_family: ::std::os::raw::c_int) -> *mut NMIPRoutingRule;
}
extern "C" {
    pub fn nm_ip_routing_rule_new_clone(rule: *const NMIPRoutingRule) -> *mut NMIPRoutingRule;
}
extern "C" {
    pub fn nm_ip_routing_rule_ref(self_: *mut NMIPRoutingRule) -> *mut NMIPRoutingRule;
}
extern "C" {
    pub fn nm_ip_routing_rule_unref(self_: *mut NMIPRoutingRule);
}
extern "C" {
    pub fn nm_ip_routing_rule_is_sealed(self_: *const NMIPRoutingRule) -> gboolean;
}
extern "C" {
    pub fn nm_ip_routing_rule_seal(self_: *mut NMIPRoutingRule);
}
extern "C" {
    pub fn nm_ip_routing_rule_get_addr_family(
        self_: *const NMIPRoutingRule,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_ip_routing_rule_get_invert(self_: *const NMIPRoutingRule) -> gboolean;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_invert(self_: *mut NMIPRoutingRule, invert: gboolean);
}
extern "C" {
    pub fn nm_ip_routing_rule_get_priority(self_: *const NMIPRoutingRule) -> gint64;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_priority(self_: *mut NMIPRoutingRule, priority: gint64);
}
extern "C" {
    pub fn nm_ip_routing_rule_get_tos(self_: *const NMIPRoutingRule) -> guint8;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_tos(self_: *mut NMIPRoutingRule, tos: guint8);
}
extern "C" {
    pub fn nm_ip_routing_rule_get_ipproto(self_: *const NMIPRoutingRule) -> guint8;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_ipproto(self_: *mut NMIPRoutingRule, ipproto: guint8);
}
extern "C" {
    pub fn nm_ip_routing_rule_get_source_port_start(self_: *const NMIPRoutingRule) -> guint16;
}
extern "C" {
    pub fn nm_ip_routing_rule_get_source_port_end(self_: *const NMIPRoutingRule) -> guint16;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_source_port(
        self_: *mut NMIPRoutingRule,
        start: guint16,
        end: guint16,
    );
}
extern "C" {
    pub fn nm_ip_routing_rule_get_destination_port_start(self_: *const NMIPRoutingRule) -> guint16;
}
extern "C" {
    pub fn nm_ip_routing_rule_get_destination_port_end(self_: *const NMIPRoutingRule) -> guint16;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_destination_port(
        self_: *mut NMIPRoutingRule,
        start: guint16,
        end: guint16,
    );
}
extern "C" {
    pub fn nm_ip_routing_rule_get_fwmark(self_: *const NMIPRoutingRule) -> guint32;
}
extern "C" {
    pub fn nm_ip_routing_rule_get_fwmask(self_: *const NMIPRoutingRule) -> guint32;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_fwmark(
        self_: *mut NMIPRoutingRule,
        fwmark: guint32,
        fwmask: guint32,
    );
}
extern "C" {
    pub fn nm_ip_routing_rule_get_from_len(self_: *const NMIPRoutingRule) -> guint8;
}
extern "C" {
    pub fn nm_ip_routing_rule_get_from(
        self_: *const NMIPRoutingRule,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_from(
        self_: *mut NMIPRoutingRule,
        from: *const ::std::os::raw::c_char,
        len: guint8,
    );
}
extern "C" {
    pub fn nm_ip_routing_rule_get_to_len(self_: *const NMIPRoutingRule) -> guint8;
}
extern "C" {
    pub fn nm_ip_routing_rule_get_to(
        self_: *const NMIPRoutingRule,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_to(
        self_: *mut NMIPRoutingRule,
        to: *const ::std::os::raw::c_char,
        len: guint8,
    );
}
extern "C" {
    pub fn nm_ip_routing_rule_get_iifname(
        self_: *const NMIPRoutingRule,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_iifname(
        self_: *mut NMIPRoutingRule,
        iifname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_ip_routing_rule_get_oifname(
        self_: *const NMIPRoutingRule,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_oifname(
        self_: *mut NMIPRoutingRule,
        oifname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_ip_routing_rule_get_action(self_: *const NMIPRoutingRule) -> guint8;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_action(self_: *mut NMIPRoutingRule, action: guint8);
}
extern "C" {
    pub fn nm_ip_routing_rule_get_table(self_: *const NMIPRoutingRule) -> guint32;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_table(self_: *mut NMIPRoutingRule, table: guint32);
}
extern "C" {
    pub fn nm_ip_routing_rule_get_suppress_prefixlength(self_: *const NMIPRoutingRule) -> gint32;
}
extern "C" {
    pub fn nm_ip_routing_rule_set_suppress_prefixlength(
        self_: *mut NMIPRoutingRule,
        suppress_prefixlength: gint32,
    );
}
extern "C" {
    pub fn nm_ip_routing_rule_cmp(
        rule: *const NMIPRoutingRule,
        other: *const NMIPRoutingRule,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_ip_routing_rule_validate(
        self_: *const NMIPRoutingRule,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub const NMIPRoutingRuleAsStringFlags_NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE:
    NMIPRoutingRuleAsStringFlags = 0;
pub const NMIPRoutingRuleAsStringFlags_NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET:
    NMIPRoutingRuleAsStringFlags = 1;
pub const NMIPRoutingRuleAsStringFlags_NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6:
    NMIPRoutingRuleAsStringFlags = 2;
pub const NMIPRoutingRuleAsStringFlags_NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE:
    NMIPRoutingRuleAsStringFlags = 4;
#[doc = " NMIPRoutingRuleAsStringFlags:"]
#[doc = " @NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE: no flags selected."]
#[doc = " @NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET: whether to allow parsing"]
#[doc = "   IPv4 addresses."]
#[doc = " @NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6: whether to allow parsing"]
#[doc = "   IPv6 addresses. If both @NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET and"]
#[doc = "   @NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6 are unset, it's the same"]
#[doc = "   as setting them both."]
#[doc = " @NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE: if set, ensure that the"]
#[doc = "   rule verfies or fail."]
#[doc = ""]
#[doc = " Since: 1.18"]
pub type NMIPRoutingRuleAsStringFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_ip_routing_rule_from_string(
        str_: *const ::std::os::raw::c_char,
        to_string_flags: NMIPRoutingRuleAsStringFlags,
        extra_args: *mut GHashTable,
        error: *mut *mut GError,
    ) -> *mut NMIPRoutingRule;
}
extern "C" {
    pub fn nm_ip_routing_rule_to_string(
        self_: *const NMIPRoutingRule,
        to_string_flags: NMIPRoutingRuleAsStringFlags,
        extra_args: *mut GHashTable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " NMSettingIPConfig:"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingIPConfig {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingIPConfig() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingIPConfig>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingIPConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingIPConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingIPConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingIPConfig>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingIPConfig),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingIPConfigClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout_NMSettingIPConfigClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingIPConfigClass>(),
        320usize,
        concat!("Size of: ", stringify!(NMSettingIPConfigClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingIPConfigClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingIPConfigClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingIPConfigClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingIPConfigClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingIPConfigClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingIPConfigClass),
            "::",
            stringify!(padding)
        )
    );
}
pub const NMDhcpHostnameFlags_NM_DHCP_HOSTNAME_FLAG_NONE: NMDhcpHostnameFlags = 0;
pub const NMDhcpHostnameFlags_NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE: NMDhcpHostnameFlags = 1;
pub const NMDhcpHostnameFlags_NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED: NMDhcpHostnameFlags = 2;
pub const NMDhcpHostnameFlags_NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE: NMDhcpHostnameFlags = 4;
pub const NMDhcpHostnameFlags_NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS: NMDhcpHostnameFlags = 8;
#[doc = " NMDhcpHostnameFlags:"]
#[doc = " @NM_DHCP_HOSTNAME_FLAG_NONE: no flag set. The default value from"]
#[doc = "   Networkmanager global configuration is used. If such value is unset"]
#[doc = "   or still zero, the DHCP request will use standard FQDN flags, i.e."]
#[doc = "   %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE and"]
#[doc = "   %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED for IPv4 and"]
#[doc = "   %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE for IPv6."]
#[doc = " @NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE: whether the server should"]
#[doc = "   do the A RR (FQDN-to-address) DNS updates."]
#[doc = " @NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED: if set, the FQDN is encoded"]
#[doc = "   using canonical wire format. Otherwise it uses the deprecated"]
#[doc = "   ASCII encoding. This flag is allowed only for DHCPv4."]
#[doc = " @NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE: when not set, request the"]
#[doc = "   server to perform updates (the PTR RR and possibly the A RR"]
#[doc = "   based on the %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE flag). If"]
#[doc = "   this is set, the %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE flag"]
#[doc = "   should be cleared."]
#[doc = " @NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS: when set, no FQDN flags are"]
#[doc = "   sent in the DHCP FQDN option. When cleared and all other FQDN"]
#[doc = "   flags are zero, standard FQDN flags are sent. This flag is"]
#[doc = "   incompatible with any other FQDN flag."]
#[doc = ""]
#[doc = " #NMDhcpHostnameFlags describe flags related to the DHCP hostname and"]
#[doc = " FQDN."]
#[doc = ""]
#[doc = " Since: 1.22"]
pub type NMDhcpHostnameFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_setting_ip_config_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ip_config_get_method(
        setting: *mut NMSettingIPConfig,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_config_get_num_dns(setting: *mut NMSettingIPConfig) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_config_get_dns(
        setting: *mut NMSettingIPConfig,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_config_add_dns(
        setting: *mut NMSettingIPConfig,
        dns: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_remove_dns(
        setting: *mut NMSettingIPConfig,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn nm_setting_ip_config_remove_dns_by_value(
        setting: *mut NMSettingIPConfig,
        dns: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_clear_dns(setting: *mut NMSettingIPConfig);
}
extern "C" {
    pub fn nm_setting_ip_config_get_num_dns_searches(setting: *mut NMSettingIPConfig) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_config_get_dns_search(
        setting: *mut NMSettingIPConfig,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_config_add_dns_search(
        setting: *mut NMSettingIPConfig,
        dns_search: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_remove_dns_search(
        setting: *mut NMSettingIPConfig,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn nm_setting_ip_config_remove_dns_search_by_value(
        setting: *mut NMSettingIPConfig,
        dns_search: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_clear_dns_searches(setting: *mut NMSettingIPConfig);
}
extern "C" {
    pub fn nm_setting_ip_config_get_num_dns_options(setting: *mut NMSettingIPConfig) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_config_has_dns_options(setting: *mut NMSettingIPConfig) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_get_dns_option(
        setting: *mut NMSettingIPConfig,
        idx: guint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_config_next_valid_dns_option(
        setting: *mut NMSettingIPConfig,
        idx: guint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_ip_config_add_dns_option(
        setting: *mut NMSettingIPConfig,
        dns_option: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_remove_dns_option(
        setting: *mut NMSettingIPConfig,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn nm_setting_ip_config_remove_dns_option_by_value(
        setting: *mut NMSettingIPConfig,
        dns_option: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_clear_dns_options(
        setting: *mut NMSettingIPConfig,
        is_set: gboolean,
    );
}
extern "C" {
    pub fn nm_setting_ip_config_get_dns_priority(
        setting: *mut NMSettingIPConfig,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_ip_config_get_num_addresses(setting: *mut NMSettingIPConfig) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_config_get_address(
        setting: *mut NMSettingIPConfig,
        idx: ::std::os::raw::c_int,
    ) -> *mut NMIPAddress;
}
extern "C" {
    pub fn nm_setting_ip_config_add_address(
        setting: *mut NMSettingIPConfig,
        address: *mut NMIPAddress,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_remove_address(
        setting: *mut NMSettingIPConfig,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn nm_setting_ip_config_remove_address_by_value(
        setting: *mut NMSettingIPConfig,
        address: *mut NMIPAddress,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_clear_addresses(setting: *mut NMSettingIPConfig);
}
extern "C" {
    pub fn nm_setting_ip_config_get_gateway(
        setting: *mut NMSettingIPConfig,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_config_get_num_routes(setting: *mut NMSettingIPConfig) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_config_get_route(
        setting: *mut NMSettingIPConfig,
        idx: ::std::os::raw::c_int,
    ) -> *mut NMIPRoute;
}
extern "C" {
    pub fn nm_setting_ip_config_add_route(
        setting: *mut NMSettingIPConfig,
        route: *mut NMIPRoute,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_remove_route(
        setting: *mut NMSettingIPConfig,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn nm_setting_ip_config_remove_route_by_value(
        setting: *mut NMSettingIPConfig,
        route: *mut NMIPRoute,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_clear_routes(setting: *mut NMSettingIPConfig);
}
extern "C" {
    pub fn nm_setting_ip_config_get_route_metric(setting: *mut NMSettingIPConfig) -> gint64;
}
extern "C" {
    pub fn nm_setting_ip_config_get_route_table(setting: *mut NMSettingIPConfig) -> guint32;
}
extern "C" {
    pub fn nm_setting_ip_config_get_num_routing_rules(setting: *mut NMSettingIPConfig) -> guint;
}
extern "C" {
    pub fn nm_setting_ip_config_get_routing_rule(
        setting: *mut NMSettingIPConfig,
        idx: guint,
    ) -> *mut NMIPRoutingRule;
}
extern "C" {
    pub fn nm_setting_ip_config_add_routing_rule(
        setting: *mut NMSettingIPConfig,
        routing_rule: *mut NMIPRoutingRule,
    );
}
extern "C" {
    pub fn nm_setting_ip_config_remove_routing_rule(setting: *mut NMSettingIPConfig, idx: guint);
}
extern "C" {
    pub fn nm_setting_ip_config_clear_routing_rules(setting: *mut NMSettingIPConfig);
}
extern "C" {
    pub fn nm_setting_ip_config_get_ignore_auto_routes(setting: *mut NMSettingIPConfig)
        -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_get_ignore_auto_dns(setting: *mut NMSettingIPConfig) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_get_dhcp_hostname(
        setting: *mut NMSettingIPConfig,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_config_get_dhcp_send_hostname(setting: *mut NMSettingIPConfig)
        -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_get_never_default(setting: *mut NMSettingIPConfig) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_get_may_fail(setting: *mut NMSettingIPConfig) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ip_config_get_dad_timeout(
        setting: *mut NMSettingIPConfig,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_ip_config_get_dhcp_timeout(
        setting: *mut NMSettingIPConfig,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_ip_config_get_dhcp_iaid(
        setting: *mut NMSettingIPConfig,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip_config_get_dhcp_hostname_flags(
        setting: *mut NMSettingIPConfig,
    ) -> NMDhcpHostnameFlags;
}
#[doc = " NMSettingIP4Config:"]
#[doc = ""]
#[doc = " IPv4 Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingIP4Config {
    pub parent: NMSettingIPConfig,
}
#[test]
fn bindgen_test_layout__NMSettingIP4Config() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingIP4Config>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingIP4Config))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingIP4Config>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingIP4Config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingIP4Config>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingIP4Config),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingIP4ConfigClass {
    pub parent: NMSettingIPConfigClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingIP4ConfigClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingIP4ConfigClass>(),
        352usize,
        concat!("Size of: ", stringify!(NMSettingIP4ConfigClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingIP4ConfigClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingIP4ConfigClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingIP4ConfigClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingIP4ConfigClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingIP4ConfigClass>())).padding as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingIP4ConfigClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_ip4_config_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ip4_config_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ip4_config_get_dhcp_client_id(
        setting: *mut NMSettingIP4Config,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip4_config_get_dhcp_fqdn(
        setting: *mut NMSettingIP4Config,
    ) -> *const ::std::os::raw::c_char;
}
pub const NMSettingIP6ConfigPrivacy_NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN:
    NMSettingIP6ConfigPrivacy = -1;
pub const NMSettingIP6ConfigPrivacy_NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED:
    NMSettingIP6ConfigPrivacy = 0;
pub const NMSettingIP6ConfigPrivacy_NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR:
    NMSettingIP6ConfigPrivacy = 1;
pub const NMSettingIP6ConfigPrivacy_NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR:
    NMSettingIP6ConfigPrivacy = 2;
#[doc = " NMSettingIP6ConfigPrivacy:"]
#[doc = " @NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN: unknown or no value specified"]
#[doc = " @NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED: IPv6 Privacy Extensions are disabled"]
#[doc = " @NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR: IPv6 Privacy Extensions"]
#[doc = " are enabled, but public addresses are preferred over temporary addresses"]
#[doc = " @NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR: IPv6 Privacy Extensions"]
#[doc = " are enabled and temporary addresses are preferred over public addresses"]
#[doc = ""]
#[doc = " #NMSettingIP6ConfigPrivacy values indicate if and how IPv6 Privacy"]
#[doc = " Extensions are used (RFC4941)."]
pub type NMSettingIP6ConfigPrivacy = ::std::os::raw::c_int;
pub const NMSettingIP6ConfigAddrGenMode_NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64:
    NMSettingIP6ConfigAddrGenMode = 0;
pub const NMSettingIP6ConfigAddrGenMode_NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY:
    NMSettingIP6ConfigAddrGenMode = 1;
#[doc = " NMSettingIP6ConfigAddrGenMode:"]
#[doc = " @NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64: The Interface Identifier is derived"]
#[doc = " from the interface hardware address."]
#[doc = " @NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY: The Interface Identifier"]
#[doc = " is created by using a cryptographically secure hash of a secret host-specific"]
#[doc = " key along with the connection identification and the network address as"]
#[doc = " specified by RFC7217."]
#[doc = ""]
#[doc = " #NMSettingIP6ConfigAddrGenMode controls how the Interface Identifier for"]
#[doc = " RFC4862 Stateless Address Autoconfiguration is created."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub type NMSettingIP6ConfigAddrGenMode = ::std::os::raw::c_uint;
#[doc = " NMSettingIP6Config:"]
#[doc = ""]
#[doc = " IPv6 Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingIP6Config {
    pub parent: NMSettingIPConfig,
}
#[test]
fn bindgen_test_layout__NMSettingIP6Config() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingIP6Config>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingIP6Config))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingIP6Config>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingIP6Config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingIP6Config>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingIP6Config),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingIP6ConfigClass {
    pub parent: NMSettingIPConfigClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingIP6ConfigClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingIP6ConfigClass>(),
        352usize,
        concat!("Size of: ", stringify!(NMSettingIP6ConfigClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingIP6ConfigClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingIP6ConfigClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingIP6ConfigClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingIP6ConfigClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingIP6ConfigClass>())).padding as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingIP6ConfigClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_ip6_config_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ip6_config_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ip6_config_get_ip6_privacy(
        setting: *mut NMSettingIP6Config,
    ) -> NMSettingIP6ConfigPrivacy;
}
extern "C" {
    pub fn nm_setting_ip6_config_get_addr_gen_mode(
        setting: *mut NMSettingIP6Config,
    ) -> NMSettingIP6ConfigAddrGenMode;
}
extern "C" {
    pub fn nm_setting_ip6_config_get_token(
        setting: *mut NMSettingIP6Config,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip6_config_get_dhcp_duid(
        setting: *mut NMSettingIP6Config,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ip6_config_get_ra_timeout(setting: *mut NMSettingIP6Config) -> gint32;
}
#[doc = " NMSettingMacsec:"]
#[doc = ""]
#[doc = " MACSec Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingMacsec {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingMacsec() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingMacsec>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingMacsec))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingMacsec>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingMacsec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingMacsec>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingMacsec),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingMacsecClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingMacsecClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingMacsecClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingMacsecClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingMacsecClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingMacsecClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingMacsecClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingMacsecClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingMacsecClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingMacsecClass),
            "::",
            stringify!(padding)
        )
    );
}
pub const NMSettingMacsecMode_NM_SETTING_MACSEC_MODE_PSK: NMSettingMacsecMode = 0;
pub const NMSettingMacsecMode_NM_SETTING_MACSEC_MODE_EAP: NMSettingMacsecMode = 1;
#[doc = " NMSettingMacsecMode:"]
#[doc = " @NM_SETTING_MACSEC_MODE_PSK: The CAK is pre-shared"]
#[doc = " @NM_SETTING_MACSEC_MODE_EAP: The CAK is the result of participation in EAP"]
#[doc = ""]
#[doc = " #NMSettingMacsecMode controls how the CAK (Connectivity Association Key) used"]
#[doc = " in MKA (MACsec Key Agreement) is obtained."]
#[doc = ""]
#[doc = " Since: 1.6"]
pub type NMSettingMacsecMode = ::std::os::raw::c_uint;
pub const NMSettingMacsecValidation_NM_SETTING_MACSEC_VALIDATION_DISABLE:
    NMSettingMacsecValidation = 0;
pub const NMSettingMacsecValidation_NM_SETTING_MACSEC_VALIDATION_CHECK: NMSettingMacsecValidation =
    1;
pub const NMSettingMacsecValidation_NM_SETTING_MACSEC_VALIDATION_STRICT: NMSettingMacsecValidation =
    2;
#[doc = " NMSettingMacsecValidation:"]
#[doc = " @NM_SETTING_MACSEC_VALIDATION_DISABLE: All incoming frames are accepted if"]
#[doc = "   possible"]
#[doc = " @NM_SETTING_MACSEC_VALIDATION_CHECK: Non protected, invalid, or impossible to"]
#[doc = "   verify frames are accepted and counted as \"invalid\""]
#[doc = " @NM_SETTING_MACSEC_VALIDATION_STRICT: Non protected, invalid, or impossible to"]
#[doc = "   verify frames are dropped"]
#[doc = ""]
#[doc = " #NMSettingMacsecValidation specifies a validation mode for incoming frames."]
#[doc = ""]
#[doc = " Since: 1.6"]
pub type NMSettingMacsecValidation = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_setting_macsec_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_macsec_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_macsec_get_parent(
        setting: *mut NMSettingMacsec,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_macsec_get_mode(setting: *mut NMSettingMacsec) -> NMSettingMacsecMode;
}
extern "C" {
    pub fn nm_setting_macsec_get_encrypt(setting: *mut NMSettingMacsec) -> gboolean;
}
extern "C" {
    pub fn nm_setting_macsec_get_mka_cak(
        setting: *mut NMSettingMacsec,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_macsec_get_mka_cak_flags(
        setting: *mut NMSettingMacsec,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_macsec_get_mka_ckn(
        setting: *mut NMSettingMacsec,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_macsec_get_port(setting: *mut NMSettingMacsec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_macsec_get_validation(
        setting: *mut NMSettingMacsec,
    ) -> NMSettingMacsecValidation;
}
extern "C" {
    pub fn nm_setting_macsec_get_send_sci(setting: *mut NMSettingMacsec) -> gboolean;
}
#[doc = " NMSettingMacvlan:"]
#[doc = ""]
#[doc = " MAC VLAN Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingMacvlan {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingMacvlan() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingMacvlan>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingMacvlan))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingMacvlan>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingMacvlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingMacvlan>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingMacvlan),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingMacvlanClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingMacvlanClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingMacvlanClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingMacvlanClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingMacvlanClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingMacvlanClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingMacvlanClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingMacvlanClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingMacvlanClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingMacvlanClass),
            "::",
            stringify!(padding)
        )
    );
}
pub const NMSettingMacvlanMode_NM_SETTING_MACVLAN_MODE_UNKNOWN: NMSettingMacvlanMode = 0;
pub const NMSettingMacvlanMode_NM_SETTING_MACVLAN_MODE_VEPA: NMSettingMacvlanMode = 1;
pub const NMSettingMacvlanMode_NM_SETTING_MACVLAN_MODE_BRIDGE: NMSettingMacvlanMode = 2;
pub const NMSettingMacvlanMode_NM_SETTING_MACVLAN_MODE_PRIVATE: NMSettingMacvlanMode = 3;
pub const NMSettingMacvlanMode_NM_SETTING_MACVLAN_MODE_PASSTHRU: NMSettingMacvlanMode = 4;
pub const NMSettingMacvlanMode_NM_SETTING_MACVLAN_MODE_SOURCE: NMSettingMacvlanMode = 5;
pub const NMSettingMacvlanMode__NM_SETTING_MACVLAN_MODE_NUM: NMSettingMacvlanMode = 6;
pub const NMSettingMacvlanMode_NM_SETTING_MACVLAN_MODE_LAST: NMSettingMacvlanMode = 5;
#[doc = " NMSettingMacvlanMode:"]
#[doc = " @NM_SETTING_MACVLAN_MODE_UNKNOWN: unknown/unset mode"]
#[doc = " @NM_SETTING_MACVLAN_MODE_VEPA: Virtual Ethernet Port Aggregator mode"]
#[doc = " @NM_SETTING_MACVLAN_MODE_BRIDGE: bridge mode"]
#[doc = " @NM_SETTING_MACVLAN_MODE_PRIVATE: private mode"]
#[doc = " @NM_SETTING_MACVLAN_MODE_PASSTHRU: passthru mode"]
#[doc = " @NM_SETTING_MACVLAN_MODE_SOURCE: source mode"]
pub type NMSettingMacvlanMode = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_setting_macvlan_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_macvlan_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_macvlan_get_parent(
        setting: *mut NMSettingMacvlan,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_macvlan_get_mode(setting: *mut NMSettingMacvlan) -> NMSettingMacvlanMode;
}
extern "C" {
    pub fn nm_setting_macvlan_get_promiscuous(setting: *mut NMSettingMacvlan) -> gboolean;
}
extern "C" {
    pub fn nm_setting_macvlan_get_tap(setting: *mut NMSettingMacvlan) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingMatchClass {
    _unused: [u8; 0],
}
pub type NMSettingMatchClass = _NMSettingMatchClass;
extern "C" {
    pub fn nm_setting_match_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_match_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_match_get_num_interface_names(setting: *mut NMSettingMatch) -> guint;
}
extern "C" {
    pub fn nm_setting_match_get_interface_name(
        setting: *mut NMSettingMatch,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_match_remove_interface_name(
        setting: *mut NMSettingMatch,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn nm_setting_match_remove_interface_name_by_value(
        setting: *mut NMSettingMatch,
        interface_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_match_add_interface_name(
        setting: *mut NMSettingMatch,
        interface_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_setting_match_clear_interface_names(setting: *mut NMSettingMatch);
}
extern "C" {
    pub fn nm_setting_match_get_interface_names(
        setting: *mut NMSettingMatch,
        length: *mut guint,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_match_get_num_kernel_command_lines(setting: *mut NMSettingMatch) -> guint;
}
extern "C" {
    pub fn nm_setting_match_get_kernel_command_line(
        setting: *mut NMSettingMatch,
        idx: guint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_match_remove_kernel_command_line(setting: *mut NMSettingMatch, idx: guint);
}
extern "C" {
    pub fn nm_setting_match_remove_kernel_command_line_by_value(
        setting: *mut NMSettingMatch,
        kernel_command_line: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_match_add_kernel_command_line(
        setting: *mut NMSettingMatch,
        kernel_command_line: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_setting_match_clear_kernel_command_lines(setting: *mut NMSettingMatch);
}
extern "C" {
    pub fn nm_setting_match_get_kernel_command_lines(
        setting: *mut NMSettingMatch,
        length: *mut guint,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_match_get_num_drivers(setting: *mut NMSettingMatch) -> guint;
}
extern "C" {
    pub fn nm_setting_match_get_driver(
        setting: *mut NMSettingMatch,
        idx: guint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_match_remove_driver(setting: *mut NMSettingMatch, idx: guint);
}
extern "C" {
    pub fn nm_setting_match_remove_driver_by_value(
        setting: *mut NMSettingMatch,
        driver: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_match_add_driver(
        setting: *mut NMSettingMatch,
        driver: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_setting_match_clear_drivers(setting: *mut NMSettingMatch);
}
extern "C" {
    pub fn nm_setting_match_get_drivers(
        setting: *mut NMSettingMatch,
        length: *mut guint,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_match_get_num_paths(setting: *mut NMSettingMatch) -> guint;
}
extern "C" {
    pub fn nm_setting_match_get_path(
        setting: *mut NMSettingMatch,
        idx: guint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_match_remove_path(setting: *mut NMSettingMatch, idx: guint);
}
extern "C" {
    pub fn nm_setting_match_remove_path_by_value(
        setting: *mut NMSettingMatch,
        path: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_match_add_path(
        setting: *mut NMSettingMatch,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_setting_match_clear_paths(setting: *mut NMSettingMatch);
}
extern "C" {
    pub fn nm_setting_match_get_paths(
        setting: *mut NMSettingMatch,
        length: *mut guint,
    ) -> *const *const ::std::os::raw::c_char;
}
#[doc = " NMSettingOlpcMesh:"]
#[doc = ""]
#[doc = " OLPC Wireless Mesh Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOlpcMesh {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingOlpcMesh() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingOlpcMesh>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingOlpcMesh))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingOlpcMesh>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingOlpcMesh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingOlpcMesh>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingOlpcMesh),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingOlpcMeshClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingOlpcMeshClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingOlpcMeshClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingOlpcMeshClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingOlpcMeshClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingOlpcMeshClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingOlpcMeshClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingOlpcMeshClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingOlpcMeshClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingOlpcMeshClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_olpc_mesh_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_olpc_mesh_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_olpc_mesh_get_ssid(setting: *mut NMSettingOlpcMesh) -> *mut GBytes;
}
extern "C" {
    pub fn nm_setting_olpc_mesh_get_channel(setting: *mut NMSettingOlpcMesh) -> guint32;
}
extern "C" {
    pub fn nm_setting_olpc_mesh_get_dhcp_anycast_address(
        setting: *mut NMSettingOlpcMesh,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsBridgeClass {
    _unused: [u8; 0],
}
pub type NMSettingOvsBridgeClass = _NMSettingOvsBridgeClass;
extern "C" {
    pub fn nm_setting_ovs_bridge_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ovs_bridge_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ovs_bridge_get_fail_mode(
        self_: *mut NMSettingOvsBridge,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ovs_bridge_get_mcast_snooping_enable(
        self_: *mut NMSettingOvsBridge,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ovs_bridge_get_rstp_enable(self_: *mut NMSettingOvsBridge) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ovs_bridge_get_stp_enable(self_: *mut NMSettingOvsBridge) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ovs_bridge_get_datapath_type(
        self_: *mut NMSettingOvsBridge,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsInterfaceClass {
    _unused: [u8; 0],
}
pub type NMSettingOvsInterfaceClass = _NMSettingOvsInterfaceClass;
extern "C" {
    pub fn nm_setting_ovs_interface_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ovs_interface_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ovs_interface_get_interface_type(
        self_: *mut NMSettingOvsInterface,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsDpdkClass {
    _unused: [u8; 0],
}
pub type NMSettingOvsDpdkClass = _NMSettingOvsDpdkClass;
extern "C" {
    pub fn nm_setting_ovs_dpdk_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ovs_dpdk_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ovs_dpdk_get_devargs(
        self_: *mut NMSettingOvsDpdk,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsPatchClass {
    _unused: [u8; 0],
}
pub type NMSettingOvsPatchClass = _NMSettingOvsPatchClass;
extern "C" {
    pub fn nm_setting_ovs_patch_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ovs_patch_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ovs_patch_get_peer(
        self_: *mut NMSettingOvsPatch,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingOvsPortClass {
    _unused: [u8; 0],
}
pub type NMSettingOvsPortClass = _NMSettingOvsPortClass;
extern "C" {
    pub fn nm_setting_ovs_port_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ovs_port_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ovs_port_get_vlan_mode(
        self_: *mut NMSettingOvsPort,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ovs_port_get_tag(self_: *mut NMSettingOvsPort) -> guint;
}
extern "C" {
    pub fn nm_setting_ovs_port_get_lacp(
        self_: *mut NMSettingOvsPort,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ovs_port_get_bond_mode(
        self_: *mut NMSettingOvsPort,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_ovs_port_get_bond_updelay(self_: *mut NMSettingOvsPort) -> guint;
}
extern "C" {
    pub fn nm_setting_ovs_port_get_bond_downdelay(self_: *mut NMSettingOvsPort) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWifiP2PClass {
    _unused: [u8; 0],
}
pub type NMSettingWifiP2PClass = _NMSettingWifiP2PClass;
extern "C" {
    pub fn nm_setting_wifi_p2p_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wifi_p2p_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_wifi_p2p_get_peer(
        setting: *mut NMSettingWifiP2P,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wifi_p2p_get_wps_method(
        setting: *mut NMSettingWifiP2P,
    ) -> NMSettingWirelessSecurityWpsMethod;
}
extern "C" {
    pub fn nm_setting_wifi_p2p_get_wfd_ies(setting: *mut NMSettingWifiP2P) -> *mut GBytes;
}
#[doc = " NMSettingPpp:"]
#[doc = ""]
#[doc = " Point-to-Point Protocol Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingPpp {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingPpp() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingPpp>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingPpp))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingPpp>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingPpp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingPpp>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingPpp),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingPppClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingPppClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingPppClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingPppClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingPppClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingPppClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingPppClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingPppClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingPppClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingPppClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_ppp_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_ppp_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_ppp_get_noauth(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_refuse_eap(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_refuse_pap(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_refuse_chap(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_refuse_mschap(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_refuse_mschapv2(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_nobsdcomp(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_nodeflate(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_no_vj_comp(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_require_mppe(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_require_mppe_128(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_mppe_stateful(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_crtscts(setting: *mut NMSettingPpp) -> gboolean;
}
extern "C" {
    pub fn nm_setting_ppp_get_baud(setting: *mut NMSettingPpp) -> guint32;
}
extern "C" {
    pub fn nm_setting_ppp_get_mru(setting: *mut NMSettingPpp) -> guint32;
}
extern "C" {
    pub fn nm_setting_ppp_get_mtu(setting: *mut NMSettingPpp) -> guint32;
}
extern "C" {
    pub fn nm_setting_ppp_get_lcp_echo_failure(setting: *mut NMSettingPpp) -> guint32;
}
extern "C" {
    pub fn nm_setting_ppp_get_lcp_echo_interval(setting: *mut NMSettingPpp) -> guint32;
}
#[doc = " NMSettingPppoe:"]
#[doc = ""]
#[doc = " PPP-over-Ethernet Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingPppoe {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingPppoe() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingPppoe>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingPppoe))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingPppoe>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingPppoe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingPppoe>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingPppoe),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingPppoeClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingPppoeClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingPppoeClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingPppoeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingPppoeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingPppoeClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingPppoeClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingPppoeClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingPppoeClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingPppoeClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_pppoe_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_pppoe_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_pppoe_get_parent(
        setting: *mut NMSettingPppoe,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_pppoe_get_service(
        setting: *mut NMSettingPppoe,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_pppoe_get_username(
        setting: *mut NMSettingPppoe,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_pppoe_get_password(
        setting: *mut NMSettingPppoe,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_pppoe_get_password_flags(
        setting: *mut NMSettingPppoe,
    ) -> NMSettingSecretFlags;
}
pub const NMSettingProxyMethod_NM_SETTING_PROXY_METHOD_NONE: NMSettingProxyMethod = 0;
pub const NMSettingProxyMethod_NM_SETTING_PROXY_METHOD_AUTO: NMSettingProxyMethod = 1;
#[doc = " NMSettingProxyMethod:"]
#[doc = " @NM_SETTING_PROXY_METHOD_NONE: No Proxy for the Connection"]
#[doc = " @NM_SETTING_PROXY_METHOD_AUTO: DHCP obtained Proxy/ Manual override"]
#[doc = ""]
#[doc = " The Proxy method."]
#[doc = ""]
#[doc = " Since: 1.6"]
pub type NMSettingProxyMethod = ::std::os::raw::c_uint;
#[doc = " NMSettingProxy:"]
#[doc = ""]
#[doc = " WWW Proxy Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingProxy {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingProxy() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingProxy>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingProxy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingProxy>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingProxy),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingProxyClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingProxyClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingProxyClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingProxyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingProxyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingProxyClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingProxyClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingProxyClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingProxyClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingProxyClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_proxy_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_proxy_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_proxy_get_method(setting: *mut NMSettingProxy) -> NMSettingProxyMethod;
}
extern "C" {
    pub fn nm_setting_proxy_get_browser_only(setting: *mut NMSettingProxy) -> gboolean;
}
extern "C" {
    pub fn nm_setting_proxy_get_pac_url(
        setting: *mut NMSettingProxy,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_proxy_get_pac_script(
        setting: *mut NMSettingProxy,
    ) -> *const ::std::os::raw::c_char;
}
pub const NMSettingSerialParity_NM_SETTING_SERIAL_PARITY_NONE: NMSettingSerialParity = 0;
pub const NMSettingSerialParity_NM_SETTING_SERIAL_PARITY_EVEN: NMSettingSerialParity = 1;
pub const NMSettingSerialParity_NM_SETTING_SERIAL_PARITY_ODD: NMSettingSerialParity = 2;
#[doc = " NMSettingSerialParity:"]
#[doc = " @NM_SETTING_SERIAL_PARITY_NONE: No parity bits (default)"]
#[doc = " @NM_SETTING_SERIAL_PARITY_EVEN: Even parity"]
#[doc = " @NM_SETTING_SERIAL_PARITY_ODD: Odd parity"]
#[doc = ""]
#[doc = " The parity setting of a serial port."]
pub type NMSettingSerialParity = ::std::os::raw::c_uint;
#[doc = " NMSettingSerial:"]
#[doc = ""]
#[doc = " Serial Link Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingSerial {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingSerial() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingSerial>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingSerial))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingSerial>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingSerial))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingSerial>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingSerial),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingSerialClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingSerialClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingSerialClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingSerialClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingSerialClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingSerialClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingSerialClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingSerialClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingSerialClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingSerialClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_serial_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_serial_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_serial_get_baud(setting: *mut NMSettingSerial) -> guint;
}
extern "C" {
    pub fn nm_setting_serial_get_bits(setting: *mut NMSettingSerial) -> guint;
}
extern "C" {
    pub fn nm_setting_serial_get_parity(setting: *mut NMSettingSerial) -> NMSettingSerialParity;
}
extern "C" {
    pub fn nm_setting_serial_get_stopbits(setting: *mut NMSettingSerial) -> guint;
}
extern "C" {
    pub fn nm_setting_serial_get_send_delay(setting: *mut NMSettingSerial) -> guint64;
}
pub const NMTeamLinkWatcherArpPingFlags_NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_NONE:
    NMTeamLinkWatcherArpPingFlags = 0;
pub const NMTeamLinkWatcherArpPingFlags_NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_ACTIVE:
    NMTeamLinkWatcherArpPingFlags = 2;
pub const NMTeamLinkWatcherArpPingFlags_NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_INACTIVE:
    NMTeamLinkWatcherArpPingFlags = 4;
pub const NMTeamLinkWatcherArpPingFlags_NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_SEND_ALWAYS:
    NMTeamLinkWatcherArpPingFlags = 8;
#[doc = " NMTeamLinkWatcherArpPingFlags:"]
#[doc = " @NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_NONE: no one among the arp_ping link watcher"]
#[doc = "    boolean options ('validate_active', 'validate_inactive', 'send_always') is"]
#[doc = "    enabled (set to true)."]
#[doc = " @NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_ACTIVE: the arp_ping link watcher"]
#[doc = "    option 'validate_active' is enabled (set to true)."]
#[doc = " @NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_INACTIVE: the arp_ping link watcher"]
#[doc = "    option 'validate_inactive' is enabled (set to true)."]
#[doc = " @NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_SEND_ALWAYS: the arp_ping link watcher option"]
#[doc = "    'send_always' is enabled (set to true)."]
pub type NMTeamLinkWatcherArpPingFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMTeamLinkWatcher {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nm_team_link_watcher_get_type() -> GType;
}
extern "C" {
    pub fn nm_team_link_watcher_new_ethtool(
        delay_up: ::std::os::raw::c_int,
        delay_down: ::std::os::raw::c_int,
        error: *mut *mut GError,
    ) -> *mut NMTeamLinkWatcher;
}
extern "C" {
    pub fn nm_team_link_watcher_new_nsna_ping(
        init_wait: ::std::os::raw::c_int,
        interval: ::std::os::raw::c_int,
        missed_max: ::std::os::raw::c_int,
        target_host: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMTeamLinkWatcher;
}
extern "C" {
    pub fn nm_team_link_watcher_new_arp_ping(
        init_wait: ::std::os::raw::c_int,
        interval: ::std::os::raw::c_int,
        missed_max: ::std::os::raw::c_int,
        target_host: *const ::std::os::raw::c_char,
        source_host: *const ::std::os::raw::c_char,
        flags: NMTeamLinkWatcherArpPingFlags,
        error: *mut *mut GError,
    ) -> *mut NMTeamLinkWatcher;
}
extern "C" {
    pub fn nm_team_link_watcher_new_arp_ping2(
        init_wait: ::std::os::raw::c_int,
        interval: ::std::os::raw::c_int,
        missed_max: ::std::os::raw::c_int,
        vlanid: ::std::os::raw::c_int,
        target_host: *const ::std::os::raw::c_char,
        source_host: *const ::std::os::raw::c_char,
        flags: NMTeamLinkWatcherArpPingFlags,
        error: *mut *mut GError,
    ) -> *mut NMTeamLinkWatcher;
}
extern "C" {
    pub fn nm_team_link_watcher_ref(watcher: *mut NMTeamLinkWatcher);
}
extern "C" {
    pub fn nm_team_link_watcher_unref(watcher: *mut NMTeamLinkWatcher);
}
extern "C" {
    pub fn nm_team_link_watcher_equal(
        watcher: *const NMTeamLinkWatcher,
        other: *const NMTeamLinkWatcher,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_team_link_watcher_dup(watcher: *const NMTeamLinkWatcher) -> *mut NMTeamLinkWatcher;
}
extern "C" {
    pub fn nm_team_link_watcher_get_name(
        watcher: *const NMTeamLinkWatcher,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_team_link_watcher_get_delay_up(
        watcher: *const NMTeamLinkWatcher,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_team_link_watcher_get_delay_down(
        watcher: *const NMTeamLinkWatcher,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_team_link_watcher_get_init_wait(
        watcher: *const NMTeamLinkWatcher,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_team_link_watcher_get_interval(
        watcher: *const NMTeamLinkWatcher,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_team_link_watcher_get_missed_max(
        watcher: *const NMTeamLinkWatcher,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_team_link_watcher_get_target_host(
        watcher: *const NMTeamLinkWatcher,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_team_link_watcher_get_source_host(
        watcher: *const NMTeamLinkWatcher,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_team_link_watcher_get_flags(
        watcher: *const NMTeamLinkWatcher,
    ) -> NMTeamLinkWatcherArpPingFlags;
}
extern "C" {
    pub fn nm_team_link_watcher_get_vlanid(
        watcher: *const NMTeamLinkWatcher,
    ) -> ::std::os::raw::c_int;
}
#[doc = " NMSettingTeam:"]
#[doc = ""]
#[doc = " Teaming Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingTeam {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingTeam() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingTeam>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingTeam))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingTeam>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingTeam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingTeam>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingTeam),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingTeamClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingTeamClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingTeamClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingTeamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingTeamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingTeamClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingTeamClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingTeamClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingTeamClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingTeamClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_team_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_team_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_team_get_config(setting: *mut NMSettingTeam)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_team_get_notify_peers_count(
        setting: *mut NMSettingTeam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_get_notify_peers_interval(
        setting: *mut NMSettingTeam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_get_mcast_rejoin_count(
        setting: *mut NMSettingTeam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_get_mcast_rejoin_interval(
        setting: *mut NMSettingTeam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_get_runner(setting: *mut NMSettingTeam)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_team_get_runner_hwaddr_policy(
        setting: *mut NMSettingTeam,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_team_get_runner_tx_balancer(
        setting: *mut NMSettingTeam,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_team_get_runner_tx_balancer_interval(
        setting: *mut NMSettingTeam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_get_runner_active(setting: *mut NMSettingTeam) -> gboolean;
}
extern "C" {
    pub fn nm_setting_team_get_runner_fast_rate(setting: *mut NMSettingTeam) -> gboolean;
}
extern "C" {
    pub fn nm_setting_team_get_runner_sys_prio(
        setting: *mut NMSettingTeam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_get_runner_min_ports(
        setting: *mut NMSettingTeam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_get_runner_agg_select_policy(
        setting: *mut NMSettingTeam,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_team_remove_runner_tx_hash_by_value(
        setting: *mut NMSettingTeam,
        txhash: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_team_get_num_runner_tx_hash(setting: *mut NMSettingTeam) -> guint;
}
extern "C" {
    pub fn nm_setting_team_get_runner_tx_hash(
        setting: *mut NMSettingTeam,
        idx: guint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_team_remove_runner_tx_hash(setting: *mut NMSettingTeam, idx: guint);
}
extern "C" {
    pub fn nm_setting_team_add_runner_tx_hash(
        setting: *mut NMSettingTeam,
        txhash: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_team_get_num_link_watchers(setting: *mut NMSettingTeam) -> guint;
}
extern "C" {
    pub fn nm_setting_team_get_link_watcher(
        setting: *mut NMSettingTeam,
        idx: guint,
    ) -> *mut NMTeamLinkWatcher;
}
extern "C" {
    pub fn nm_setting_team_add_link_watcher(
        setting: *mut NMSettingTeam,
        link_watcher: *mut NMTeamLinkWatcher,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_team_remove_link_watcher(setting: *mut NMSettingTeam, idx: guint);
}
extern "C" {
    pub fn nm_setting_team_remove_link_watcher_by_value(
        setting: *mut NMSettingTeam,
        link_watcher: *mut NMTeamLinkWatcher,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_team_clear_link_watchers(setting: *mut NMSettingTeam);
}
#[doc = " NMSettingTeamPort:"]
#[doc = ""]
#[doc = " Team Port Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingTeamPort {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingTeamPort() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingTeamPort>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingTeamPort))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingTeamPort>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingTeamPort))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingTeamPort>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingTeamPort),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingTeamPortClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingTeamPortClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingTeamPortClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingTeamPortClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingTeamPortClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingTeamPortClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingTeamPortClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingTeamPortClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingTeamPortClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingTeamPortClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_team_port_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_team_port_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_team_port_get_config(
        setting: *mut NMSettingTeamPort,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_team_port_get_queue_id(
        setting: *mut NMSettingTeamPort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_port_get_prio(setting: *mut NMSettingTeamPort) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_port_get_sticky(setting: *mut NMSettingTeamPort) -> gboolean;
}
extern "C" {
    pub fn nm_setting_team_port_get_lacp_prio(
        setting: *mut NMSettingTeamPort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_port_get_lacp_key(
        setting: *mut NMSettingTeamPort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_setting_team_port_get_num_link_watchers(setting: *mut NMSettingTeamPort) -> guint;
}
extern "C" {
    pub fn nm_setting_team_port_get_link_watcher(
        setting: *mut NMSettingTeamPort,
        idx: guint,
    ) -> *mut NMTeamLinkWatcher;
}
extern "C" {
    pub fn nm_setting_team_port_add_link_watcher(
        setting: *mut NMSettingTeamPort,
        link_watcher: *mut NMTeamLinkWatcher,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_team_port_remove_link_watcher(setting: *mut NMSettingTeamPort, idx: guint);
}
extern "C" {
    pub fn nm_setting_team_port_remove_link_watcher_by_value(
        setting: *mut NMSettingTeamPort,
        link_watcher: *mut NMTeamLinkWatcher,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_team_port_clear_link_watchers(setting: *mut NMSettingTeamPort);
}
pub const NMSettingTunMode_NM_SETTING_TUN_MODE_UNKNOWN: NMSettingTunMode = 0;
pub const NMSettingTunMode_NM_SETTING_TUN_MODE_TUN: NMSettingTunMode = 1;
pub const NMSettingTunMode_NM_SETTING_TUN_MODE_TAP: NMSettingTunMode = 2;
#[doc = " NMSettingTunMode:"]
#[doc = " @NM_SETTING_TUN_MODE_UNKNOWN: an unknown device type"]
#[doc = " @NM_SETTING_TUN_MODE_TUN: a TUN device"]
#[doc = " @NM_SETTING_TUN_MODE_TAP: a TAP device"]
#[doc = ""]
#[doc = " #NMSettingTunMode values indicate the device type (TUN/TAP)"]
pub type NMSettingTunMode = ::std::os::raw::c_uint;
#[doc = " NMSettingTun:"]
#[doc = ""]
#[doc = " Tunnel Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingTun {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingTun() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingTun>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingTun))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingTun>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingTun))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingTun>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingTun),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingTunClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingTunClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingTunClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingTunClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingTunClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingTunClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingTunClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingTunClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingTunClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingTunClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_tun_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_tun_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_tun_get_mode(setting: *mut NMSettingTun) -> NMSettingTunMode;
}
extern "C" {
    pub fn nm_setting_tun_get_owner(setting: *mut NMSettingTun) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_tun_get_group(setting: *mut NMSettingTun) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_tun_get_pi(setting: *mut NMSettingTun) -> gboolean;
}
extern "C" {
    pub fn nm_setting_tun_get_vnet_hdr(setting: *mut NMSettingTun) -> gboolean;
}
extern "C" {
    pub fn nm_setting_tun_get_multi_queue(setting: *mut NMSettingTun) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingUserClass {
    _unused: [u8; 0],
}
pub type NMSettingUserClass = _NMSettingUserClass;
extern "C" {
    pub fn nm_setting_user_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_user_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_user_get_keys(
        setting: *mut NMSettingUser,
        out_len: *mut guint,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_user_get_data(
        setting: *mut NMSettingUser,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_user_set_data(
        setting: *mut NMSettingUser,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_user_check_key(
        key: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_user_check_val(
        val: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " NMSettingVlan:"]
#[doc = ""]
#[doc = " VLAN Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingVlan {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingVlan() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingVlan>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingVlan))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingVlan>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingVlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingVlan>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingVlan),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingVlanClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingVlanClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingVlanClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingVlanClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingVlanClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingVlanClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingVlanClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingVlanClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingVlanClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingVlanClass),
            "::",
            stringify!(padding)
        )
    );
}
pub const NMVlanPriorityMap_NM_VLAN_INGRESS_MAP: NMVlanPriorityMap = 0;
pub const NMVlanPriorityMap_NM_VLAN_EGRESS_MAP: NMVlanPriorityMap = 1;
#[doc = " NMVlanPriorityMap:"]
#[doc = " @NM_VLAN_INGRESS_MAP: map for incoming data"]
#[doc = " @NM_VLAN_EGRESS_MAP: map for outgoing data"]
#[doc = ""]
#[doc = " A selector for traffic priority maps; these map Linux SKB priorities"]
#[doc = " to 802.1p priorities used in VLANs."]
pub type NMVlanPriorityMap = ::std::os::raw::c_uint;
pub const NMVlanFlags_NM_VLAN_FLAG_REORDER_HEADERS: NMVlanFlags = 1;
pub const NMVlanFlags_NM_VLAN_FLAG_GVRP: NMVlanFlags = 2;
pub const NMVlanFlags_NM_VLAN_FLAG_LOOSE_BINDING: NMVlanFlags = 4;
pub const NMVlanFlags_NM_VLAN_FLAG_MVRP: NMVlanFlags = 8;
#[doc = " NMVlanFlags:"]
#[doc = " @NM_VLAN_FLAG_REORDER_HEADERS: indicates that this interface should reorder"]
#[doc = "  outgoing packet headers to look more like a non-VLAN Ethernet interface"]
#[doc = " @NM_VLAN_FLAG_GVRP: indicates that this interface should use GVRP to register"]
#[doc = "  itself with its switch"]
#[doc = " @NM_VLAN_FLAG_LOOSE_BINDING: indicates that this interface's operating"]
#[doc = "  state is tied to the underlying network interface but other details"]
#[doc = "  (like routing) are not."]
#[doc = " @NM_VLAN_FLAG_MVRP: indicates that this interface should use MVRP to register"]
#[doc = "  itself with its switch"]
#[doc = ""]
#[doc = " #NMVlanFlags values control the behavior of the VLAN interface."]
pub type NMVlanFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn nm_setting_vlan_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_vlan_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_vlan_get_parent(setting: *mut NMSettingVlan)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vlan_get_id(setting: *mut NMSettingVlan) -> guint32;
}
extern "C" {
    pub fn nm_setting_vlan_get_flags(setting: *mut NMSettingVlan) -> guint32;
}
extern "C" {
    pub fn nm_setting_vlan_get_num_priorities(
        setting: *mut NMSettingVlan,
        map: NMVlanPriorityMap,
    ) -> gint32;
}
extern "C" {
    pub fn nm_setting_vlan_get_priority(
        setting: *mut NMSettingVlan,
        map: NMVlanPriorityMap,
        idx: guint32,
        out_from: *mut guint32,
        out_to: *mut guint32,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vlan_add_priority(
        setting: *mut NMSettingVlan,
        map: NMVlanPriorityMap,
        from: guint32,
        to: guint32,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vlan_remove_priority(
        setting: *mut NMSettingVlan,
        map: NMVlanPriorityMap,
        idx: guint32,
    );
}
extern "C" {
    pub fn nm_setting_vlan_remove_priority_by_value(
        setting: *mut NMSettingVlan,
        map: NMVlanPriorityMap,
        from: guint32,
        to: guint32,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vlan_remove_priority_str_by_value(
        setting: *mut NMSettingVlan,
        map: NMVlanPriorityMap,
        str_: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vlan_clear_priorities(setting: *mut NMSettingVlan, map: NMVlanPriorityMap);
}
extern "C" {
    pub fn nm_setting_vlan_add_priority_str(
        setting: *mut NMSettingVlan,
        map: NMVlanPriorityMap,
        str_: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
#[doc = " NMSettingVpn:"]
#[doc = ""]
#[doc = " VPN Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingVpn {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingVpn() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingVpn>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingVpn))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingVpn>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingVpn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingVpn>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingVpn),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingVpnClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingVpnClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingVpnClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingVpnClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingVpnClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingVpnClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingVpnClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingVpnClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingVpnClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingVpnClass),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = " NMVpnIterFunc:"]
#[doc = " @key: the name of the data or secret item"]
#[doc = " @value: the value of the data or secret item"]
#[doc = " @user_data: User data passed to nm_setting_vpn_foreach_data_item() or"]
#[doc = " nm_setting_vpn_foreach_secret()"]
pub type NMVpnIterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        user_data: gpointer,
    ),
>;
extern "C" {
    pub fn nm_setting_vpn_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_vpn_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_vpn_get_service_type(
        setting: *mut NMSettingVpn,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vpn_get_user_name(
        setting: *mut NMSettingVpn,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vpn_get_persistent(setting: *mut NMSettingVpn) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vpn_get_num_data_items(setting: *mut NMSettingVpn) -> guint32;
}
extern "C" {
    pub fn nm_setting_vpn_add_data_item(
        setting: *mut NMSettingVpn,
        key: *const ::std::os::raw::c_char,
        item: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_setting_vpn_get_data_item(
        setting: *mut NMSettingVpn,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vpn_remove_data_item(
        setting: *mut NMSettingVpn,
        key: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vpn_foreach_data_item(
        setting: *mut NMSettingVpn,
        func: NMVpnIterFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_setting_vpn_get_data_keys(
        setting: *mut NMSettingVpn,
        out_length: *mut guint,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vpn_get_num_secrets(setting: *mut NMSettingVpn) -> guint32;
}
extern "C" {
    pub fn nm_setting_vpn_add_secret(
        setting: *mut NMSettingVpn,
        key: *const ::std::os::raw::c_char,
        secret: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_setting_vpn_get_secret(
        setting: *mut NMSettingVpn,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vpn_remove_secret(
        setting: *mut NMSettingVpn,
        key: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vpn_foreach_secret(
        setting: *mut NMSettingVpn,
        func: NMVpnIterFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn nm_setting_vpn_get_secret_keys(
        setting: *mut NMSettingVpn,
        out_length: *mut guint,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vpn_get_timeout(setting: *mut NMSettingVpn) -> guint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingVrfClass {
    _unused: [u8; 0],
}
pub type NMSettingVrfClass = _NMSettingVrfClass;
extern "C" {
    pub fn nm_setting_vrf_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_vrf_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_vrf_get_table(setting: *mut NMSettingVrf) -> guint32;
}
#[doc = " NMSettingVxlan:"]
#[doc = ""]
#[doc = " VXLAN Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingVxlan {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingVxlan() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingVxlan>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingVxlan))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingVxlan>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingVxlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingVxlan>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingVxlan),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingVxlanClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingVxlanClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingVxlanClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingVxlanClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingVxlanClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingVxlanClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingVxlanClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingVxlanClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingVxlanClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingVxlanClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_vxlan_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_vxlan_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_vxlan_get_parent(
        setting: *mut NMSettingVxlan,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vxlan_get_id(setting: *mut NMSettingVxlan) -> guint;
}
extern "C" {
    pub fn nm_setting_vxlan_get_local(
        setting: *mut NMSettingVxlan,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vxlan_get_remote(
        setting: *mut NMSettingVxlan,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_vxlan_get_source_port_min(setting: *mut NMSettingVxlan) -> guint;
}
extern "C" {
    pub fn nm_setting_vxlan_get_source_port_max(setting: *mut NMSettingVxlan) -> guint;
}
extern "C" {
    pub fn nm_setting_vxlan_get_destination_port(setting: *mut NMSettingVxlan) -> guint;
}
extern "C" {
    pub fn nm_setting_vxlan_get_tos(setting: *mut NMSettingVxlan) -> guint;
}
extern "C" {
    pub fn nm_setting_vxlan_get_ttl(setting: *mut NMSettingVxlan) -> guint;
}
extern "C" {
    pub fn nm_setting_vxlan_get_ageing(setting: *mut NMSettingVxlan) -> guint;
}
extern "C" {
    pub fn nm_setting_vxlan_get_limit(setting: *mut NMSettingVxlan) -> guint;
}
extern "C" {
    pub fn nm_setting_vxlan_get_proxy(setting: *mut NMSettingVxlan) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vxlan_get_learning(setting: *mut NMSettingVxlan) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vxlan_get_rsc(setting: *mut NMSettingVxlan) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vxlan_get_l2_miss(setting: *mut NMSettingVxlan) -> gboolean;
}
extern "C" {
    pub fn nm_setting_vxlan_get_l3_miss(setting: *mut NMSettingVxlan) -> gboolean;
}
#[doc = " NMSettingWimax:"]
#[doc = ""]
#[doc = " WiMax Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWimax {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingWimax() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingWimax>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingWimax))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingWimax>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingWimax))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingWimax>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingWimax),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingWimaxClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingWimaxClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingWimaxClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingWimaxClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingWimaxClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingWimaxClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingWimaxClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingWimaxClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingWimaxClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingWimaxClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_wimax_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wimax_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_wimax_get_network_name(
        setting: *mut NMSettingWimax,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wimax_get_mac_address(
        setting: *mut NMSettingWimax,
    ) -> *const ::std::os::raw::c_char;
}
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_NONE: NMSettingWiredWakeOnLan = 0;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_PHY: NMSettingWiredWakeOnLan = 2;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST: NMSettingWiredWakeOnLan = 4;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST: NMSettingWiredWakeOnLan =
    8;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST: NMSettingWiredWakeOnLan =
    16;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_ARP: NMSettingWiredWakeOnLan = 32;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC: NMSettingWiredWakeOnLan = 64;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_ALL: NMSettingWiredWakeOnLan = 126;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT: NMSettingWiredWakeOnLan = 1;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE: NMSettingWiredWakeOnLan =
    32768;
pub const NMSettingWiredWakeOnLan_NM_SETTING_WIRED_WAKE_ON_LAN_EXCLUSIVE_FLAGS:
    NMSettingWiredWakeOnLan = 32769;
#[doc = " NMSettingWiredWakeOnLan:"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_NONE: Wake-on-LAN disabled"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_PHY: Wake on PHY activity"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST: Wake on unicast messages"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST: Wake on multicast messages"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST: Wake on broadcast messages"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_ARP: Wake on ARP"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC: Wake on magic packet"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_ALL: Wake on all events. This does not"]
#[doc = "   include the exclusive flags @NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT or"]
#[doc = "   @NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE."]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT: Use the default value"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE: Don't change configured settings"]
#[doc = " @NM_SETTING_WIRED_WAKE_ON_LAN_EXCLUSIVE_FLAGS: Mask of flags that are"]
#[doc = "   incompatible with other flags"]
#[doc = ""]
#[doc = " Options for #NMSettingWired:wake-on-lan. Note that not all options"]
#[doc = " are supported by all devices."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub type NMSettingWiredWakeOnLan = ::std::os::raw::c_uint;
#[doc = " NMSettingWired:"]
#[doc = ""]
#[doc = " Wired Ethernet Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWired {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingWired() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingWired>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingWired))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingWired>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingWired))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingWired>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingWired),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingWiredClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingWiredClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingWiredClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingWiredClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingWiredClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingWiredClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingWiredClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingWiredClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingWiredClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingWiredClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_wired_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wired_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_wired_get_port(setting: *mut NMSettingWired)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_get_speed(setting: *mut NMSettingWired) -> guint32;
}
extern "C" {
    pub fn nm_setting_wired_get_duplex(
        setting: *mut NMSettingWired,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_get_auto_negotiate(setting: *mut NMSettingWired) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wired_get_mac_address(
        setting: *mut NMSettingWired,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_get_cloned_mac_address(
        setting: *mut NMSettingWired,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_get_generate_mac_address_mask(
        setting: *mut NMSettingWired,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_get_mac_address_blacklist(
        setting: *mut NMSettingWired,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_get_num_mac_blacklist_items(setting: *mut NMSettingWired) -> guint32;
}
extern "C" {
    pub fn nm_setting_wired_get_mac_blacklist_item(
        setting: *mut NMSettingWired,
        idx: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_add_mac_blacklist_item(
        setting: *mut NMSettingWired,
        mac: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wired_remove_mac_blacklist_item(setting: *mut NMSettingWired, idx: guint32);
}
extern "C" {
    pub fn nm_setting_wired_remove_mac_blacklist_item_by_value(
        setting: *mut NMSettingWired,
        mac: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wired_clear_mac_blacklist_items(setting: *mut NMSettingWired);
}
extern "C" {
    pub fn nm_setting_wired_get_mtu(setting: *mut NMSettingWired) -> guint32;
}
extern "C" {
    pub fn nm_setting_wired_get_s390_subchannels(
        setting: *mut NMSettingWired,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_get_s390_nettype(
        setting: *mut NMSettingWired,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_get_num_s390_options(setting: *mut NMSettingWired) -> guint32;
}
extern "C" {
    pub fn nm_setting_wired_get_s390_option(
        setting: *mut NMSettingWired,
        idx: guint32,
        out_key: *mut *const ::std::os::raw::c_char,
        out_value: *mut *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wired_get_s390_option_by_key(
        setting: *mut NMSettingWired,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_add_s390_option(
        setting: *mut NMSettingWired,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wired_remove_s390_option(
        setting: *mut NMSettingWired,
        key: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wired_get_valid_s390_options(
        setting: *mut NMSettingWired,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wired_get_wake_on_lan(
        setting: *mut NMSettingWired,
    ) -> NMSettingWiredWakeOnLan;
}
extern "C" {
    pub fn nm_setting_wired_get_wake_on_lan_password(
        setting: *mut NMSettingWired,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMWireGuardPeer {
    _unused: [u8; 0],
}
pub type NMWireGuardPeer = _NMWireGuardPeer;
extern "C" {
    pub fn nm_wireguard_peer_get_type() -> GType;
}
extern "C" {
    pub fn nm_wireguard_peer_new() -> *mut NMWireGuardPeer;
}
extern "C" {
    pub fn nm_wireguard_peer_new_clone(
        self_: *const NMWireGuardPeer,
        with_secrets: gboolean,
    ) -> *mut NMWireGuardPeer;
}
extern "C" {
    pub fn nm_wireguard_peer_ref(self_: *mut NMWireGuardPeer) -> *mut NMWireGuardPeer;
}
extern "C" {
    pub fn nm_wireguard_peer_unref(self_: *mut NMWireGuardPeer);
}
extern "C" {
    pub fn nm_wireguard_peer_seal(self_: *mut NMWireGuardPeer);
}
extern "C" {
    pub fn nm_wireguard_peer_is_sealed(self_: *const NMWireGuardPeer) -> gboolean;
}
extern "C" {
    pub fn nm_wireguard_peer_get_public_key(
        self_: *const NMWireGuardPeer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wireguard_peer_set_public_key(
        self_: *mut NMWireGuardPeer,
        public_key: *const ::std::os::raw::c_char,
        accept_invalid: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_wireguard_peer_get_preshared_key(
        self_: *const NMWireGuardPeer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wireguard_peer_set_preshared_key(
        self_: *mut NMWireGuardPeer,
        preshared_key: *const ::std::os::raw::c_char,
        accept_invalid: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_wireguard_peer_get_preshared_key_flags(
        self_: *const NMWireGuardPeer,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_wireguard_peer_set_preshared_key_flags(
        self_: *mut NMWireGuardPeer,
        preshared_key_flags: NMSettingSecretFlags,
    );
}
extern "C" {
    pub fn nm_wireguard_peer_get_persistent_keepalive(self_: *const NMWireGuardPeer) -> guint16;
}
extern "C" {
    pub fn nm_wireguard_peer_set_persistent_keepalive(
        self_: *mut NMWireGuardPeer,
        persistent_keepalive: guint16,
    );
}
extern "C" {
    pub fn nm_wireguard_peer_get_endpoint(
        self_: *const NMWireGuardPeer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wireguard_peer_set_endpoint(
        self_: *mut NMWireGuardPeer,
        endpoint: *const ::std::os::raw::c_char,
        allow_invalid: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_wireguard_peer_get_allowed_ips_len(self_: *const NMWireGuardPeer) -> guint;
}
extern "C" {
    pub fn nm_wireguard_peer_get_allowed_ip(
        self_: *const NMWireGuardPeer,
        idx: guint,
        out_is_valid: *mut gboolean,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wireguard_peer_clear_allowed_ips(self_: *mut NMWireGuardPeer);
}
extern "C" {
    pub fn nm_wireguard_peer_append_allowed_ip(
        self_: *mut NMWireGuardPeer,
        allowed_ip: *const ::std::os::raw::c_char,
        accept_invalid: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_wireguard_peer_remove_allowed_ip(self_: *mut NMWireGuardPeer, idx: guint)
        -> gboolean;
}
extern "C" {
    pub fn nm_wireguard_peer_is_valid(
        self_: *const NMWireGuardPeer,
        check_non_secrets: gboolean,
        check_secrets: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_wireguard_peer_cmp(
        a: *const NMWireGuardPeer,
        b: *const NMWireGuardPeer,
        compare_flags: NMSettingCompareFlags,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWireGuardClass {
    _unused: [u8; 0],
}
pub type NMSettingWireGuardClass = _NMSettingWireGuardClass;
extern "C" {
    pub fn nm_setting_wireguard_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wireguard_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_wireguard_get_private_key(
        self_: *mut NMSettingWireGuard,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireguard_get_private_key_flags(
        self_: *mut NMSettingWireGuard,
    ) -> NMSettingSecretFlags;
}
extern "C" {
    pub fn nm_setting_wireguard_get_listen_port(self_: *mut NMSettingWireGuard) -> guint16;
}
extern "C" {
    pub fn nm_setting_wireguard_get_fwmark(self_: *mut NMSettingWireGuard) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireguard_get_peers_len(self_: *mut NMSettingWireGuard) -> guint;
}
extern "C" {
    pub fn nm_setting_wireguard_get_peer(
        self_: *mut NMSettingWireGuard,
        idx: guint,
    ) -> *mut NMWireGuardPeer;
}
extern "C" {
    pub fn nm_setting_wireguard_get_peer_by_public_key(
        self_: *mut NMSettingWireGuard,
        public_key: *const ::std::os::raw::c_char,
        out_idx: *mut guint,
    ) -> *mut NMWireGuardPeer;
}
extern "C" {
    pub fn nm_setting_wireguard_set_peer(
        self_: *mut NMSettingWireGuard,
        peer: *mut NMWireGuardPeer,
        idx: guint,
    );
}
extern "C" {
    pub fn nm_setting_wireguard_append_peer(
        self_: *mut NMSettingWireGuard,
        peer: *mut NMWireGuardPeer,
    );
}
extern "C" {
    pub fn nm_setting_wireguard_remove_peer(self_: *mut NMSettingWireGuard, idx: guint)
        -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireguard_clear_peers(self_: *mut NMSettingWireGuard) -> guint;
}
extern "C" {
    pub fn nm_setting_wireguard_get_peer_routes(self_: *mut NMSettingWireGuard) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireguard_get_mtu(self_: *mut NMSettingWireGuard) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireguard_get_ip4_auto_default_route(
        self_: *mut NMSettingWireGuard,
    ) -> NMTernary;
}
extern "C" {
    pub fn nm_setting_wireguard_get_ip6_auto_default_route(
        self_: *mut NMSettingWireGuard,
    ) -> NMTernary;
}
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_NONE:
    NMSettingWirelessWakeOnWLan = 0;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY:
    NMSettingWirelessWakeOnWLan = 2;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT:
    NMSettingWirelessWakeOnWLan = 4;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC:
    NMSettingWirelessWakeOnWLan = 8;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE:
    NMSettingWirelessWakeOnWLan = 16;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST:
    NMSettingWirelessWakeOnWLan = 32;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE:
    NMSettingWirelessWakeOnWLan = 64;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE:
    NMSettingWirelessWakeOnWLan = 128;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_TCP:
    NMSettingWirelessWakeOnWLan = 256;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL:
    NMSettingWirelessWakeOnWLan = 510;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT:
    NMSettingWirelessWakeOnWLan = 1;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE:
    NMSettingWirelessWakeOnWLan = 32768;
pub const NMSettingWirelessWakeOnWLan_NM_SETTING_WIRELESS_WAKE_ON_WLAN_EXCLUSIVE_FLAGS:
    NMSettingWirelessWakeOnWLan = 32769;
#[doc = " NMSettingWirelessWakeOnWLan:"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_NONE: Wake-on-WLAN disabled"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY: Wake on any activity"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT: Wake on disconnect"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC: Wake on magic packet"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE: Wake on GTK rekey failure"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST: Wake on EAP identity request"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE: Wake on 4way handshake"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE: Wake on rfkill release"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL: Wake on all events. This does not"]
#[doc = "   include the exclusive flags @NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT or"]
#[doc = "   @NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE."]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT: Use the default value"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE: Don't change configured settings"]
#[doc = " @NM_SETTING_WIRELESS_WAKE_ON_WLAN_EXCLUSIVE_FLAGS: Mask of flags that are"]
#[doc = "   incompatible with other flags"]
#[doc = ""]
#[doc = " Options for #NMSettingWireless:wake-on-wlan. Note that not all options"]
#[doc = " are supported by all devices."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type NMSettingWirelessWakeOnWLan = ::std::os::raw::c_uint;
pub const NMSettingWirelessPowersave_NM_SETTING_WIRELESS_POWERSAVE_DEFAULT:
    NMSettingWirelessPowersave = 0;
pub const NMSettingWirelessPowersave_NM_SETTING_WIRELESS_POWERSAVE_IGNORE:
    NMSettingWirelessPowersave = 1;
pub const NMSettingWirelessPowersave_NM_SETTING_WIRELESS_POWERSAVE_DISABLE:
    NMSettingWirelessPowersave = 2;
pub const NMSettingWirelessPowersave_NM_SETTING_WIRELESS_POWERSAVE_ENABLE:
    NMSettingWirelessPowersave = 3;
pub const NMSettingWirelessPowersave__NM_SETTING_WIRELESS_POWERSAVE_NUM:
    NMSettingWirelessPowersave = 4;
pub const NMSettingWirelessPowersave_NM_SETTING_WIRELESS_POWERSAVE_LAST:
    NMSettingWirelessPowersave = 3;
#[doc = " NMSettingWirelessPowersave:"]
#[doc = " @NM_SETTING_WIRELESS_POWERSAVE_DEFAULT: use the default value"]
#[doc = " @NM_SETTING_WIRELESS_POWERSAVE_IGNORE: don't touch existing setting"]
#[doc = " @NM_SETTING_WIRELESS_POWERSAVE_DISABLE: disable powersave"]
#[doc = " @NM_SETTING_WIRELESS_POWERSAVE_ENABLE: enable powersave"]
#[doc = ""]
#[doc = " These flags indicate whether wireless powersave must be enabled."]
pub type NMSettingWirelessPowersave = ::std::os::raw::c_uint;
#[doc = " NMSettingWireless:"]
#[doc = ""]
#[doc = " Wi-Fi Settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWireless {
    pub parent: NMSetting,
}
#[test]
fn bindgen_test_layout__NMSettingWireless() {
    assert_eq!(
        ::std::mem::size_of::<_NMSettingWireless>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSettingWireless))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSettingWireless>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSettingWireless))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSettingWireless>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSettingWireless),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSettingWirelessClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSettingWirelessClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSettingWirelessClass>(),
        288usize,
        concat!("Size of: ", stringify!(NMSettingWirelessClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSettingWirelessClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSettingWirelessClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingWirelessClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingWirelessClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSettingWirelessClass>())).padding as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSettingWirelessClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_setting_wireless_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wireless_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_wireless_get_ssid(setting: *mut NMSettingWireless) -> *mut GBytes;
}
extern "C" {
    pub fn nm_setting_wireless_get_mode(
        setting: *mut NMSettingWireless,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_get_band(
        setting: *mut NMSettingWireless,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_get_channel(setting: *mut NMSettingWireless) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_get_bssid(
        setting: *mut NMSettingWireless,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_get_rate(setting: *mut NMSettingWireless) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_get_tx_power(setting: *mut NMSettingWireless) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_get_mac_address(
        setting: *mut NMSettingWireless,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_get_cloned_mac_address(
        setting: *mut NMSettingWireless,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_get_generate_mac_address_mask(
        setting: *mut NMSettingWireless,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_get_mac_address_blacklist(
        setting: *mut NMSettingWireless,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_get_num_mac_blacklist_items(
        setting: *mut NMSettingWireless,
    ) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_get_mac_blacklist_item(
        setting: *mut NMSettingWireless,
        idx: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_add_mac_blacklist_item(
        setting: *mut NMSettingWireless,
        mac: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_remove_mac_blacklist_item(
        setting: *mut NMSettingWireless,
        idx: guint32,
    );
}
extern "C" {
    pub fn nm_setting_wireless_remove_mac_blacklist_item_by_value(
        setting: *mut NMSettingWireless,
        mac: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_clear_mac_blacklist_items(setting: *mut NMSettingWireless);
}
extern "C" {
    pub fn nm_setting_wireless_get_mtu(setting: *mut NMSettingWireless) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_get_hidden(setting: *mut NMSettingWireless) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_get_powersave(setting: *mut NMSettingWireless) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_get_mac_address_randomization(
        setting: *mut NMSettingWireless,
    ) -> NMSettingMacRandomization;
}
extern "C" {
    pub fn nm_setting_wireless_add_seen_bssid(
        setting: *mut NMSettingWireless,
        bssid: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_get_num_seen_bssids(setting: *mut NMSettingWireless) -> guint32;
}
extern "C" {
    pub fn nm_setting_wireless_get_seen_bssid(
        setting: *mut NMSettingWireless,
        i: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wireless_ap_security_compatible(
        s_wireless: *mut NMSettingWireless,
        s_wireless_sec: *mut NMSettingWirelessSecurity,
        ap_flags: NM80211ApFlags,
        ap_wpa: NM80211ApSecurityFlags,
        ap_rsn: NM80211ApSecurityFlags,
        ap_mode: NM80211Mode,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_setting_wireless_get_wake_on_wlan(
        setting: *mut NMSettingWireless,
    ) -> NMSettingWirelessWakeOnWLan;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSettingWpanClass {
    _unused: [u8; 0],
}
pub type NMSettingWpanClass = _NMSettingWpanClass;
extern "C" {
    pub fn nm_setting_wpan_get_type() -> GType;
}
extern "C" {
    pub fn nm_setting_wpan_new() -> *mut NMSetting;
}
extern "C" {
    pub fn nm_setting_wpan_get_mac_address(
        setting: *mut NMSettingWpan,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_setting_wpan_get_pan_id(setting: *mut NMSettingWpan) -> guint16;
}
extern "C" {
    pub fn nm_setting_wpan_get_short_address(setting: *mut NMSettingWpan) -> guint16;
}
extern "C" {
    pub fn nm_setting_wpan_get_page(setting: *mut NMSettingWpan) -> gint16;
}
extern "C" {
    pub fn nm_setting_wpan_get_channel(setting: *mut NMSettingWpan) -> gint16;
}
#[doc = " NMSimpleConnection:"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSimpleConnection {
    pub parent: GObject,
}
#[test]
fn bindgen_test_layout__NMSimpleConnection() {
    assert_eq!(
        ::std::mem::size_of::<_NMSimpleConnection>(),
        24usize,
        concat!("Size of: ", stringify!(_NMSimpleConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_NMSimpleConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_NMSimpleConnection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NMSimpleConnection>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NMSimpleConnection),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMSimpleConnectionClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout_NMSimpleConnectionClass() {
    assert_eq!(
        ::std::mem::size_of::<NMSimpleConnectionClass>(),
        168usize,
        concat!("Size of: ", stringify!(NMSimpleConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMSimpleConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMSimpleConnectionClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMSimpleConnectionClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSimpleConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMSimpleConnectionClass>())).padding as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(NMSimpleConnectionClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_simple_connection_get_type() -> GType;
}
extern "C" {
    pub fn nm_simple_connection_new() -> *mut NMConnection;
}
extern "C" {
    pub fn nm_simple_connection_new_from_dbus(
        dict: *mut GVariant,
        error: *mut *mut GError,
    ) -> *mut NMConnection;
}
extern "C" {
    pub fn nm_simple_connection_new_clone(connection: *mut NMConnection) -> *mut NMConnection;
}
pub const NMVpnServiceState_NM_VPN_SERVICE_STATE_UNKNOWN: NMVpnServiceState = 0;
pub const NMVpnServiceState_NM_VPN_SERVICE_STATE_INIT: NMVpnServiceState = 1;
pub const NMVpnServiceState_NM_VPN_SERVICE_STATE_SHUTDOWN: NMVpnServiceState = 2;
pub const NMVpnServiceState_NM_VPN_SERVICE_STATE_STARTING: NMVpnServiceState = 3;
pub const NMVpnServiceState_NM_VPN_SERVICE_STATE_STARTED: NMVpnServiceState = 4;
pub const NMVpnServiceState_NM_VPN_SERVICE_STATE_STOPPING: NMVpnServiceState = 5;
pub const NMVpnServiceState_NM_VPN_SERVICE_STATE_STOPPED: NMVpnServiceState = 6;
#[doc = " NMVpnServiceState:"]
#[doc = " @NM_VPN_SERVICE_STATE_UNKNOWN: The state of the VPN plugin is unknown."]
#[doc = " @NM_VPN_SERVICE_STATE_INIT: The VPN plugin is initialized."]
#[doc = " @NM_VPN_SERVICE_STATE_SHUTDOWN: Not used."]
#[doc = " @NM_VPN_SERVICE_STATE_STARTING: The plugin is attempting to connect to a VPN server."]
#[doc = " @NM_VPN_SERVICE_STATE_STARTED: The plugin has connected to a VPN server."]
#[doc = " @NM_VPN_SERVICE_STATE_STOPPING: The plugin is disconnecting from the VPN server."]
#[doc = " @NM_VPN_SERVICE_STATE_STOPPED: The plugin has disconnected from the VPN server."]
#[doc = ""]
#[doc = " VPN daemon states"]
pub type NMVpnServiceState = ::std::os::raw::c_uint;
pub const NMVpnConnectionState_NM_VPN_CONNECTION_STATE_UNKNOWN: NMVpnConnectionState = 0;
pub const NMVpnConnectionState_NM_VPN_CONNECTION_STATE_PREPARE: NMVpnConnectionState = 1;
pub const NMVpnConnectionState_NM_VPN_CONNECTION_STATE_NEED_AUTH: NMVpnConnectionState = 2;
pub const NMVpnConnectionState_NM_VPN_CONNECTION_STATE_CONNECT: NMVpnConnectionState = 3;
pub const NMVpnConnectionState_NM_VPN_CONNECTION_STATE_IP_CONFIG_GET: NMVpnConnectionState = 4;
pub const NMVpnConnectionState_NM_VPN_CONNECTION_STATE_ACTIVATED: NMVpnConnectionState = 5;
pub const NMVpnConnectionState_NM_VPN_CONNECTION_STATE_FAILED: NMVpnConnectionState = 6;
pub const NMVpnConnectionState_NM_VPN_CONNECTION_STATE_DISCONNECTED: NMVpnConnectionState = 7;
#[doc = " NMVpnConnectionState:"]
#[doc = " @NM_VPN_CONNECTION_STATE_UNKNOWN: The state of the VPN connection is"]
#[doc = "   unknown."]
#[doc = " @NM_VPN_CONNECTION_STATE_PREPARE: The VPN connection is preparing to"]
#[doc = "   connect."]
#[doc = " @NM_VPN_CONNECTION_STATE_NEED_AUTH: The VPN connection needs authorization"]
#[doc = "   credentials."]
#[doc = " @NM_VPN_CONNECTION_STATE_CONNECT: The VPN connection is being established."]
#[doc = " @NM_VPN_CONNECTION_STATE_IP_CONFIG_GET: The VPN connection is getting an IP"]
#[doc = "   address."]
#[doc = " @NM_VPN_CONNECTION_STATE_ACTIVATED: The VPN connection is active."]
#[doc = " @NM_VPN_CONNECTION_STATE_FAILED: The VPN connection failed."]
#[doc = " @NM_VPN_CONNECTION_STATE_DISCONNECTED: The VPN connection is disconnected."]
#[doc = ""]
#[doc = " VPN connection states"]
pub type NMVpnConnectionState = ::std::os::raw::c_uint;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_UNKNOWN:
    NMVpnConnectionStateReason = 0;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_NONE:
    NMVpnConnectionStateReason = 1;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED:
    NMVpnConnectionStateReason = 2;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED:
    NMVpnConnectionStateReason = 3;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED:
    NMVpnConnectionStateReason = 4;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID:
    NMVpnConnectionStateReason = 5;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT:
    NMVpnConnectionStateReason = 6;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT:
    NMVpnConnectionStateReason = 7;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED:
    NMVpnConnectionStateReason = 8;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS:
    NMVpnConnectionStateReason = 9;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED:
    NMVpnConnectionStateReason = 10;
pub const NMVpnConnectionStateReason_NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED:
    NMVpnConnectionStateReason = 11;
#[doc = " NMVpnConnectionStateReason:"]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_UNKNOWN: The reason for the VPN connection"]
#[doc = "   state change is unknown."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_NONE: No reason was given for the VPN"]
#[doc = "   connection state change."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED: The VPN connection changed"]
#[doc = "   state because the user disconnected it."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED: The VPN connection"]
#[doc = "   changed state because the device it was using was disconnected."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED: The service providing the"]
#[doc = "   VPN connection was stopped."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID: The IP config of the VPN"]
#[doc = "   connection was invalid."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT: The connection attempt to"]
#[doc = "   the VPN service timed out."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT: A timeout occurred"]
#[doc = "   while starting the service providing the VPN connection."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED: Starting the service"]
#[doc = "   starting the service providing the VPN connection failed."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS: Necessary secrets for the VPN"]
#[doc = "   connection were not provided."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED: Authentication to the VPN"]
#[doc = "   server failed."]
#[doc = " @NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED: The connection was"]
#[doc = "   deleted from settings."]
#[doc = ""]
#[doc = " VPN connection state reasons"]
pub type NMVpnConnectionStateReason = ::std::os::raw::c_uint;
pub const NMVpnPluginFailure_NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED: NMVpnPluginFailure = 0;
pub const NMVpnPluginFailure_NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED: NMVpnPluginFailure = 1;
pub const NMVpnPluginFailure_NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG: NMVpnPluginFailure = 2;
#[doc = " NMVpnPluginFailure:"]
#[doc = " @NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED: Login failed."]
#[doc = " @NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED: Connect failed."]
#[doc = " @NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG: Invalid IP configuration returned from"]
#[doc = "   the VPN plugin."]
#[doc = ""]
#[doc = " VPN plugin failure reasons"]
pub type NMVpnPluginFailure = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVpnConnectionClass {
    _unused: [u8; 0],
}
#[doc = " NMVpnConnection:"]
pub type NMVpnConnectionClass = _NMVpnConnectionClass;
extern "C" {
    pub fn nm_vpn_connection_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_connection_get_vpn_state(vpn: *mut NMVpnConnection) -> NMVpnConnectionState;
}
extern "C" {
    pub fn nm_vpn_connection_get_banner(vpn: *mut NMVpnConnection)
        -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVpnPluginInfo {
    _unused: [u8; 0],
}
pub type NMVpnPluginInfo = _NMVpnPluginInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVpnEditorPlugin {
    _unused: [u8; 0],
}
pub type NMVpnEditorPlugin = _NMVpnEditorPlugin;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVpnEditor {
    _unused: [u8; 0],
}
pub type NMVpnEditor = _NMVpnEditor;
pub type NMVpnEditorPluginFactory =
    ::std::option::Option<unsafe extern "C" fn(error: *mut *mut GError) -> *mut NMVpnEditorPlugin>;
extern "C" {
    pub fn nm_vpn_editor_plugin_factory(error: *mut *mut GError) -> *mut NMVpnEditorPlugin;
}
pub const NMVpnEditorPluginCapability_NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE:
    NMVpnEditorPluginCapability = 0;
pub const NMVpnEditorPluginCapability_NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT:
    NMVpnEditorPluginCapability = 1;
pub const NMVpnEditorPluginCapability_NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT:
    NMVpnEditorPluginCapability = 2;
pub const NMVpnEditorPluginCapability_NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6:
    NMVpnEditorPluginCapability = 4;
#[doc = " NMVpnEditorPluginCapability:"]
#[doc = " @NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE: unknown or no capability"]
#[doc = " @NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT: the plugin can import new connections"]
#[doc = " @NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT: the plugin can export connections"]
#[doc = " @NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6: the plugin supports IPv6 addressing"]
#[doc = ""]
#[doc = " Flags that indicate certain capabilities of the plugin to editor programs."]
pub type NMVpnEditorPluginCapability = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVpnEditorPluginVT {
    _unused: [u8; 0],
}
pub type NMVpnEditorPluginVT = _NMVpnEditorPluginVT;
#[doc = " NMVpnEditorPluginInterface:"]
#[doc = " @g_iface: the parent interface"]
#[doc = " @get_editor: returns an #NMVpnEditor, pre-filled with values from @connection"]
#[doc = "   if non-%NULL."]
#[doc = " @get_capabilities: returns a bitmask of capabilities."]
#[doc = " @import_from_file: Try to import a connection from the specified path.  On"]
#[doc = "   success, return a partial #NMConnection object.  On error, return %NULL and"]
#[doc = "   set @error with additional information.  Note that @error can be %NULL, in"]
#[doc = "   which case no additional error information should be provided."]
#[doc = " @export_to_file: Export the given connection to the specified path.  Return"]
#[doc = "   %TRUE on success.  On error, return %FALSE and set @error with additional"]
#[doc = "   error information.  Note that @error can be %NULL, in which case no"]
#[doc = "   additional error information should be provided."]
#[doc = " @get_suggested_filename: For a given connection, return a suggested file"]
#[doc = "   name.  Returned value will be %NULL or a suggested file name to be freed by"]
#[doc = "   the caller."]
#[doc = " @notify_plugin_info_set: A callback to be called when the plugin info is set."]
#[doc = " @get_vt: return a virtual function table to implement further functions in"]
#[doc = "   the plugin, without requiring to update libnm. Used by nm_vpn_editor_plugin_get_vt()."]
#[doc = ""]
#[doc = " Interface for VPN editor plugins."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMVpnEditorPluginInterface {
    pub g_iface: GTypeInterface,
    pub get_editor: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnEditorPlugin,
            connection: *mut NMConnection,
            error: *mut *mut GError,
        ) -> *mut NMVpnEditor,
    >,
    pub get_capabilities: ::std::option::Option<
        unsafe extern "C" fn(plugin: *mut NMVpnEditorPlugin) -> NMVpnEditorPluginCapability,
    >,
    pub import_from_file: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnEditorPlugin,
            path: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> *mut NMConnection,
    >,
    pub export_to_file: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnEditorPlugin,
            path: *const ::std::os::raw::c_char,
            connection: *mut NMConnection,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_suggested_filename: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnEditorPlugin,
            connection: *mut NMConnection,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub notify_plugin_info_set: ::std::option::Option<
        unsafe extern "C" fn(plugin: *mut NMVpnEditorPlugin, plugin_info: *mut NMVpnPluginInfo),
    >,
    pub get_vt: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnEditorPlugin,
            out_vt_size: *mut gsize,
        ) -> *const NMVpnEditorPluginVT,
    >,
}
#[test]
fn bindgen_test_layout_NMVpnEditorPluginInterface() {
    assert_eq!(
        ::std::mem::size_of::<NMVpnEditorPluginInterface>(),
        72usize,
        concat!("Size of: ", stringify!(NMVpnEditorPluginInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<NMVpnEditorPluginInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(NMVpnEditorPluginInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorPluginInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorPluginInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorPluginInterface>())).get_editor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorPluginInterface),
            "::",
            stringify!(get_editor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorPluginInterface>())).get_capabilities as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorPluginInterface),
            "::",
            stringify!(get_capabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorPluginInterface>())).import_from_file as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorPluginInterface),
            "::",
            stringify!(import_from_file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorPluginInterface>())).export_to_file as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorPluginInterface),
            "::",
            stringify!(export_to_file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorPluginInterface>())).get_suggested_filename
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorPluginInterface),
            "::",
            stringify!(get_suggested_filename)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorPluginInterface>())).notify_plugin_info_set
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorPluginInterface),
            "::",
            stringify!(notify_plugin_info_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorPluginInterface>())).get_vt as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorPluginInterface),
            "::",
            stringify!(get_vt)
        )
    );
}
extern "C" {
    pub fn nm_vpn_editor_plugin_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_get_editor(
        plugin: *mut NMVpnEditorPlugin,
        connection: *mut NMConnection,
        error: *mut *mut GError,
    ) -> *mut NMVpnEditor;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_get_capabilities(
        plugin: *mut NMVpnEditorPlugin,
    ) -> NMVpnEditorPluginCapability;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_get_vt(
        plugin: *mut NMVpnEditorPlugin,
        vt: *mut NMVpnEditorPluginVT,
        vt_size: gsize,
    ) -> gsize;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_import(
        plugin: *mut NMVpnEditorPlugin,
        path: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMConnection;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_export(
        plugin: *mut NMVpnEditorPlugin,
        path: *const ::std::os::raw::c_char,
        connection: *mut NMConnection,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_get_suggested_filename(
        plugin: *mut NMVpnEditorPlugin,
        connection: *mut NMConnection,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_load_from_file(
        plugin_name: *const ::std::os::raw::c_char,
        check_service: *const ::std::os::raw::c_char,
        check_owner: ::std::os::raw::c_int,
        check_file: NMUtilsCheckFilePredicate,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut NMVpnEditorPlugin;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_load(
        plugin_name: *const ::std::os::raw::c_char,
        check_service: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMVpnEditorPlugin;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_get_plugin_info(
        plugin: *mut NMVpnEditorPlugin,
    ) -> *mut NMVpnPluginInfo;
}
extern "C" {
    pub fn nm_vpn_editor_plugin_set_plugin_info(
        plugin: *mut NMVpnEditorPlugin,
        plugin_info: *mut NMVpnPluginInfo,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVpnPluginInfoClass {
    _unused: [u8; 0],
}
pub type NMVpnPluginInfoClass = _NMVpnPluginInfoClass;
extern "C" {
    pub fn nm_vpn_plugin_info_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_plugin_info_new_from_file(
        filename: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut NMVpnPluginInfo;
}
extern "C" {
    pub fn nm_vpn_plugin_info_new_with_data(
        filename: *const ::std::os::raw::c_char,
        keyfile: *mut GKeyFile,
        error: *mut *mut GError,
    ) -> *mut NMVpnPluginInfo;
}
extern "C" {
    pub fn nm_vpn_plugin_info_new_search_file(
        name: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
    ) -> *mut NMVpnPluginInfo;
}
extern "C" {
    pub fn nm_vpn_plugin_info_get_name(
        self_: *mut NMVpnPluginInfo,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_get_filename(
        self_: *mut NMVpnPluginInfo,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_get_service(
        self_: *mut NMVpnPluginInfo,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_get_plugin(
        self_: *mut NMVpnPluginInfo,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_get_program(
        self_: *mut NMVpnPluginInfo,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_get_auth_dialog(
        self_: *mut NMVpnPluginInfo,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_supports_hints(self_: *mut NMVpnPluginInfo) -> gboolean;
}
extern "C" {
    pub fn nm_vpn_plugin_info_supports_multiple(self_: *mut NMVpnPluginInfo) -> gboolean;
}
extern "C" {
    pub fn nm_vpn_plugin_info_get_aliases(
        self_: *mut NMVpnPluginInfo,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_lookup_property(
        self_: *mut NMVpnPluginInfo,
        group: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_validate_filename(
        filename: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_vpn_plugin_info_list_load() -> *mut GSList;
}
extern "C" {
    pub fn nm_vpn_plugin_info_list_add(
        list: *mut *mut GSList,
        plugin_info: *mut NMVpnPluginInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_vpn_plugin_info_list_remove(
        list: *mut *mut GSList,
        plugin_info: *mut NMVpnPluginInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_vpn_plugin_info_list_find_by_name(
        list: *mut GSList,
        name: *const ::std::os::raw::c_char,
    ) -> *mut NMVpnPluginInfo;
}
extern "C" {
    pub fn nm_vpn_plugin_info_list_find_by_filename(
        list: *mut GSList,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut NMVpnPluginInfo;
}
extern "C" {
    pub fn nm_vpn_plugin_info_list_find_by_service(
        list: *mut GSList,
        service: *const ::std::os::raw::c_char,
    ) -> *mut NMVpnPluginInfo;
}
extern "C" {
    pub fn nm_vpn_plugin_info_list_find_service_type(
        list: *mut GSList,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_list_get_service_types(
        list: *mut GSList,
        only_existing: gboolean,
        with_abbreviations: gboolean,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_vpn_plugin_info_get_editor_plugin(
        self_: *mut NMVpnPluginInfo,
    ) -> *mut NMVpnEditorPlugin;
}
extern "C" {
    pub fn nm_vpn_plugin_info_set_editor_plugin(
        self_: *mut NMVpnPluginInfo,
        plugin: *mut NMVpnEditorPlugin,
    );
}
extern "C" {
    pub fn nm_vpn_plugin_info_load_editor_plugin(
        self_: *mut NMVpnPluginInfo,
        error: *mut *mut GError,
    ) -> *mut NMVpnEditorPlugin;
}
#[doc = " NMVpnEditorInterface:"]
#[doc = " @g_iface: the parent interface"]
#[doc = " @get_widget: return the #GtkWidget for the VPN editor's UI"]
#[doc = " @placeholder: not currently used"]
#[doc = " @update_connection: called to save the user-entered options to the connection"]
#[doc = "   object.  Should return %FALSE and set @error if the current options are"]
#[doc = "   invalid.  @error should contain enough information for the plugin to"]
#[doc = "   determine which UI widget is invalid at a later point in time.  For"]
#[doc = "   example, creating unique error codes for what error occurred and populating"]
#[doc = "   the message field of @error with the name of the invalid property."]
#[doc = " @changed: emitted when the value of a UI widget changes.  May trigger a"]
#[doc = "   validity check via @update_connection to write values to the connection."]
#[doc = ""]
#[doc = " Interface for editing a specific #NMConnection"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMVpnEditorInterface {
    pub g_iface: GTypeInterface,
    pub get_widget:
        ::std::option::Option<unsafe extern "C" fn(editor: *mut NMVpnEditor) -> *mut GObject>,
    pub placeholder: ::std::option::Option<unsafe extern "C" fn()>,
    pub update_connection: ::std::option::Option<
        unsafe extern "C" fn(
            editor: *mut NMVpnEditor,
            connection: *mut NMConnection,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub changed: ::std::option::Option<unsafe extern "C" fn(editor: *mut NMVpnEditor)>,
}
#[test]
fn bindgen_test_layout_NMVpnEditorInterface() {
    assert_eq!(
        ::std::mem::size_of::<NMVpnEditorInterface>(),
        48usize,
        concat!("Size of: ", stringify!(NMVpnEditorInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<NMVpnEditorInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(NMVpnEditorInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnEditorInterface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnEditorInterface>())).get_widget as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorInterface),
            "::",
            stringify!(get_widget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorInterface>())).placeholder as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorInterface),
            "::",
            stringify!(placeholder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnEditorInterface>())).update_connection as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorInterface),
            "::",
            stringify!(update_connection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnEditorInterface>())).changed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnEditorInterface),
            "::",
            stringify!(changed)
        )
    );
}
extern "C" {
    pub fn nm_vpn_editor_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_editor_get_widget(editor: *mut NMVpnEditor) -> *mut GObject;
}
extern "C" {
    pub fn nm_vpn_editor_update_connection(
        editor: *mut NMVpnEditor,
        connection: *mut NMConnection,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " NMVpnServicePlugin:"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMVpnServicePlugin {
    pub parent: GObject,
}
#[test]
fn bindgen_test_layout_NMVpnServicePlugin() {
    assert_eq!(
        ::std::mem::size_of::<NMVpnServicePlugin>(),
        24usize,
        concat!("Size of: ", stringify!(NMVpnServicePlugin))
    );
    assert_eq!(
        ::std::mem::align_of::<NMVpnServicePlugin>(),
        8usize,
        concat!("Alignment of ", stringify!(NMVpnServicePlugin))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnServicePlugin>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePlugin),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMVpnServicePluginClass {
    pub parent: GObjectClass,
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(plugin: *mut NMVpnServicePlugin, state: NMVpnServiceState),
    >,
    pub ip4_config: ::std::option::Option<
        unsafe extern "C" fn(plugin: *mut NMVpnServicePlugin, ip4_config: *mut GVariant),
    >,
    pub login_banner: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnServicePlugin,
            banner: *const ::std::os::raw::c_char,
        ),
    >,
    pub failure: ::std::option::Option<
        unsafe extern "C" fn(plugin: *mut NMVpnServicePlugin, reason: NMVpnPluginFailure),
    >,
    pub quit: ::std::option::Option<unsafe extern "C" fn(plugin: *mut NMVpnServicePlugin)>,
    pub config: ::std::option::Option<
        unsafe extern "C" fn(plugin: *mut NMVpnServicePlugin, config: *mut GVariant),
    >,
    pub ip6_config: ::std::option::Option<
        unsafe extern "C" fn(plugin: *mut NMVpnServicePlugin, config: *mut GVariant),
    >,
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnServicePlugin,
            connection: *mut NMConnection,
            err: *mut *mut GError,
        ) -> gboolean,
    >,
    pub need_secrets: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnServicePlugin,
            connection: *mut NMConnection,
            setting_name: *mut *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub disconnect: ::std::option::Option<
        unsafe extern "C" fn(plugin: *mut NMVpnServicePlugin, err: *mut *mut GError) -> gboolean,
    >,
    pub new_secrets: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnServicePlugin,
            connection: *mut NMConnection,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub connect_interactive: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: *mut NMVpnServicePlugin,
            connection: *mut NMConnection,
            details: *mut GVariant,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout_NMVpnServicePluginClass() {
    assert_eq!(
        ::std::mem::size_of::<NMVpnServicePluginClass>(),
        296usize,
        concat!("Size of: ", stringify!(NMVpnServicePluginClass))
    );
    assert_eq!(
        ::std::mem::align_of::<NMVpnServicePluginClass>(),
        8usize,
        concat!("Alignment of ", stringify!(NMVpnServicePluginClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnServicePluginClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnServicePluginClass>())).state_changed as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(state_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnServicePluginClass>())).ip4_config as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(ip4_config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnServicePluginClass>())).login_banner as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(login_banner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnServicePluginClass>())).failure as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(failure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnServicePluginClass>())).quit as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnServicePluginClass>())).config as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnServicePluginClass>())).ip6_config as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(ip6_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnServicePluginClass>())).connect as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnServicePluginClass>())).need_secrets as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(need_secrets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnServicePluginClass>())).disconnect as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(disconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnServicePluginClass>())).new_secrets as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(new_secrets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMVpnServicePluginClass>())).connect_interactive as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(connect_interactive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMVpnServicePluginClass>())).padding as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(NMVpnServicePluginClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn nm_vpn_service_plugin_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_service_plugin_get_connection(
        plugin: *mut NMVpnServicePlugin,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn nm_vpn_service_plugin_secrets_required(
        plugin: *mut NMVpnServicePlugin,
        message: *const ::std::os::raw::c_char,
        hints: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_vpn_service_plugin_set_login_banner(
        plugin: *mut NMVpnServicePlugin,
        banner: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn nm_vpn_service_plugin_failure(
        plugin: *mut NMVpnServicePlugin,
        reason: NMVpnPluginFailure,
    );
}
extern "C" {
    pub fn nm_vpn_service_plugin_set_config(plugin: *mut NMVpnServicePlugin, config: *mut GVariant);
}
extern "C" {
    pub fn nm_vpn_service_plugin_set_ip4_config(
        plugin: *mut NMVpnServicePlugin,
        ip4_config: *mut GVariant,
    );
}
extern "C" {
    pub fn nm_vpn_service_plugin_set_ip6_config(
        plugin: *mut NMVpnServicePlugin,
        ip6_config: *mut GVariant,
    );
}
extern "C" {
    pub fn nm_vpn_service_plugin_disconnect(
        plugin: *mut NMVpnServicePlugin,
        err: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_vpn_service_plugin_shutdown(plugin: *mut NMVpnServicePlugin);
}
extern "C" {
    pub fn nm_vpn_service_plugin_read_vpn_details(
        fd: ::std::os::raw::c_int,
        out_data: *mut *mut GHashTable,
        out_secrets: *mut *mut GHashTable,
    ) -> gboolean;
}
extern "C" {
    pub fn nm_vpn_service_plugin_get_secret_flags(
        data: *mut GHashTable,
        secret_name: *const ::std::os::raw::c_char,
        out_flags: *mut NMSettingSecretFlags,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMWifiP2PPeerClass {
    _unused: [u8; 0],
}
#[doc = " NMWifiP2PPeer:"]
pub type NMWifiP2PPeerClass = _NMWifiP2PPeerClass;
extern "C" {
    pub fn nm_wifi_p2p_peer_get_type() -> GType;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_flags(peer: *mut NMWifiP2PPeer) -> NM80211ApFlags;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_name(peer: *mut NMWifiP2PPeer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_manufacturer(
        peer: *mut NMWifiP2PPeer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_model(peer: *mut NMWifiP2PPeer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_model_number(
        peer: *mut NMWifiP2PPeer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_serial(peer: *mut NMWifiP2PPeer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_wfd_ies(peer: *mut NMWifiP2PPeer) -> *mut GBytes;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_hw_address(
        peer: *mut NMWifiP2PPeer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_strength(peer: *mut NMWifiP2PPeer) -> guint8;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_get_last_seen(peer: *mut NMWifiP2PPeer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_filter_connections(
        peer: *mut NMWifiP2PPeer,
        connections: *const GPtrArray,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_wifi_p2p_peer_connection_valid(
        peer: *mut NMWifiP2PPeer,
        connection: *mut NMConnection,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMWimaxNspClass {
    _unused: [u8; 0],
}
#[doc = " NMWimaxNsp:"]
#[doc = ""]
#[doc = " Deprecated: 1.22: WiMAX is no longer supported by NetworkManager since 1.2.0."]
pub type NMWimaxNspClass = _NMWimaxNspClass;
extern "C" {
    pub fn nm_wimax_nsp_get_type() -> GType;
}
extern "C" {
    pub fn nm_wimax_nsp_get_name(nsp: *mut NMWimaxNsp) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nm_wimax_nsp_get_signal_quality(nsp: *mut NMWimaxNsp) -> guint32;
}
extern "C" {
    pub fn nm_wimax_nsp_get_network_type(nsp: *mut NMWimaxNsp) -> NMWimaxNspNetworkType;
}
extern "C" {
    pub fn nm_wimax_nsp_filter_connections(
        nsp: *mut NMWimaxNsp,
        connections: *const GPtrArray,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn nm_wimax_nsp_connection_valid(
        nsp: *mut NMWimaxNsp,
        connection: *mut NMConnection,
    ) -> gboolean;
}
pub type NMClient_autoptr = *mut NMClient;
pub type NMClient_listautoptr = *mut GList;
pub type NMClient_slistautoptr = *mut GSList;
pub type NMClient_queueautoptr = *mut GQueue;
pub type NMAccessPoint_autoptr = *mut NMAccessPoint;
pub type NMAccessPoint_listautoptr = *mut GList;
pub type NMAccessPoint_slistautoptr = *mut GSList;
pub type NMAccessPoint_queueautoptr = *mut GQueue;
pub type NMActiveConnection_autoptr = *mut NMActiveConnection;
pub type NMActiveConnection_listautoptr = *mut GList;
pub type NMActiveConnection_slistautoptr = *mut GSList;
pub type NMActiveConnection_queueautoptr = *mut GQueue;
pub type NMCheckpoint_autoptr = *mut NMCheckpoint;
pub type NMCheckpoint_listautoptr = *mut GList;
pub type NMCheckpoint_slistautoptr = *mut GSList;
pub type NMCheckpoint_queueautoptr = *mut GQueue;
pub type NMConnection_autoptr = *mut NMConnection;
pub type NMConnection_listautoptr = *mut GList;
pub type NMConnection_slistautoptr = *mut GSList;
pub type NMConnection_queueautoptr = *mut GQueue;
pub type NMDevice_autoptr = *mut NMDevice;
pub type NMDevice_listautoptr = *mut GList;
pub type NMDevice_slistautoptr = *mut GSList;
pub type NMDevice_queueautoptr = *mut GQueue;
pub type NMDhcpConfig_autoptr = *mut NMDhcpConfig;
pub type NMDhcpConfig_listautoptr = *mut GList;
pub type NMDhcpConfig_slistautoptr = *mut GSList;
pub type NMDhcpConfig_queueautoptr = *mut GQueue;
pub type NMIPConfig_autoptr = *mut NMIPConfig;
pub type NMIPConfig_listautoptr = *mut GList;
pub type NMIPConfig_slistautoptr = *mut GSList;
pub type NMIPConfig_queueautoptr = *mut GQueue;
pub type NMObject_autoptr = *mut NMObject;
pub type NMObject_listautoptr = *mut GList;
pub type NMObject_slistautoptr = *mut GSList;
pub type NMObject_queueautoptr = *mut GQueue;
pub type NMRemoteConnection_autoptr = *mut NMRemoteConnection;
pub type NMRemoteConnection_listautoptr = *mut GList;
pub type NMRemoteConnection_slistautoptr = *mut GSList;
pub type NMRemoteConnection_queueautoptr = *mut GQueue;
pub type NMSetting_autoptr = *mut NMSetting;
pub type NMSetting_listautoptr = *mut GList;
pub type NMSetting_slistautoptr = *mut GSList;
pub type NMSetting_queueautoptr = *mut GQueue;
pub type NMSimpleConnection_autoptr = *mut NMSimpleConnection;
pub type NMSimpleConnection_listautoptr = *mut GList;
pub type NMSimpleConnection_slistautoptr = *mut GSList;
pub type NMSimpleConnection_queueautoptr = *mut GQueue;
pub type NMWifiP2PPeer_autoptr = *mut NMWifiP2PPeer;
pub type NMWifiP2PPeer_listautoptr = *mut GList;
pub type NMWifiP2PPeer_slistautoptr = *mut GSList;
pub type NMWifiP2PPeer_queueautoptr = *mut GQueue;
pub type NMWimaxNsp_autoptr = *mut NMWimaxNsp;
pub type NMWimaxNsp_listautoptr = *mut GList;
pub type NMWimaxNsp_slistautoptr = *mut GSList;
pub type NMWimaxNsp_queueautoptr = *mut GQueue;
pub type NMDevice6Lowpan_autoptr = *mut NMDevice6Lowpan;
pub type NMDevice6Lowpan_listautoptr = *mut GList;
pub type NMDevice6Lowpan_slistautoptr = *mut GSList;
pub type NMDevice6Lowpan_queueautoptr = *mut GQueue;
pub type NMDeviceAdsl_autoptr = *mut NMDeviceAdsl;
pub type NMDeviceAdsl_listautoptr = *mut GList;
pub type NMDeviceAdsl_slistautoptr = *mut GSList;
pub type NMDeviceAdsl_queueautoptr = *mut GQueue;
pub type NMDeviceBond_autoptr = *mut NMDeviceBond;
pub type NMDeviceBond_listautoptr = *mut GList;
pub type NMDeviceBond_slistautoptr = *mut GSList;
pub type NMDeviceBond_queueautoptr = *mut GQueue;
pub type NMDeviceBridge_autoptr = *mut NMDeviceBridge;
pub type NMDeviceBridge_listautoptr = *mut GList;
pub type NMDeviceBridge_slistautoptr = *mut GSList;
pub type NMDeviceBridge_queueautoptr = *mut GQueue;
pub type NMDeviceBt_autoptr = *mut NMDeviceBt;
pub type NMDeviceBt_listautoptr = *mut GList;
pub type NMDeviceBt_slistautoptr = *mut GSList;
pub type NMDeviceBt_queueautoptr = *mut GQueue;
pub type NMDeviceDummy_autoptr = *mut NMDeviceDummy;
pub type NMDeviceDummy_listautoptr = *mut GList;
pub type NMDeviceDummy_slistautoptr = *mut GSList;
pub type NMDeviceDummy_queueautoptr = *mut GQueue;
pub type NMDeviceEthernet_autoptr = *mut NMDeviceEthernet;
pub type NMDeviceEthernet_listautoptr = *mut GList;
pub type NMDeviceEthernet_slistautoptr = *mut GSList;
pub type NMDeviceEthernet_queueautoptr = *mut GQueue;
pub type NMDeviceGeneric_autoptr = *mut NMDeviceGeneric;
pub type NMDeviceGeneric_listautoptr = *mut GList;
pub type NMDeviceGeneric_slistautoptr = *mut GSList;
pub type NMDeviceGeneric_queueautoptr = *mut GQueue;
pub type NMDeviceIPTunnel_autoptr = *mut NMDeviceIPTunnel;
pub type NMDeviceIPTunnel_listautoptr = *mut GList;
pub type NMDeviceIPTunnel_slistautoptr = *mut GSList;
pub type NMDeviceIPTunnel_queueautoptr = *mut GQueue;
pub type NMDeviceInfiniband_autoptr = *mut NMDeviceInfiniband;
pub type NMDeviceInfiniband_listautoptr = *mut GList;
pub type NMDeviceInfiniband_slistautoptr = *mut GSList;
pub type NMDeviceInfiniband_queueautoptr = *mut GQueue;
pub type NMDeviceMacsec_autoptr = *mut NMDeviceMacsec;
pub type NMDeviceMacsec_listautoptr = *mut GList;
pub type NMDeviceMacsec_slistautoptr = *mut GSList;
pub type NMDeviceMacsec_queueautoptr = *mut GQueue;
pub type NMDeviceMacvlan_autoptr = *mut NMDeviceMacvlan;
pub type NMDeviceMacvlan_listautoptr = *mut GList;
pub type NMDeviceMacvlan_slistautoptr = *mut GSList;
pub type NMDeviceMacvlan_queueautoptr = *mut GQueue;
pub type NMDeviceModem_autoptr = *mut NMDeviceModem;
pub type NMDeviceModem_listautoptr = *mut GList;
pub type NMDeviceModem_slistautoptr = *mut GSList;
pub type NMDeviceModem_queueautoptr = *mut GQueue;
pub type NMDeviceOlpcMesh_autoptr = *mut NMDeviceOlpcMesh;
pub type NMDeviceOlpcMesh_listautoptr = *mut GList;
pub type NMDeviceOlpcMesh_slistautoptr = *mut GSList;
pub type NMDeviceOlpcMesh_queueautoptr = *mut GQueue;
pub type NMDeviceOvsBridge_autoptr = *mut NMDeviceOvsBridge;
pub type NMDeviceOvsBridge_listautoptr = *mut GList;
pub type NMDeviceOvsBridge_slistautoptr = *mut GSList;
pub type NMDeviceOvsBridge_queueautoptr = *mut GQueue;
pub type NMDeviceOvsInterface_autoptr = *mut NMDeviceOvsInterface;
pub type NMDeviceOvsInterface_listautoptr = *mut GList;
pub type NMDeviceOvsInterface_slistautoptr = *mut GSList;
pub type NMDeviceOvsInterface_queueautoptr = *mut GQueue;
pub type NMDeviceOvsPort_autoptr = *mut NMDeviceOvsPort;
pub type NMDeviceOvsPort_listautoptr = *mut GList;
pub type NMDeviceOvsPort_slistautoptr = *mut GSList;
pub type NMDeviceOvsPort_queueautoptr = *mut GQueue;
pub type NMDevicePpp_autoptr = *mut NMDevicePpp;
pub type NMDevicePpp_listautoptr = *mut GList;
pub type NMDevicePpp_slistautoptr = *mut GSList;
pub type NMDevicePpp_queueautoptr = *mut GQueue;
pub type NMDeviceTeam_autoptr = *mut NMDeviceTeam;
pub type NMDeviceTeam_listautoptr = *mut GList;
pub type NMDeviceTeam_slistautoptr = *mut GSList;
pub type NMDeviceTeam_queueautoptr = *mut GQueue;
pub type NMDeviceTun_autoptr = *mut NMDeviceTun;
pub type NMDeviceTun_listautoptr = *mut GList;
pub type NMDeviceTun_slistautoptr = *mut GSList;
pub type NMDeviceTun_queueautoptr = *mut GQueue;
pub type NMDeviceVlan_autoptr = *mut NMDeviceVlan;
pub type NMDeviceVlan_listautoptr = *mut GList;
pub type NMDeviceVlan_slistautoptr = *mut GSList;
pub type NMDeviceVlan_queueautoptr = *mut GQueue;
pub type NMDeviceVxlan_autoptr = *mut NMDeviceVxlan;
pub type NMDeviceVxlan_listautoptr = *mut GList;
pub type NMDeviceVxlan_slistautoptr = *mut GSList;
pub type NMDeviceVxlan_queueautoptr = *mut GQueue;
pub type NMDeviceWifi_autoptr = *mut NMDeviceWifi;
pub type NMDeviceWifi_listautoptr = *mut GList;
pub type NMDeviceWifi_slistautoptr = *mut GSList;
pub type NMDeviceWifi_queueautoptr = *mut GQueue;
pub type NMDeviceWifiP2P_autoptr = *mut NMDeviceWifiP2P;
pub type NMDeviceWifiP2P_listautoptr = *mut GList;
pub type NMDeviceWifiP2P_slistautoptr = *mut GSList;
pub type NMDeviceWifiP2P_queueautoptr = *mut GQueue;
pub type NMDeviceWimax_autoptr = *mut NMDeviceWimax;
pub type NMDeviceWimax_listautoptr = *mut GList;
pub type NMDeviceWimax_slistautoptr = *mut GSList;
pub type NMDeviceWimax_queueautoptr = *mut GQueue;
pub type NMDeviceWireGuard_autoptr = *mut NMDeviceWireGuard;
pub type NMDeviceWireGuard_listautoptr = *mut GList;
pub type NMDeviceWireGuard_slistautoptr = *mut GSList;
pub type NMDeviceWireGuard_queueautoptr = *mut GQueue;
pub type NMDeviceWpan_autoptr = *mut NMDeviceWpan;
pub type NMDeviceWpan_listautoptr = *mut GList;
pub type NMDeviceWpan_slistautoptr = *mut GSList;
pub type NMDeviceWpan_queueautoptr = *mut GQueue;
pub type NMSetting6Lowpan_autoptr = *mut NMSetting6Lowpan;
pub type NMSetting6Lowpan_listautoptr = *mut GList;
pub type NMSetting6Lowpan_slistautoptr = *mut GSList;
pub type NMSetting6Lowpan_queueautoptr = *mut GQueue;
pub type NMSetting8021x_autoptr = *mut NMSetting8021x;
pub type NMSetting8021x_listautoptr = *mut GList;
pub type NMSetting8021x_slistautoptr = *mut GSList;
pub type NMSetting8021x_queueautoptr = *mut GQueue;
pub type NMSettingAdsl_autoptr = *mut NMSettingAdsl;
pub type NMSettingAdsl_listautoptr = *mut GList;
pub type NMSettingAdsl_slistautoptr = *mut GSList;
pub type NMSettingAdsl_queueautoptr = *mut GQueue;
pub type NMSettingBluetooth_autoptr = *mut NMSettingBluetooth;
pub type NMSettingBluetooth_listautoptr = *mut GList;
pub type NMSettingBluetooth_slistautoptr = *mut GSList;
pub type NMSettingBluetooth_queueautoptr = *mut GQueue;
pub type NMSettingBond_autoptr = *mut NMSettingBond;
pub type NMSettingBond_listautoptr = *mut GList;
pub type NMSettingBond_slistautoptr = *mut GSList;
pub type NMSettingBond_queueautoptr = *mut GQueue;
pub type NMSettingBridge_autoptr = *mut NMSettingBridge;
pub type NMSettingBridge_listautoptr = *mut GList;
pub type NMSettingBridge_slistautoptr = *mut GSList;
pub type NMSettingBridge_queueautoptr = *mut GQueue;
pub type NMSettingBridgePort_autoptr = *mut NMSettingBridgePort;
pub type NMSettingBridgePort_listautoptr = *mut GList;
pub type NMSettingBridgePort_slistautoptr = *mut GSList;
pub type NMSettingBridgePort_queueautoptr = *mut GQueue;
pub type NMSettingCdma_autoptr = *mut NMSettingCdma;
pub type NMSettingCdma_listautoptr = *mut GList;
pub type NMSettingCdma_slistautoptr = *mut GSList;
pub type NMSettingCdma_queueautoptr = *mut GQueue;
pub type NMSettingConnection_autoptr = *mut NMSettingConnection;
pub type NMSettingConnection_listautoptr = *mut GList;
pub type NMSettingConnection_slistautoptr = *mut GSList;
pub type NMSettingConnection_queueautoptr = *mut GQueue;
pub type NMSettingDcb_autoptr = *mut NMSettingDcb;
pub type NMSettingDcb_listautoptr = *mut GList;
pub type NMSettingDcb_slistautoptr = *mut GSList;
pub type NMSettingDcb_queueautoptr = *mut GQueue;
pub type NMSettingDummy_autoptr = *mut NMSettingDummy;
pub type NMSettingDummy_listautoptr = *mut GList;
pub type NMSettingDummy_slistautoptr = *mut GSList;
pub type NMSettingDummy_queueautoptr = *mut GQueue;
pub type NMSettingEthtool_autoptr = *mut NMSettingEthtool;
pub type NMSettingEthtool_listautoptr = *mut GList;
pub type NMSettingEthtool_slistautoptr = *mut GSList;
pub type NMSettingEthtool_queueautoptr = *mut GQueue;
pub type NMSettingGeneric_autoptr = *mut NMSettingGeneric;
pub type NMSettingGeneric_listautoptr = *mut GList;
pub type NMSettingGeneric_slistautoptr = *mut GSList;
pub type NMSettingGeneric_queueautoptr = *mut GQueue;
pub type NMSettingGsm_autoptr = *mut NMSettingGsm;
pub type NMSettingGsm_listautoptr = *mut GList;
pub type NMSettingGsm_slistautoptr = *mut GSList;
pub type NMSettingGsm_queueautoptr = *mut GQueue;
pub type NMSettingIP4Config_autoptr = *mut NMSettingIP4Config;
pub type NMSettingIP4Config_listautoptr = *mut GList;
pub type NMSettingIP4Config_slistautoptr = *mut GSList;
pub type NMSettingIP4Config_queueautoptr = *mut GQueue;
pub type NMSettingIP6Config_autoptr = *mut NMSettingIP6Config;
pub type NMSettingIP6Config_listautoptr = *mut GList;
pub type NMSettingIP6Config_slistautoptr = *mut GSList;
pub type NMSettingIP6Config_queueautoptr = *mut GQueue;
pub type NMSettingIPConfig_autoptr = *mut NMSettingIPConfig;
pub type NMSettingIPConfig_listautoptr = *mut GList;
pub type NMSettingIPConfig_slistautoptr = *mut GSList;
pub type NMSettingIPConfig_queueautoptr = *mut GQueue;
pub type NMSettingIPTunnel_autoptr = *mut NMSettingIPTunnel;
pub type NMSettingIPTunnel_listautoptr = *mut GList;
pub type NMSettingIPTunnel_slistautoptr = *mut GSList;
pub type NMSettingIPTunnel_queueautoptr = *mut GQueue;
pub type NMSettingInfiniband_autoptr = *mut NMSettingInfiniband;
pub type NMSettingInfiniband_listautoptr = *mut GList;
pub type NMSettingInfiniband_slistautoptr = *mut GSList;
pub type NMSettingInfiniband_queueautoptr = *mut GQueue;
pub type NMSettingMacsec_autoptr = *mut NMSettingMacsec;
pub type NMSettingMacsec_listautoptr = *mut GList;
pub type NMSettingMacsec_slistautoptr = *mut GSList;
pub type NMSettingMacsec_queueautoptr = *mut GQueue;
pub type NMSettingMacvlan_autoptr = *mut NMSettingMacvlan;
pub type NMSettingMacvlan_listautoptr = *mut GList;
pub type NMSettingMacvlan_slistautoptr = *mut GSList;
pub type NMSettingMacvlan_queueautoptr = *mut GQueue;
pub type NMSettingMatch_autoptr = *mut NMSettingMatch;
pub type NMSettingMatch_listautoptr = *mut GList;
pub type NMSettingMatch_slistautoptr = *mut GSList;
pub type NMSettingMatch_queueautoptr = *mut GQueue;
pub type NMSettingOlpcMesh_autoptr = *mut NMSettingOlpcMesh;
pub type NMSettingOlpcMesh_listautoptr = *mut GList;
pub type NMSettingOlpcMesh_slistautoptr = *mut GSList;
pub type NMSettingOlpcMesh_queueautoptr = *mut GQueue;
pub type NMSettingOvsBridge_autoptr = *mut NMSettingOvsBridge;
pub type NMSettingOvsBridge_listautoptr = *mut GList;
pub type NMSettingOvsBridge_slistautoptr = *mut GSList;
pub type NMSettingOvsBridge_queueautoptr = *mut GQueue;
pub type NMSettingOvsInterface_autoptr = *mut NMSettingOvsInterface;
pub type NMSettingOvsInterface_listautoptr = *mut GList;
pub type NMSettingOvsInterface_slistautoptr = *mut GSList;
pub type NMSettingOvsInterface_queueautoptr = *mut GQueue;
pub type NMSettingOvsPatch_autoptr = *mut NMSettingOvsPatch;
pub type NMSettingOvsPatch_listautoptr = *mut GList;
pub type NMSettingOvsPatch_slistautoptr = *mut GSList;
pub type NMSettingOvsPatch_queueautoptr = *mut GQueue;
pub type NMSettingOvsPort_autoptr = *mut NMSettingOvsPort;
pub type NMSettingOvsPort_listautoptr = *mut GList;
pub type NMSettingOvsPort_slistautoptr = *mut GSList;
pub type NMSettingOvsPort_queueautoptr = *mut GQueue;
pub type NMSettingPpp_autoptr = *mut NMSettingPpp;
pub type NMSettingPpp_listautoptr = *mut GList;
pub type NMSettingPpp_slistautoptr = *mut GSList;
pub type NMSettingPpp_queueautoptr = *mut GQueue;
pub type NMSettingPppoe_autoptr = *mut NMSettingPppoe;
pub type NMSettingPppoe_listautoptr = *mut GList;
pub type NMSettingPppoe_slistautoptr = *mut GSList;
pub type NMSettingPppoe_queueautoptr = *mut GQueue;
pub type NMSettingProxy_autoptr = *mut NMSettingProxy;
pub type NMSettingProxy_listautoptr = *mut GList;
pub type NMSettingProxy_slistautoptr = *mut GSList;
pub type NMSettingProxy_queueautoptr = *mut GQueue;
pub type NMSettingSerial_autoptr = *mut NMSettingSerial;
pub type NMSettingSerial_listautoptr = *mut GList;
pub type NMSettingSerial_slistautoptr = *mut GSList;
pub type NMSettingSerial_queueautoptr = *mut GQueue;
pub type NMSettingSriov_autoptr = *mut NMSettingSriov;
pub type NMSettingSriov_listautoptr = *mut GList;
pub type NMSettingSriov_slistautoptr = *mut GSList;
pub type NMSettingSriov_queueautoptr = *mut GQueue;
pub type NMSettingTCConfig_autoptr = *mut NMSettingTCConfig;
pub type NMSettingTCConfig_listautoptr = *mut GList;
pub type NMSettingTCConfig_slistautoptr = *mut GSList;
pub type NMSettingTCConfig_queueautoptr = *mut GQueue;
pub type NMSettingTeam_autoptr = *mut NMSettingTeam;
pub type NMSettingTeam_listautoptr = *mut GList;
pub type NMSettingTeam_slistautoptr = *mut GSList;
pub type NMSettingTeam_queueautoptr = *mut GQueue;
pub type NMSettingTeamPort_autoptr = *mut NMSettingTeamPort;
pub type NMSettingTeamPort_listautoptr = *mut GList;
pub type NMSettingTeamPort_slistautoptr = *mut GSList;
pub type NMSettingTeamPort_queueautoptr = *mut GQueue;
pub type NMSettingTun_autoptr = *mut NMSettingTun;
pub type NMSettingTun_listautoptr = *mut GList;
pub type NMSettingTun_slistautoptr = *mut GSList;
pub type NMSettingTun_queueautoptr = *mut GQueue;
pub type NMSettingUser_autoptr = *mut NMSettingUser;
pub type NMSettingUser_listautoptr = *mut GList;
pub type NMSettingUser_slistautoptr = *mut GSList;
pub type NMSettingUser_queueautoptr = *mut GQueue;
pub type NMSettingVlan_autoptr = *mut NMSettingVlan;
pub type NMSettingVlan_listautoptr = *mut GList;
pub type NMSettingVlan_slistautoptr = *mut GSList;
pub type NMSettingVlan_queueautoptr = *mut GQueue;
pub type NMSettingVpn_autoptr = *mut NMSettingVpn;
pub type NMSettingVpn_listautoptr = *mut GList;
pub type NMSettingVpn_slistautoptr = *mut GSList;
pub type NMSettingVpn_queueautoptr = *mut GQueue;
pub type NMSettingVxlan_autoptr = *mut NMSettingVxlan;
pub type NMSettingVxlan_listautoptr = *mut GList;
pub type NMSettingVxlan_slistautoptr = *mut GSList;
pub type NMSettingVxlan_queueautoptr = *mut GQueue;
pub type NMSettingWifiP2P_autoptr = *mut NMSettingWifiP2P;
pub type NMSettingWifiP2P_listautoptr = *mut GList;
pub type NMSettingWifiP2P_slistautoptr = *mut GSList;
pub type NMSettingWifiP2P_queueautoptr = *mut GQueue;
pub type NMSettingWimax_autoptr = *mut NMSettingWimax;
pub type NMSettingWimax_listautoptr = *mut GList;
pub type NMSettingWimax_slistautoptr = *mut GSList;
pub type NMSettingWimax_queueautoptr = *mut GQueue;
pub type NMSettingWired_autoptr = *mut NMSettingWired;
pub type NMSettingWired_listautoptr = *mut GList;
pub type NMSettingWired_slistautoptr = *mut GSList;
pub type NMSettingWired_queueautoptr = *mut GQueue;
pub type NMSettingWireGuard_autoptr = *mut NMSettingWireGuard;
pub type NMSettingWireGuard_listautoptr = *mut GList;
pub type NMSettingWireGuard_slistautoptr = *mut GSList;
pub type NMSettingWireGuard_queueautoptr = *mut GQueue;
pub type NMSettingWireless_autoptr = *mut NMSettingWireless;
pub type NMSettingWireless_listautoptr = *mut GList;
pub type NMSettingWireless_slistautoptr = *mut GSList;
pub type NMSettingWireless_queueautoptr = *mut GQueue;
pub type NMSettingWirelessSecurity_autoptr = *mut NMSettingWirelessSecurity;
pub type NMSettingWirelessSecurity_listautoptr = *mut GList;
pub type NMSettingWirelessSecurity_slistautoptr = *mut GSList;
pub type NMSettingWirelessSecurity_queueautoptr = *mut GQueue;
pub type NMSettingWpan_autoptr = *mut NMSettingWpan;
pub type NMSettingWpan_listautoptr = *mut GList;
pub type NMSettingWpan_slistautoptr = *mut GSList;
pub type NMSettingWpan_queueautoptr = *mut GQueue;
pub type NMVpnConnection_autoptr = *mut NMVpnConnection;
pub type NMVpnConnection_listautoptr = *mut GList;
pub type NMVpnConnection_slistautoptr = *mut GSList;
pub type NMVpnConnection_queueautoptr = *mut GQueue;
pub type NMVpnEditor_autoptr = *mut NMVpnEditor;
pub type NMVpnEditor_listautoptr = *mut GList;
pub type NMVpnEditor_slistautoptr = *mut GSList;
pub type NMVpnEditor_queueautoptr = *mut GQueue;
pub type NMVpnEditorPlugin_autoptr = *mut NMVpnEditorPlugin;
pub type NMVpnEditorPlugin_listautoptr = *mut GList;
pub type NMVpnEditorPlugin_slistautoptr = *mut GSList;
pub type NMVpnEditorPlugin_queueautoptr = *mut GQueue;
pub type NMVpnPluginInfo_autoptr = *mut NMVpnPluginInfo;
pub type NMVpnPluginInfo_listautoptr = *mut GList;
pub type NMVpnPluginInfo_slistautoptr = *mut GSList;
pub type NMVpnPluginInfo_queueautoptr = *mut GQueue;
pub type NMVpnServicePlugin_autoptr = *mut NMVpnServicePlugin;
pub type NMVpnServicePlugin_listautoptr = *mut GList;
pub type NMVpnServicePlugin_slistautoptr = *mut GSList;
pub type NMVpnServicePlugin_queueautoptr = *mut GQueue;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMCheckpointClass {
    _unused: [u8; 0],
}
#[doc = " NMCheckpoint:"]
pub type NMCheckpointClass = _NMCheckpointClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMDeviceVrfClass {
    _unused: [u8; 0],
}
#[doc = " NMDeviceVrf:"]
pub type NMDeviceVrfClass = _NMDeviceVrfClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSecretAgentOld {
    _unused: [u8; 0],
}
pub type NMSecretAgentOld = _NMSecretAgentOld;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMSecretAgentOldClass {
    _unused: [u8; 0],
}
#[doc = " NMSecretAgent:"]
pub type NMSecretAgentOldClass = _NMSecretAgentOldClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVpnPluginOld {
    _unused: [u8; 0],
}
pub type NMVpnPluginOld = _NMVpnPluginOld;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NMVpnPluginOldClass {
    _unused: [u8; 0],
}
#[doc = " NMVpnPluginOld:"]
pub type NMVpnPluginOldClass = _NMVpnPluginOldClass;
extern "C" {
    pub fn nm_checkpoint_get_type() -> GType;
}
extern "C" {
    pub fn nm_device_vrf_get_type() -> GType;
}
extern "C" {
    pub fn nm_vpn_plugin_old_get_type() -> GType;
}
extern "C" {
    pub fn nm_secret_agent_old_get_type() -> GType;
}
